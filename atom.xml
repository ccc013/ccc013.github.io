<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Cai's blog]]></title>
  <subtitle><![CDATA[Stay hungry, stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ccc013.github.io/"/>
  <updated>2018-09-02T04:15:50.457Z</updated>
  <id>http://ccc013.github.io/</id>
  
  <author>
    <name><![CDATA[cai]]></name>
    <email><![CDATA[429546420@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[机器学习入门系列(2)--机器学习概览(下)]]></title>
    <link href="http://ccc013.github.io/2018/09/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97-2-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88-%E4%B8%8B/"/>
    <id>http://ccc013.github.io/2018/09/02/机器学习入门系列-2-机器学习概览-下/</id>
    <published>2018-09-02T03:04:09.000Z</published>
    <updated>2018-09-02T04:15:50.457Z</updated>
    <content type="html"><![CDATA[<p>这是本系列的第二篇，也是机器学习概览的下半部分。</p>
<h3 id="1-机器学习的主要挑战"><a href="#1-机器学习的主要挑战" class="headerlink" title="1. 机器学习的主要挑战"></a>1. 机器学习的主要挑战</h3><p>在介绍基于模型学习算法的流程的时候，对于预测结果不好的问题分析，主要说了是数据问题还是模型问题，这同时也就是机器学习的效果不好的两个主要原因，即错误的数据和错误的算法。</p>
<h4 id="1-1-训练数据量不足"><a href="#1-1-训练数据量不足" class="headerlink" title="1.1 训练数据量不足"></a>1.1 训练数据量不足</h4><p>第一个问题就是训练数据的数量问题，这是非常重要的问题。</p>
<p>因为即使是简单的问题，一般也需要数千的样本，这还是因为简单的问题一般采用简单的算法就可以解决，对于复杂的图像或语音问题，通常需要数百万的样本，特别是如果采用现在非常热门的深度学习算法，比如卷积神经网络模型，这些复杂的模型如果没有足够的数据量支持，非常容易陷入过拟合的情况。</p>
<p>实际上更多数量的训练集也是为了获得更有代表性的数据，能够学习到这类数据的所有特征。</p>
<p>但是，应该注意到，小型和中型的数据集仍然是非常常见的，获得额外的训练数据并不总是轻易和廉价的，所以不要抛弃算法。</p>
<h4 id="1-2-没有代表性的训练数据"><a href="#1-2-没有代表性的训练数据" class="headerlink" title="1.2 没有代表性的训练数据"></a>1.2 没有代表性的训练数据</h4><p>无论采用基于实例还是基于模型的学习，让训练数据对新数据具有代表性是非常重要的。如果训练集没有代表性，那么训练得到的模型就是不可能得到准确性的模型，比如人脸识别中，模型没有学习到某个人最明显的代表性的特征，比如高鼻梁或者没有眉毛等突出特征，那么模型对这个人的识别率就不会很高。</p>
<p>使用具有代表性的训练集对于推广到新案例是非常重要的。但是做起来比说起来要难：如果样本太小，就会有样本噪声（即会有一定概率包含没有代表性的数据），但是即使是非常大的样本也可能没有代表性，如果取样方法错误的话。这叫做样本偏差。</p>
<h4 id="1-3-低质量的数据"><a href="#1-3-低质量的数据" class="headerlink" title="1.3 低质量的数据"></a>1.3 低质量的数据</h4><p>低质量的数据指的是数据有错误、带有过多噪声或者是出现异常值等的数据，这种数据会影响系统整体的性能，因此，数据清洗对于构建一个机器学习系统或者一个机器学习项目来说都是必不可少的步骤。</p>
<p>对于这些低质量的数据，通常可以按照如下做法处理：</p>
<ul>
<li>如果一些实例是明显的异常值，最好删掉它们或尝试手工修改错误；</li>
<li>如果一些实例缺少特征（比如，你的 5% 的顾客没有说明年龄），你必须决定是否忽略这个属性、忽略这些实例、填入缺失值（比如，年龄中位数），或者训练一个含有这个特征的模型和一个不含有这个特征的模型，等等。</li>
</ul>
<h4 id="1-4-不相关的特征"><a href="#1-4-不相关的特征" class="headerlink" title="1.4 不相关的特征"></a>1.4 不相关的特征</h4><p>不相关的特征对于整个机器学习系统是有着反作用的效果，训练数据必须包含足够多的相关特征、非相关特征不多的情况下，才能训练出一个性能不错的模型。机器学习项目成功的关键之一是用好的特征进行训练。这个过程称作<strong>特征工程</strong>，包括：</p>
<ul>
<li>特征选择：在所有存在的特征中选取最有用的特征进行训练。</li>
<li>特征提取：组合存在的特征，生成一个更有用的特征（如前面看到的，可以使用降维算法）。</li>
<li>收集新数据创建新特征。</li>
</ul>
<h4 id="1-5-过拟合"><a href="#1-5-过拟合" class="headerlink" title="1.5 过拟合"></a>1.5 过拟合</h4><p>上述四种情况都是坏数据的情况，接下来是两种算法问题，也是机器学习最常见的两种算法方面的问题，过拟合和欠拟合。</p>
<p>过拟合就是指算法模型在训练集上的性能非常好，但是泛化能力很差，即在测试集上的效果却很糟糕的情况。比如下图，采用一个高阶多项式回归模型来预测生活满意度和人均 GDP 的关系，很明显看出来，这个模型过拟合了训练数据，其预测效果并不会达到在训练数据上这么好的效果。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E8%BF%87%E6%8B%9F%E5%90%88%E7%A4%BA%E4%BE%8B.png" alt="过拟合示例"></p>
<p>通常对于比较复杂的模型，比如深度神经网络，它能够检测和识别到数据中比较细微的规律和特征，但是如果训练集包含噪声，或者训练集数量太少（数量太少会引入样本噪声），这种情况下，模型同样会学习这种噪声，从而导致模型的泛化能力的下降。</p>
<p>一般解决过拟合的方法有：</p>
<ul>
<li>简化模型，这包括了采用简单点的模型、减少特征数量以及限制模型，即采用正则化；</li>
<li>增加训练数据</li>
<li>减小训练数据的噪声，即数据清洗，比如修正数据错误和去除异常值等</li>
</ul>
<p>其中正则化方法是比较常用的方法，它的作用就是限制模型，不让模型过于复杂，从而降低过拟合的风险或者是缓和过拟合的程度。常用的正则化方法是 L2 和 L1 正则化。正则化方法通常会采用一个超参数来控制其限制模型的强度。超参数是一个学习算法的参数（而不是模型的）。这样，它是不会被学习算法本身影响的，它优于训练，在训练中是保持不变的。如何调节超参数也是构建一个机器学习算法模型非常重要的一个步骤，也是让性能能够进一步提升的做法。</p>
<h4 id="1-6-欠拟合"><a href="#1-6-欠拟合" class="headerlink" title="1.6 欠拟合"></a>1.6 欠拟合</h4><p>欠拟合和过拟合刚好相反，它就是模型的性能非常差，在训练数据和测试数据上的性能都不好。</p>
<p>通常也是因为模型过于简单，没有能够很好学习到数据的有效的相关的特征，解决方法有：</p>
<ul>
<li>选择一个更强大的模型，带有更多参数</li>
<li>用更好的特征训练学习算法（特征工程）</li>
<li>减小对模型的限制（比如，减小正则化超参数）</li>
</ul>
<h3 id="2-测试和评估"><a href="#2-测试和评估" class="headerlink" title="2. 测试和评估"></a>2. 测试和评估</h3><p>当训练好一个机器学习模型后，接下来就需要对模型进行预测和评估，判断得到的模型是否可用，是否还能进行提升，并进行错误分析等操作。</p>
<p>一般在训练模型前，我们会将数据集分成两个集合，分别是训练集和测试集，通常 8:2 的比例，也就是 80% 的数据作为训练集，剩余是测试集。然后采用训练集训练模型，在测试集上用按照学习的问题采用对应评估指标评估模型的性能，比如分类问题，一般就是采用分类的准确率或者错误率作为评估的标准。</p>
<p>但这种划分数据集的方法，存在一个问题，就是如果需要调节超参数，比如对于正则化的超参数、学习率等，继续采用测试集来进行评估不同超参数对模型性能的影响，这会导致最后在测试集上测试得到性能最好的模型，实际上是过拟合了测试集，那么模型的泛化能力也不会太好。</p>
<p>所以，为了解决这个问题，我们还需要为调节超参数划分一个专门的数据集，测试集应该是用于测试最终得到的模型的性能。因此，我们再划分一个叫做验证集的数据集。</p>
<p>一种做法是可以将所有数据按照一定比例划分为训练集、验证集和测试集，比如按照 6:2:2 的比例划分；当然更通常的做法是采用交叉验证：训练集分成互补的子集，每个模型用不同的子集训练，再用剩下的子集验证。一旦确定模型类型和超参数，最终的模型使用这些超参数和全部的训练集进行训练，用测试集得到推广误差率。</p>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>最后我们总结下：</p>
<ol>
<li><p>机器学习的四个主要挑战是</p>
<ul>
<li>数据量太少</li>
<li>数据问题，包括没有代表性数据和质量差</li>
<li>不相关特征</li>
<li>模型过拟合或者欠拟合</li>
</ul>
</li>
<li>过拟合的解法方法有：<ul>
<li>简化模型，包括采用更简单的模型和更少的参数</li>
<li>正则化方法降低模型的复杂度</li>
<li>收集或者采用更大的数据集</li>
<li>数据清洗，去除噪声和异常值等</li>
</ul>
</li>
<li>欠拟合的解决方法：<ul>
<li>采用更强大的模型，包含更多的参数和学习能力</li>
<li>降低正则化的强度</li>
<li>使用更好的特征提取方法，即使用或者改善特征工程的工作</li>
</ul>
</li>
<li>采用交叉验证方法进行超参数条件和模型的选择</li>
</ol>
<p>以上就是本文的主要内容和总结，欢迎关注我的微信公众号—一个算法汪的技术成长之路或者扫描下方的二维码，和我分享你的建议和看法，指正文章中可能存在的错误，大家一起交流，学习和进步！</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/FqsJIpKGsF3-Qbu7bfQjzG-l0Ro9" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是本系列的第二篇，也是机器学习概览的下半部分。</p>
<h3 id="1-机器学习的主要挑战"><a href="#1-机器学习的主要挑战" class="headerlink" title="1. 机器学习的主要挑战"></a>1. 机器学习的主要挑战</h3><p>]]>
    </summary>
    
      <category term="技术" scheme="http://ccc013.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ccc013.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习入门系列(1)--机器学习概览(上)]]></title>
    <link href="http://ccc013.github.io/2018/09/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97-1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88-%E4%B8%8A/"/>
    <id>http://ccc013.github.io/2018/09/02/机器学习入门系列-1-机器学习概览-上/</id>
    <published>2018-09-02T02:32:41.000Z</published>
    <updated>2018-09-02T04:26:29.513Z</updated>
    <content type="html"><![CDATA[<p>最近打算系统学习和整理机器学习方面的知识，会将之前看的 Andrew Ng 在 course 课程笔记以及最近看的书籍《hands-on-ml-with-sklearn-and-tf》结合起来，简单总结下机器学习的常用算法，由于数学功底有限，所以可能不会也暂时不能过多深入公式和算法原理，所以就做成一个入门系列吧。</p>
<p>这是本系列的第一篇，也是机器学习概览的上半部分。</p>
<h3 id="1-什么是机器学习"><a href="#1-什么是机器学习" class="headerlink" title="1 . 什么是机器学习"></a>1 . 什么是机器学习</h3><p>简单的定义，<strong>机器学习是通过编程让计算机从数据中进行学习的科学（和艺术）</strong>。</p>
<p>但还有另外两种定义，一个更广义的定义：</p>
<blockquote>
<p>机器学习是让计算机具有学习的能力，无需进行明确编程。    ——    亚瑟·萨缪尔，1959</p>
</blockquote>
<p>和一个工程性的定义：</p>
<blockquote>
<p>计算机程序利用经验 E 学习任务    T，性能是 P，如果针对任务 T 的性能 P 随着经验 E 不断增长，则称为机器学习。    ——    汤姆·米切尔，1997</p>
</blockquote>
<p>一个简单的例子，也是经常提及的例子：垃圾邮件过滤器。它可以根据垃圾邮件（比如，用户标记的垃圾邮件）和普通邮件（非垃圾邮件，也称作 ham）学习标记垃圾邮件。用来进行学习的样例称作训练集。每个训练样例称作训练实例（或样本）。在这个例子中，任务 T 就是标记新邮件是否是垃圾邮件，经验E是训练数据，性能 P 需要定义：例如，可以使用正确分类的比例。这个性能指标称为准确率，通常用在分类任务中。</p>
<h3 id="2-为什么要用机器学习"><a href="#2-为什么要用机器学习" class="headerlink" title="2. 为什么要用机器学习"></a>2. 为什么要用机器学习</h3><p>为什么要用机器学习方法呢？</p>
<p>原因如下：</p>
<ul>
<li>需要进行大量手工调整或需要拥有长串规则才能解决的问题：机器学习算法通常可以<strong>简化代码、提高性能</strong>。</li>
<li>问题复杂，传统方法难以解决：最好的机器学习方法可以找到解决方案。</li>
<li>环境有波动：机器学习算法可以<strong>适应新数据</strong>。</li>
<li>洞察复杂问题和大量数据</li>
</ul>
<p>一些机器学习的应用例子：</p>
<ul>
<li>数据挖掘</li>
<li>一些无法通过手动编程来编写的应用：如自然语言处理，计算机视觉、语音识别等</li>
<li>一些自助式的程序：如推荐系统等</li>
<li>理解人类是如何学习的</li>
</ul>
<h3 id="3-机器学习系统的类型"><a href="#3-机器学习系统的类型" class="headerlink" title="3. 机器学习系统的类型"></a>3. 机器学习系统的类型</h3><p>机器学习有多种类型，可以根据如下规则进行分类：</p>
<ul>
<li>是否在人类监督下进行训练（监督，非监督，半监督和强化学习）<ul>
<li>是否可以动态渐进学习（在线学习 vs批量学习）</li>
<li>它们是否只是通过简单地比较新的数据点和已知的数据点，或者在训练数据中进行模式识别，以建立一个预测模型，就像科学家所做的那样（基于实例学习 vs基于模型学习）</li>
</ul>
</li>
</ul>
<h4 id="3-1-监督-非监督学习"><a href="#3-1-监督-非监督学习" class="headerlink" title="3.1 监督/非监督学习"></a>3.1 监督/非监督学习</h4><p>第一种分类机器学习的方法是可以根据训练时监督的量和类型进行分类。主要有四类：监督学习、非监督学习、半监督学习和强化学习。</p>
<h5 id="3-1-1-监督学习"><a href="#3-1-1-监督学习" class="headerlink" title="3.1.1 监督学习"></a>3.1.1 监督学习</h5><p>监督学习，顾名思义就是带有监督的学习，而监督就是体现在训练数据都是有标签的，所有在训练模型的时候可以根据数据的真实标签不断调整模型，从而得到一个性能更好的模型。</p>
<p>监督学习主要有两个常见的典型的任务—分类和回归。</p>
<h6 id="3-1-1-1-分类"><a href="#3-1-1-1-分类" class="headerlink" title="3.1.1.1 分类"></a>3.1.1.1 分类</h6><p>分类问题主要就是预测新数据的类别问题。例如上文提到的垃圾邮件过滤器就是一个二分类问题，将邮件分为垃圾邮件还是正常的邮件，如下图所示。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%88%86%E7%B1%BB%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h6 id="3-1-1-2-回归"><a href="#3-1-1-2-回归" class="headerlink" title="3.1.1.2 回归"></a>3.1.1.2 回归</h6><p>回归问题主要是预测目标数值。比如给定预测房价的问题，给定一些特征，如房子大小、房间数量、地理位置等等，然后预测房子的价格。如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%9E%E5%BD%92%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<p>注意，一些回归算法也可以用来进行分类，反之亦然。例如，逻辑回归通常用来进行分类，它可以生成一属于每个类别的概率值，然后选择最大概率的类别作为预测的类别。</p>
<p>常用的监督学习算法有：</p>
<ul>
<li>K近邻算法</li>
<li>线性回归</li>
<li>逻辑回归</li>
<li>支持向量机（SVM）</li>
<li>决策树和随机森林</li>
<li>神经网络</li>
</ul>
<h5 id="3-1-2-非监督学习"><a href="#3-1-2-非监督学习" class="headerlink" title="3.1.2 非监督学习"></a>3.1.2 非监督学习</h5><p>和监督学习相反，非监督学习就是采用没有标签的数据集。</p>
<p>非监督主要有四个典型的任务，分别是聚类、降维、异常检测和关联规则学习。</p>
<h6 id="3-1-2-1-聚类"><a href="#3-1-2-1-聚类" class="headerlink" title="3.1.2.1. 聚类"></a>3.1.2.1. 聚类</h6><p>聚类就是将数据根据一定的规则分成多个类，通常是采用相似性。比如对于博客访客的聚类，通过聚类算法，检测相似性访客的分组，如下图所示。不需要告诉算法访客是哪个类别，它会自动根据访客的属性找到相互间的关系，比如它可能找出访客的职业关系，将访客分为有 40% 的是上班族，有 50% 的是学生，或者对于技术博客，可能就是根据开发方向，划分为前端、后台、移动开发、人工智能等等。甚至，如果采用层次聚类分析算法，还可以继续对上述的分类进行更加详细的划分。这种做法可以帮助博主知道自己博客的主要群体是谁，更好规划自己博客发表的文章应该以什么方向为主。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E8%81%9A%E7%B1%BB%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<p>可视化算法也是极佳的非监督学习案例：<strong>给算法大量复杂的且不加标签的数据，算法输出数据的2D或3D图像</strong>。如下图所示，算法会试图保留数据的结构（即尝试保留输入的独立聚类，避免在图像中重叠），这样就可以明白数据是如何组织起来的，也许还能发现隐藏的规律。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%97%E6%B3%95.png" alt=""></p>
<h6 id="3-1-2-2-降维"><a href="#3-1-2-2-降维" class="headerlink" title="3.1.2.2. 降维"></a>3.1.2.2. 降维</h6><p>降维的目的是简化数据、但是不能失去大部分信息。做法之一是合并若干相关的特征。例如，汽车的里程数与车龄高度相关，降维算法就会将它们合并成一个，表示汽车的磨损。这叫做特征提取。</p>
<p>此外，在采用机器学习算法训练的时候，可以对训练集进行降维，这样有助于提高训练速度，降低占用的硬盘和内存空间，有时候也能提高算法的性能，但必须选择合适的降维算法，否则性能实际上是很有可能会下降的。</p>
<h6 id="3-1-2-3-异常检测"><a href="#3-1-2-3-异常检测" class="headerlink" title="3.1.2.3. 异常检测"></a>3.1.2.3. 异常检测</h6><p>另一个重要的非监督任务是异常检测（anomaly detection）。例如，检测异常的信用卡转账以防欺诈，检测制造缺陷，或者在训练之前自动从训练数据集去除异常值。异常检测的系统使用正常值训练的，当它碰到一个新实例，它可以判断这个新实例是像正常值还是异常值。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h6 id="3-1-2-4-关联规则学习"><a href="#3-1-2-4-关联规则学习" class="headerlink" title="3.1.2.4. 关联规则学习"></a>3.1.2.4. 关联规则学习</h6><p>最后，另一个常见的非监督任务是关联规则学习，它的目标是挖掘大量数据以发现属性间有趣的关系。例如，假设你拥有一个超市。在销售日志上运行关联规则，可能发现买了烧烤酱和薯片的人也会买牛排。因此，你可以将这些商品放在一起。</p>
<p>下面是一些最重要的非监督学习算法：</p>
<ol>
<li>聚类<ul>
<li>K 均值</li>
<li>层次聚类分析（Hierarchical Cluster Analysis, HCA）</li>
<li>期望最大值</li>
</ul>
</li>
<li>可视化和降维<ul>
<li>主成分分析（Principal    Component Analysis, PCA）</li>
<li>核主成分分析</li>
<li>局部线性嵌入（Locally-Linear Embedding, LLE）</li>
<li>t-分布邻域嵌入算法（t-distributed Stochastic Neighbor Embedding, t-SNE）</li>
</ul>
</li>
<li>关联性规则学习<ul>
<li>Apriori 算法<ul>
<li>Eclat算法</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="3-1-3-半监督学习"><a href="#3-1-3-半监督学习" class="headerlink" title="3.1.3 半监督学习"></a>3.1.3 半监督学习</h5><p>一些算法可以处理部分带标签的训练数据，通常是大量不带标签数据加上小部分带标签数据。这称作半监督学习。如下图所示，图中灰色圆点表示没有标签的数据，仅有几个三角形和正方形点表示带标签的数据。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%A4%BA%E4%BE%8B.png" alt="半监督学习示例"></p>
<p><strong>多数半监督学习算法是非监督和监督算法的结合</strong>。例如，深度信念网络（deep belief networks）是基于被称为互相叠加的受限玻尔兹曼机（restricted Boltzmann machines，RBM）的非监督组件。RBM 是先用非监督方法进行训练，再用监督学习方法进行整个系统微调。</p>
<p>半监督学习的示例，如一些图片存储服务，比如 Google Photos，是半监督学习的好例子。一旦你上传了所有家庭相片，它就能自动识别相同的人 A 出现了相片1、5、11    中，另一个人    B 出现在了相片 2、5、7 中。这是算法的非监督部分（聚类）。现在系统需要的就是你告诉这两个人是谁。只要给每个人一个标签，算法就可以命名每张照片中的每个人，特别适合搜索照片。</p>
<h5 id="3-1-4强化学习"><a href="#3-1-4强化学习" class="headerlink" title="3.1.4强化学习"></a>3.1.4强化学习</h5><p>强化学习和上述三种学习问题是非常不同的。学习系统在这里被称为<strong>智能体</strong>（ agent），可以对环境进行观察，选择和执行动作，获得<strong>奖励</strong>（负奖励是惩罚，见下图）。然后它必须自己学习哪个是最佳方法（称为<strong>策略</strong>，policy），以得到长久的最大奖励。策略决定了智能体在给定情况下应该采取的行动 。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.png" alt="强化学习示例"></p>
<p>目前强化学习的应用还不算非常广，特别是结合了深度学习的强化学习，主要是应用在机器人方面，当然最著名的一个应用就是 DeepMind 的 AlphaGo 了，它是通过分析数百万盘棋局学习制胜策略，然后自己和自己下棋。要注意，在比赛中机器学习是关闭的；AlphaGo    只是使用它学会的策略。 </p>
<h4 id="3-2-批量和在线学习"><a href="#3-2-批量和在线学习" class="headerlink" title="3.2 批量和在线学习"></a>3.2 批量和在线学习</h4><p>第二种分类机器学习的准则是，它是否能从导入的数据流进行持续学习。也就是如果导入的是持续的数据流，机器学习算法能否在不断采用新数据来训练已经训练好的模型，并且新的模型对新旧数据都还有很好的性能。</p>
<h5 id="3-2-1-批量学习"><a href="#3-2-1-批量学习" class="headerlink" title="3.2.1 批量学习"></a>3.2.1 批量学习</h5><p>在批量学习中，<strong>系统不能进行持续学习：必须用所有可用数据进行训练</strong>。这通常会占用大量时间和计算资源，所以一般是线下做的。首先是进行训练，然后部署在生产环境且停止学习，它只是使用已经学到的策略。这称为离线学习。</p>
<p>对于批量学习算法来说，当获取到新数据的时候，就需要重新重头训练整个数据集，然后更新模型，如果是应用该算法系统，那就相当于需要更新系统，需要停掉旧版本的系统，重新上线新版本的系统。</p>
<p>当然，一般训练、评估、部署一套机器学习的系统的整个过程可以自动进行，所以即便是批量学习也可以适应改变。只要有需要，就可以方便地更新数据、训练一个新版本。并且对于更新周期，可以选择每 24 小时或者每周更新一次。</p>
<p>但是，批量学习还是存在下面的缺点：</p>
<ol>
<li>实时性差，即对于需要快速适应变化的系统，比如预测股票变化、电商推荐系统等，就不适合采用批量学习算法；</li>
<li>耗费大量计算资源，用全部数据训练需要大量计算资源（CPU、内存空间、磁盘空间、磁盘 I/O、网络 I/O 等等），特别是训练集特别大的情况，更加凸显这个问题的严峻性；</li>
<li>无法应用在资源有限的设备上，比如需要自动学习的系统，但是如果采用智能手机，每次采用大量训练数据重新训练几个小时是非常不实际的。</li>
</ol>
<h5 id="3-2-2-在线学习"><a href="#3-2-2-在线学习" class="headerlink" title="3.2.2 在线学习"></a>3.2.2 在线学习</h5><p>批量学习的缺陷和问题可以通过采用在线学习算法来解决。</p>
<p>在在线学习中，是用数据实例持续地进行训练，可以一次一个或一次几个实例（称为小批量）。每个学习步骤都很快且廉价，所以系统可以动态地学习到达的新数据。</p>
<p>在线学习虽然名字带着在线两个字，但是实际上它的训练过程也是离线的，因此应该说是持续学习或者增量学习。</p>
<p>在线学习有下面几个优点：</p>
<ol>
<li>实时性好。在线学习算法非常适合接收连续流的数据，然后自动更新模型，实时性比批量学习更好；</li>
<li>可以节省大量计算资源。在线学习算法在学习新数据后，可以扔掉训练数据，从而节省大量存储空间；此外，训练得过程不需要加载所有训练数据，对于内存、CPU 等资源的要求也大大减少；</li>
<li>实现核外学习(out-of-core learning)。当内存不足以加载训练集的时候，可以采用在线学习算法多次训练，每次加载一部分训练集，即将一部分训练集当做新数据不断加载，直到训练完所有数据。</li>
</ol>
<p>在线学习也存在两个挑战：</p>
<ol>
<li>学习速率问题。学习速率是在线学习的一个重要参数，它反映了在线学习算法有多快地适应数据的改变，必须选择一个合适的学习速率，因为学习速率过大，系统可以很快适应新数据，但是也容易遗忘旧数据，比如图像分类问题，训练了一个 50 类分类器后，增加新的 10 类数据，一旦学习速率过快，系统只会记住新的 10 个类别，忘记了前面的 50 个类别的数据。相反的，如果你设定的学习速率低，系统的惰性就会强：即，它学的更慢，但对新数据中的噪声或没有代表性的数据点结果不那么敏感。</li>
<li>坏数据的影响。如果采用坏数据训练，会破坏系统的性能。要减小这种风险，你需要密集监测，如果检测到性能下降，要快速关闭（或是滚回到一个之前的状态）。你可能还要监测输入数据，对反常数据做出反应（比如，使用异常检测算法）。</li>
</ol>
<h4 id="3-3-基于实例-vs-基于模型学习"><a href="#3-3-基于实例-vs-基于模型学习" class="headerlink" title="3.3 基于实例 vs 基于模型学习"></a>3.3 基于实例 vs 基于模型学习</h4><p>第三种分类机器学习的方法是判断它们是如何进行归纳推广的。大多机器学习任务是关于预测的。这意味着给定一定数量的训练样本，系统需要能推广到之前没见到过的样本。对训练数据集有很好的性能还不够，真正的目标是对新实例预测的性能。</p>
<p>有两种主要的归纳方法：基于实例学习和基于模型学习。</p>
<h5 id="3-3-1-基于实例学习"><a href="#3-3-1-基于实例学习" class="headerlink" title="3.3.1 基于实例学习"></a>3.3.1 基于实例学习</h5><p>基于实例学习是系统先用记忆学习案例，然后使用相似度测量推广到新的例子，如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0%E7%A4%BA%E4%BE%8B.png" alt="基于实例学习示例"></p>
<p>这种学习算法可以说是机器学习中最简单的算法了，它实际上就是采用存储的数据集进行分类或者回归，典型的算法就是 KNN 算法，即 K 近邻算法，它就是将新的输入数据和已经保存的训练数据采用相似性度量（一般采用欧式距离）得到最近的 K 个训练样本，并采用 K 个训练样本中类别出现次数最多的类别作为预测的结果。</p>
<p>所以，这种算法的缺点就比较明显了：</p>
<ul>
<li>一是对存储空间的需求很大，需要占用的空间直接取决于实例数量的大小；</li>
<li>二是运行时间比较慢，因为需要需要与已知的实例进行比对。</li>
</ul>
<h5 id="3-3-2-基于模型学习"><a href="#3-3-2-基于模型学习" class="headerlink" title="3.3.2 基于模型学习"></a>3.3.2 基于模型学习</h5><p>和基于实例学习相反的就是基于模型学习：建立这些样本的模型，然后使用这个模型进行预测。如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%A4%BA%E4%BE%8B.png" alt="基于模型学习"></p>
<p>基于模型学习算法的流程一般如下所示：</p>
<ul>
<li>研究数据。先对数据进行分析，这可能包含清洗数据、特征筛选、特征组合等等</li>
<li>选择模型。选择合适的模型，从简单的线性回归、逻辑回归，到慢慢复杂的随机森林、集成学习，甚至深度学习的卷积神经网络模型等等</li>
<li>用训练数据进行训练。也就是寻找最适合算法模型的参数，使得代价函数取得最小值。</li>
<li>使用模型对新案例进行预测（这称作推断）。预测结果非常好，就能上线系统；如果不好，就需要进行错误分析，问题出现在哪里，是数据问题还是模型问题，找到问题，然后继续重复这个流程。</li>
</ul>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>最后，总结下：</p>
<ol>
<li>机器学习就是让机器通过学习数据得到解决更好解决某些问题的能力，而不需要确定的代码规则；</li>
<li>机器学习的应用非常广泛，包含图像、自然语言处理、语音、推荐系统和搜索等方面，每个方面还有更加具体详细的应用方向；</li>
<li>机器学习按照不同的划分标准可以分为不同的学习类型，包括监督和非监督学习、批量和在线学习，基于实例和基于模型学习；</li>
<li>最常见的监督学习任务是分类和回归；</li>
<li>常见的非监督学习任务是聚类、降维、异常值检测和关联规则学习；</li>
</ol>
<p>以上就是本文的主要内容和总结，欢迎关注我的微信公众号—一个算法汪的技术成长之路或者扫描下方的二维码，和我分享你的建议和看法，指正文章中可能存在的错误，大家一起交流，学习和进步！</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/FqsJIpKGsF3-Qbu7bfQjzG-l0Ro9" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近打算系统学习和整理机器学习方面的知识，会将之前看的 Andrew Ng 在 course 课程笔记以及最近看的书籍《hands-on-ml-with-sklearn-and-tf》结合起来，简单总结下机器学习的常用算法，由于数学功底有限，所以可能不会也暂时不能过多深入公]]>
    </summary>
    
      <category term="技术" scheme="http://ccc013.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://ccc013.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[卷积神经网络介绍]]></title>
    <link href="http://ccc013.github.io/2018/05/08/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8B%E7%BB%8D/"/>
    <id>http://ccc013.github.io/2018/05/08/卷积神经网络介绍/</id>
    <published>2018-05-08T03:04:39.000Z</published>
    <updated>2018-05-08T05:40:42.214Z</updated>
    <content type="html"><![CDATA[<p>记录在学习CNN过程中的一些知识点，包括参考的文章，论文或者博客等。</p>
<p>参考文章/书籍：</p>
<ol>
<li><a href="https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/" target="_blank" rel="external">An Intuitive Explanation of Convolutional Neural Networks</a></li>
<li><a href="http://blog.csdn.net/jiejinquanil/article/details/50042791" target="_blank" rel="external">对CNN中pooling的理解</a></li>
<li>《深度学习轻松学：核心算法与视觉实践》</li>
<li><a href="https://blog.csdn.net/lanran2/article/details/79057994" target="_blank" rel="external">ResNet解析</a></li>
</ol>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CNN可以应用在场景分类，图像分类，现在还可以应用到自然语言处理(NLP)方面的很多问题，比如句子分类等。</p>
<p><strong>LeNet</strong>是最早的CNN结构之一，它是由大神<strong>Yann LeCun</strong>所创造的，主要是用在字符分类问题。</p>
<p>下面是一个简单的CNN结构，图来自参考文章<a href="https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/" target="_blank" rel="external">1</a>。这个网络结构是用于一个四类分类的问题，分别是狗、猫、船和鸟，图中的输入图片是属于船一类。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/CNN1.png" alt="此处输入图片的描述"></p>
<p>该结构展示了四种运算，也可以说是由四种不同的层，分别是卷积层，非线性层(也就是使用了ReLU函数)，Pooling层，全连接层，下面将一一介绍这几种网络层。</p>
<hr>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><h4 id="卷积简介"><a href="#卷积简介" class="headerlink" title="卷积简介"></a>卷积简介</h4><p>  CNN的名字由来就是因为其使用了卷积运算的缘故。卷积的目的主要是为了提取图片的特征。卷积运算可以保持像素之间的空间关系。</p>
<p>  每张图片可以当做是一个包含每个像素值的矩阵，像素值的范围是0~255,0表示黑色，255是白色。下面是一个$5 \times 5$大小的矩阵例子，它的值是0或者1。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/CNN2.png" alt="此处输入图片的描述"></p>
<p>  接下来是另一个$3\times 3$矩阵：</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/CNN3.png" alt="此处输入图片的描述"></p>
<p>  上述两个矩阵通过卷积，可以得到如下图右侧粉色的矩阵结果。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/CNN4.png" alt="此处输入图片的描述"></p>
<p>  黄色的矩阵在绿色的矩阵上从左到右，从上到下，每次滑动的步进值是1个像素，所以得到一个$3\times 3$的矩阵。</p>
<p>  在CNN中，黄色的矩阵被叫做<strong>滤波器(filter)或者核(kernel)或者是特征提取器</strong>，而通过卷积得到的矩阵则是称为<strong>“特征图(Feature Map)”或者“Activation Map”</strong>。</p>
<p>  另外，<strong>使用不同的滤波器矩阵是可以得到不同的 Feature Map</strong> ，例子如下图所示：</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/CNN5.png" alt="此处输入图片的描述"></p>
<p>  上图通过滤波器矩阵，实现了不同的操作，比如边缘检测，锐化以及模糊操作等。</p>
<p>  在实际应用中，CNN是可以在其训练过程中学习到这些滤波器的值，不过我们需要首先指定好滤波器的大小，数量以及网络的结构。使用越多的滤波器，可以提取到更多的图像特征，网络也就能够有更好的性能。</p>
<p>  Feature Map的尺寸是由以下三个参数来决定的：</p>
<ul>
<li><strong>深度(Depth)</strong>： <strong>深度等于滤波器的数量</strong>。</li>
<li><strong>步进(Stride)</strong>: 步进值是在使用滤波器在输入矩阵上滑动的时候，每次滑动的距离。步进值越大，得到的Feature Map的尺寸越小。</li>
<li><strong>Zero-padding</strong>: 有时候可以在输入矩阵的边界填补0，这样就可以将滤波器应用到边缘的像素点上，一个好的Zero-padding是能让我们可以控制好特征图的尺寸的。使用该方法的卷积称为<strong>wide convolution</strong>，没有使用的则是<strong>narrow convolution</strong>。</li>
</ul>
<h4 id="卷积公式和参数量"><a href="#卷积公式和参数量" class="headerlink" title="卷积公式和参数量"></a>卷积公式和参数量</h4><p> 上一小节简单介绍了卷积的操作和其实现的效果，接下来将介绍卷积运算的公式，以及CNN中卷积层的参数数量。</p>
<p> 卷积是大自然中最常见的运算，一切信号观测、采集、传输和处理都可以用卷积过程实现，其用公式表达如下：</p>
<script type="math/tex; mode=display">
\begin{align}
Y(m,n) & =X(m,n)*H(m,n) \\ 
&= \sum_{i=-\infty}^{+\infty}\sum_{j=-\infty}^{+\infty}X(i,j)H(m-i,n-j) \\ &=\sum_{i=-\infty}^{+\infty}\sum_{j=-\infty}^{+\infty}X(m-i,n-j)H(i,j)
\end{align}</script><p>上述公式中$H(m,n)$表示卷积核。</p>
<p>在CNN中的卷积层的计算步骤与上述公式定义的二维卷积有点差异，首先是维度升至三维、四维卷积，跟二维卷积相比多了一个<strong>“通道”(channel)</strong>，每个通道还是按照二维卷积方式计算，而多个通道与多个卷积核分别进行二维卷积，得到多通道输出，需要“合并”为一个通道；<strong>其次是卷积核在卷积计算时没有“翻转”，而是与输入图片做滑动窗口“相关”计算</strong>。用公式重新表达如下：</p>
<script type="math/tex; mode=display">
Y^l(m,n) =X^k(m,n)*H^{kl}(m,n) = \sum_{k=0}^{K-1}\sum_{i=0}^{I-1}\sum_{j=0}^{J-1}X^k(m+i,n+j)H^{kl}(i,j)</script><p>这里假定卷积层有$L$个输出通道和$K$个输入通道，于是需要有$KL$个卷积核实现通道数目的转换。其中$X^k$表示第$k$个输入通道的二维特征图，$Y^l$表示第$l$个输出通道的二维特征图，$H^{kl}$表示第$k$行、第$l$列二维卷积核。假定卷积核大小是$I*J$,每个输出通道的特征图大小是$M×N$，则该层每个样本做一次前向传播时卷积层的计算量是$Calculations(MAC)=I×J×M×N×K×L$。</p>
<p>卷积层的学习参数，也就是<strong>卷积核数目乘以卷积核的尺寸—$Params = I×J×K×L$。</strong></p>
<p>这里定义计算量-参数量之比是<strong>CPR</strong>=$Calculations/Params=M×N$。</p>
<p>因此可以得出结论：<strong>卷积层的输出特征图尺寸越大，CPR越大，参数重复利用率越高。若输入一批大小为B的样本，则CPR值可提高B倍。</strong></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>卷积神经网络通过<strong>『参数减少』与『权值共享』</strong>大大减少了连接的个数，也即需要训练的参数的个数。</p>
<p>假设我们的图像是<code>1000*1000</code>的，则有10^6个隐层神经元，那么它们全连接的话，也就是每个隐层神经元都连接图像的每个像素点，就有10^12个连接，也即10^12个权值参数需要训练，这显然是不值得的。但是对于一个只识别特定feature的卷积核，需要大到覆盖整个图像的所有像素点吗？通常是不需要的，<strong>一个特定feature，尤其是第一层需要提取的feature，通常都相当基础，只占图像很小的一部分。所以我们设置一个较小的局部感受区域，比如<code>10*10</code>，也即每个神经元只需要和这<code>10*10</code>的局部图像相连接，所以10^6个神经元也就有10^8个连接。这就叫参数减少。</strong></p>
<p>那什么叫权值共享呢？在上面的局部连接中，10^6个神经元，每个神经元都对应100个参数，所以是10^8个参数，<strong>那如果每个神经元所对应的参数都是相同的，那需要训练的参数就只有100个了。</strong></p>
<p>这后面隐含的道理在于，<strong>这100个参数就是一个卷积核，而卷积核是提取feature的方式，与其在图像上的位置无关，图像一个局部的统计特征与其他局部的统计特征是一样的，我们用在这个局部抽取feature的卷积核也可以用在图像上的其它任何地方。</strong></p>
<p>而且这100个参数只是一种卷积核，只能提取一种feature，我们完全可以采用100个卷积核，提取100种feature，而所需要训练的参数也不过10^4，最开始我们训练10^12个参数，还只能提取一种特征。选取100个卷积核，我们就能得到100张FM，每张FM可以看做是一张图像的不同通道。</p>
<p>CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN特征检测层通过训练数据进行学习，在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者，由于同一FM上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，避免了特征提取和分类过程中数据重建的复杂度。</p>
<hr>
<h3 id="非线性层-ReLU"><a href="#非线性层-ReLU" class="headerlink" title="非线性层(ReLU)"></a>非线性层(ReLU)</h3><p>  非线性修正函数<strong>ReLU(Rectified Linear Unit)</strong>如下图所示：</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/CNN6.png" alt="此处输入图片的描述"></p>
<p>这是一个对每个像素点实现点乘运算，并用0来替换负值像素点。其目的是在CNN中加入非线性，<strong>因为使用CNN来解决的现实世界的问题都是非线性的，而卷积运算是线性运算，所以必须使用一个如ReLU的非线性函数来加入非线性的性质。</strong></p>
<p>其他非线性函数还包括<strong>tanh</strong>和<strong>Sigmoid</strong>,但是<strong>ReLU</strong>函数已经被证明在大部分情况下性能最好。</p>
<h3 id="Pooling层"><a href="#Pooling层" class="headerlink" title="Pooling层"></a>Pooling层</h3><p>  <strong>空间合并（Spatial Pooling)</strong>也可以叫做子采样或者下采样，可以在保持最重要的信息的同时降低特征图的维度。它有不同的类型，如最大化，平均，求和等等。</p>
<p>  对于<strong>Max Pooling</strong>操作，首先定义一个空间上的邻居，比如一个$2\times 2$的窗口，对该窗口内的经过ReLU的特征图提取最大的元素。除了提取最大的元素，还可以使用窗口内元素的平均值或者是求和的值。不过，<strong>Max Pooling</strong>的性能是最好的。例子可以如下图所示：</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/CNN7.png" alt="此处输入图片的描述"></p>
<p>  上图中使用的步进值是2。</p>
<p>根据相关理论，特征提取的误差主要来自两个方面：</p>
<ol>
<li>邻域大小受限造成的估计值方差增大；</li>
<li>卷积层参数误差造成估计均值的偏移。</li>
</ol>
<p><strong>一般来说，mean-pooling能减小第一种误差，更多的保留图像的背景信息，max-pooling能减小第二种误差，更多的保留纹理信息。</strong></p>
<p>  使用Pooling的原因有如下几点：</p>
<ul>
<li>不变性，更关注是否存在某些特征而不是特征具体的位置。可以看作加了一个很强的先验，让学到的特征要能容忍一些的变化。</li>
<li>减小下一层输入大小，减小计算量和参数个数。</li>
<li>获得定长输出。（文本分类的时候输入是不定长的，可以通过池化获得定长输出）</li>
<li>防止过拟合或有可能会带来欠拟合</li>
</ul>
<hr>
<h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>  全连接层就是一个传统的多层感知器，它在输出层使用一个<strong>softmax</strong>激活函数。其主要作用就是将前面卷积层提取到的特征结合在一起然后进行分类。<strong>Softmax</strong>函数可以将输入是一个任意实数分数的向量变成一个值的范围是0~1的向量，但所有值的总和是1。</p>
<p>  在CNN出现之前，最早的深度学习网络计算类型都是全连接形式的。</p>
<p>  全连接层的主要计算类型是<strong>矩阵-向量乘（GEMV)。</strong>假设输入节点组成的向量是$x$，维度是$D$,输出节点组成的向量是$y$,维度是$V$,则全连接层计算可以表示为$y=Wx$。</p>
<p>  其中$W$是$V×D$的权值矩阵。</p>
<p>  全连接层的参数量为$Params=V×D$,其单个样本前向传播的计算量也是$Calculations(MAC)=V×D$，也就是$CPR=Calculations/Params=1$。也就是其权值利用率很低。</p>
<p>  可以将一批大小为$B$的样本$x_i$逐列拼接成矩阵$X$，一次性通过全连接层，得到一批输出向量构成的矩阵$Y$，相应地前面的矩阵-向量乘运算升为<strong>矩阵-矩阵乘计算（GEMM)：$Y=WX$</strong>。</p>
<p>  这样全连接层前向计算量提高了$B$倍，CPR相应提高了$B$倍，权重矩阵在多个样本之间实现了共享，可提高计算速度。</p>
<p>  比较卷积层和全连接层，卷积层在输出特征图维度实现了<strong>权值共享</strong>，这是降低参数量的重要举措，同时，卷积层<strong>局部连接</strong>特性（相比全连接）也大幅减少了参数量。<strong>因此卷积层参数量占比小，但计算量占比大，而全连接层是参数量占比大，计算量占比小。所以在进行计算加速优化时，重点放在卷积层；在进行参数优化、权值剪裁时，重点放在全连接层。</strong></p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>激活函数是给网络提供非线性的特性，在每个网络层中对输入数据进行非线性变换的作用，这有两个好处。</p>
<ul>
<li><strong>对数据实现归一化操作</strong></li>
</ul>
<p>激活函数都有各自的取值范围，比如Sigmoid函数取值范围是[0,1]，Tanh函数取值范围是[-1,1]，这种好处对网络的正反向训练都有好处：</p>
<p>（1）正向计算网络的时候，由于输入数值的大小没有限制，其数值差距会非常大，第一个坏处是大数值会更被重视，而小数值的重要性会被忽视，其次，随着层数加深，这种大数值会不断累积到后面的网络层，最终可能导致数值爆炸溢出的情况；</p>
<p>（2）反向计算网络的时候，每层数值大小范围不同，有的在[0,1]，有的在[0,10000]，这在模型优化时会对设定反向求导的优化步长增加难度，设置过大会让梯度较大的维度因为过量更新而造成无法预期的结果；设置过小，梯度较小的维度会得不到充分的更新，就无法有所提升。</p>
<ul>
<li><strong>打破之前的线性映射关系。</strong></li>
</ul>
<p>如果网络只有线性部分，那么叠加多个网络层是没有意义的，因为多层神经网络可以退化为一层神经网络。</p>
<hr>
<h3 id="反向传播Backpropagation"><a href="#反向传播Backpropagation" class="headerlink" title="反向传播Backpropagation"></a>反向传播Backpropagation</h3><p>  CNN的整个训练过程如下所示：</p>
<ol>
<li>首先是随机初始化所有滤波器以及其他参数和权重值；</li>
<li>输入图片，进行前向传播，也就是经过卷积层，ReLU和pooling运算，最后到达全连接层进行分类，得到一个分类的结果，也就是输出一个包含每个类预测的概率值的向量；</li>
<li>计算误差，也就是代价函数，这里代价函数可以有多种计算方法，比较常用的有平方和函数，即$实际值预测值Error = \frac{1}{2}\sum(实际值-预测值)^2$；</li>
<li>使用反向传播来计算网络中对应各个权重的误差的梯度，一般是使用梯度下降法来更新各个滤波器的权重值，目的是为了让输出的误差，也就是代价函数的值尽可能小。</li>
<li>重复上述第二到第四步，直到训练次数达到设定好的值。</li>
</ol>
<hr>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>这里简单介绍比较有名的网络结构。</p>
<h4 id="1-LeNet（1990s）"><a href="#1-LeNet（1990s）" class="headerlink" title="1.LeNet（1990s）"></a>1.LeNet（1990s）</h4><p>在开头介绍了，这是最早使用的CNN网络结构之一，主要是用于字符分类；</p>
<p>   特点如下：</p>
<ul>
<li>卷积神经网络使用3层架构：卷积、下采样、非线性激活函数</li>
<li>使用卷积提取图像空间特征<ul>
<li>下采样使用了图像平均稀疏性</li>
<li>激活函数采用了tanh或者sigmoid函数</li>
<li>多层神经网络（MLP）作为最后的分类器</li>
<li>层之间使用稀疏连接矩阵，以避免大的计算成本</li>
</ul>
</li>
</ul>
<h4 id="2-AlexNet（2012）"><a href="#2-AlexNet（2012）" class="headerlink" title="2. AlexNet（2012）"></a>2. AlexNet（2012）</h4><p>这是在2012年的ImageNet视觉挑战比赛上获得第一名所使用的网络结构，这也是使得许多视觉问题取得重大突破，让CNN变得非常热门的原因。总结下其改进地方：</p>
<ul>
<li>使用ReLU函数作为激活函数，降低了Sigmoid类函数的计算量</li>
<li>利用dropout技术在训练期间选择性地剪掉某些神经元，避免模型过度拟合</li>
<li>引入max-pooling技术</li>
<li>利用双GPU NVIDIA GTX 580显著减少训练时间</li>
</ul>
<h4 id="3-ZF-Net（2013）"><a href="#3-ZF-Net（2013）" class="headerlink" title="3. ZF Net（2013）"></a>3. ZF Net（2013）</h4><p>这是2013年ImageNet比赛的胜者，对AlexNet的结构超参数做出了调整。</p>
<h4 id="4-GoogleNet（2014）"><a href="#4-GoogleNet（2014）" class="headerlink" title="4. GoogleNet（2014）"></a>4. GoogleNet（2014）</h4><p>2014年ImageNet比赛的胜者，其主要贡献是使用了一个<strong>Inception Module</strong>，可以大幅度减少网络的参数数量，其参数数量是4M，而AlexNet的则有60M。</p>
<h4 id="5-VGGNet（2014）"><a href="#5-VGGNet（2014）" class="headerlink" title="5.VGGNet（2014）"></a>5.VGGNet（2014）</h4><p>这是一个更深的网络，使用了16层的结构。<strong>它是对原始图像进行3×3卷积，然后再进行3×3卷积，连续使用小的卷积核对图像进行多次卷积。</strong>VGG一开始提出的时候刚好与LeNet的设计原则相违背，<strong>因为LeNet相信大的卷积核能够捕获图像当中相似的特征（权值共享）。</strong>AlexNet在浅层网络开始的时候也是使用9×9、11×11卷积核，并且尽量在浅层网络的时候避免使用1×1的卷积核。但是VGG的神奇之处就是在于使用多个3×3卷积核可以模仿较大卷积核那样对图像进行局部感知。后来多个小的卷积核串联这一思想被GoogleNet和ResNet等吸收。</p>
<p>   <strong>VGG相信如果使用大的卷积核将会造成很大的时间浪费，减少的卷积核能够减少参数，节省运算开销。虽然训练的时间变长了，但是总体来说预测的时间和参数都是减少的了。</strong></p>
<h4 id="6-ResNets（2015）"><a href="#6-ResNets（2015）" class="headerlink" title="6.ResNets（2015）"></a>6.ResNets（2015）</h4><p>随着网络的加深，出现了<strong>训练集准确率下降</strong>的现象，我们可以确定<strong>这不是由于Overfit过拟合造成的(过拟合的情况训练集应该准确率很高)</strong>；所以作者针对这个问题提出了一种全新的网络，叫深度残差网络，它允许网络尽可能的加深，其中引入了全新的结构如下图；<br><img src="https://img-blog.csdn.net/20180508132926226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjMDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>残差指的是什么？</strong><br>其中ResNet提出了两种mapping：一种是<strong>identity mapping</strong>，指的就是上图中”弯弯的曲线”，另一种<strong>residual mapping</strong>，指的就是除了”弯弯的曲线“那部分，所以最后的输出是 y=F(x)+x<br>identity mapping顾名思义，就是指本身，也就是公式中的x，而residual mapping指的是“差”，也就是y−x，所以残差指的就是F(x)部分。<br><strong>为什么ResNet可以解决“随着网络加深，准确率不下降”的问题？</strong><br>理论上，对于“随着网络加深，准确率下降”的问题，Resnet提供了两种选择方式，也就是identity mapping和residual mapping，<strong>如果网络已经到达最优，继续加深网络，residual mapping将被push为0，只剩下identity mapping，这样理论上网络一直处于最优状态了，网络的性能也就不会随着深度增加而降低了。</strong></p>
<p>​    </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录在学习CNN过程中的一些知识点，包括参考的文章，论文或者博客等。</p>
<p>参考文章/书籍：</p>
<ol>
<li><a href="https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/]]>
    </summary>
    
      <category term="卷积神经网络" scheme="http://ccc013.github.io/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="机器学习" scheme="http://ccc013.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://ccc013.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016总结 & 2017展望]]></title>
    <link href="http://ccc013.github.io/2016/12/31/2016%E6%80%BB%E7%BB%93-2017%E5%B1%95%E6%9C%9B/"/>
    <id>http://ccc013.github.io/2016/12/31/2016总结-2017展望/</id>
    <published>2016-12-31T08:30:39.000Z</published>
    <updated>2017-01-01T04:14:36.010Z</updated>
    <content type="html"><![CDATA[<h4 id="2016-总结"><a href="#2016-总结" class="headerlink" title="2016 总结"></a>2016 总结</h4><p>对于2016年，最大的感觉还是自己还总是处于变化的过程吧，主要是对求职方向的变化，上半年主要是处于学习Android的过程，但是后来听了师兄的话后，大概就是6月底，就开始转变，想要往机器学习算法岗位准备，然后到了10月份左右，随着时间和自己准备两方面考虑，又决定应该往C++开发，但是跟师兄交流后，发现似乎这个方向需要准备的东西要更多，还是好好准备机器学习算法岗位吧。这么来来回回变化，也是自己性格上的缺点吧，缺乏恒心，不能坚持太久，或者其实是自己太过浮躁了，每次都有点过于冲动地考虑，又特别容易后悔自己做过的决定，这真的是需要在未来的一年里面去改进的，需要有恒心，专心和坚持完成一件事情。</p>
<p>科研进展方向，自己是写了一篇中文的论文，第一次投稿是被拒绝了，现在第二次投稿，尚处于审稿中，希望可以顺利收录；然后就是看了多篇论文啦，还看完一本介绍Caffe的，也尝试修改了一些代码，但是基本是根据网上别人的代码来修改的，复现的方法也能找到代码，现在毕设题目也是确定了，需要做的就是设计自己的算法，能够有足够的创新性吧。</p>
<p>编程方面，上半年也是看了一两本Android方面的书，然后C++方面，看完《C++ primer plus》，看完《大话数据结构》和《数据结构算法与应用：C++描述》，算法方面则看了《剑指offer》，看完《机器学习》（年终最后一天完成），《现代操作系统》则根据师兄的建议，看完前面比较重要的六章，而Linux方面，正在看鸟哥的《Linux私房菜—基础学习篇》，看完前面十一章内容，打算是看到第三部分的，目前就剩下两章内容，估计需要多两到三天的时间。这是书籍方面的阅读，此外，还有到LeetCode上刷题，目前做了20多道题目，然后在牛客网上也做了不少编程题目，数据结构和操作系统练习，都需要继续坚持。</p>
<p>此外，还是有坚持做了一些笔记，主要是数据结构和算法学习的笔记，需要继续保持。在博客方面，我的技术博客上是发表了30篇日志，当然主要是数据结构学习的比较和总结文章。而在CSDN博客方面，也写了有37篇博文，主要是下半年开始增多，前面主要是机器学习的时候的笔记，之后就是有一些论文阅读笔记和算法学习笔记。而Github方面，今年提交次数也有两百多近三百，当然提交的也都是上述的笔记内容。</p>
<p>其他，锻炼方面也是断断续续做着，还不能很好地坚持，所以基本上体重没有比去年减少多少，跑步方面，15年是总共跑了33次，总计里程是129.59km，而16年跑步次数增加到36次，总里程是144.08km，增加得不是很明显，按照每月跑步算是，月均3次而已；而在力量训练方面，总共锻炼时间是630分钟，总共锻炼次数是47次。</p>
<p>旅游方面，上半年去了武汉参加一次会议，然后都是省内游了。</p>
<h4 id="2017-展望"><a href="#2017-展望" class="headerlink" title="2017 展望"></a>2017 展望</h4><p>首先是希望在上半年找到一份比较好的实习，目前求职岗位是机器学习算法，所以希望找到机器学习算法相关的岗位，所以这需要前面两个多月继续好好看书，刷题准备；</p>
<p>其次是希望投稿的论文可以顺利被收录，这样也可以达成毕业条件了。</p>
<p>接着就是下半年秋招可以找到一份好的工作，实习的时候也要争取能收到留下的offer。</p>
<p>最后就是搞定毕设，写好毕设论文了。</p>
<p>上述算是明年比较重要的四件事情了。在这其中，对于找实习还是工作，首先还是需要继续学习，书籍阅读方面，《统计学习方法》是需要好好看透，理解好的，然后《TCP/IP 协议》也要看，掌握网络知识；python方面的知识也要复习一下；然后就是看看《大话设计模式》和《STL源码剖析》，继续加强C++编程能力。</p>
<p>然后需要继续坚持做笔记，写博客，上传代码到Github。希望博客内容可以有更多干货，不只是阅读书籍的学习笔记，还有更多实践内容，比如一些自己做的项目代码，一些应用的实现等。</p>
<p>最后就是坚持锻炼身体，继续减脂训练，跑步和力量训练都要有序进行，计划跑步方面，总里程要达到300km左右，如果每次跑步在4km以上，那么需要总共跑75次，也就是平均每月6-7次左右；然后力量训练方面是总训练时间达到1200分钟，如果平均每次锻炼时间是30分钟，需要锻炼40次，平均到每月就是3-4次。</p>
<p>总而言之，希望能够更加专注，更加坚持，脚踏实地做好每件计划好的事情。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="2016-总结"><a href="#2016-总结" class="headerlink" title="2016 总结"></a>2016 总结</h4><p>对于2016年，最大的感觉还是自己还总是处于变化的过程吧，主要是对求职方向的变化，上半年主要是处于学]]>
    </summary>
    
      <category term="总结" scheme="http://ccc013.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="随笔" scheme="http://ccc013.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <link href="http://ccc013.github.io/2016/11/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ccc013.github.io/2016/11/20/排序算法总结/</id>
    <published>2016-11-20T05:27:44.000Z</published>
    <updated>2016-12-08T03:18:55.965Z</updated>
    <content type="html"><![CDATA[<p>这是《大话数据结构》第九章排序算法的知识点总结。</p>
<h4 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h4><blockquote>
<p>假设含有n个记录的序列为${r_1,r_2,\cdots,r_n}$，其相应的关键字分别为${k_1,k_2,\cdots,k_n}$，需要确定$1,2, \cdots, n$的一种排列$p_1,p_2,\cdots,p_n$，使其相应的关键字满足$k_{p1}\le k_{p2}\le \cdots \le k_{pn}$非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列${r_{p1}, r_{p2}, \cdots, r_{pn}}$，这样的操作就称为排序。</p>
</blockquote>
<p><strong>在排序问题中，通常将数据元素称为记录。</strong></p>
<p>排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p>
<p>这里关键字$k_i$可以是记录$r$的主关键字，也可以是次关键字，甚至是若干数据项的组合。</p>
<h5 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h5><p>由于排序不仅是针对主关键字，还有针对次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，下面给出稳定与不稳定排序的定义。</p>
<blockquote>
<p>假设$k_i = k_j \ (1\le i \le n, 1\le j\le n, i\neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i \lt j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先于$r_i$，则称所用的排序方法是不稳定的。</p>
</blockquote>
<p>不稳定的排序算法有：<strong>希尔、快速、堆排和选择排序</strong>。</p>
<h5 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h5><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序可以分为：内排序和外排序。</p>
<blockquote>
<p>内排序是在排序整个过程中，<strong>待排序的所有记录全部被放置在内存中</strong>。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要<strong>在内外存之间多次交换数据才能进行</strong>。</p>
</blockquote>
<p>对于内排序来说，排序算法的性能主要是受到3个方面的影响：</p>
<h6 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h6><p>在内排序中，主要进行两种操作：<strong>比较和移动</strong>。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</p>
<h6 id="辅助空间"><a href="#辅助空间" class="headerlink" title="辅助空间"></a>辅助空间</h6><p>辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</p>
<h6 id="算法的复杂性"><a href="#算法的复杂性" class="headerlink" title="算法的复杂性"></a>算法的复杂性</h6><p>这里指的是算法本身的复杂度，而不是算法的时间复杂度。</p>
<p>根据排序过程中借助的主要操作，我们把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序。</strong></p>
<h5 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h5><p>这里先提供一个用于排序用的顺序表结构，这个结构将用于接下来介绍的所有排序算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">10</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 用于存储待排序数组</span></span><br><span class="line">  <span class="keyword">int</span> r[MAXSIZE]; </span><br><span class="line">  <span class="comment">// 用于记录顺序表的长度</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>此外，由于排序最常用到的操作是数组两元素的交换，这里写成一个函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换L中数组r的下标为i和j的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = L-&gt;r[i];</span><br><span class="line">  L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">  L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p><strong>冒泡排序(Bubble sort)是一种交换排序。</strong>它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。</p>
</blockquote>
<p>首先介绍一个简单版本的冒泡排序算法的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序初级版</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort0</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不算是标准的冒泡排序算法，因为不满足“两两比较相邻记录”的冒泡排序思想，它更应该是最简单的交换排序。它的思路是让每一个关键字都和后面的每一个关键字比较，如果大或小则进行交换，这样关键字在一次循环后，第一个位置的关键字会变成最大值或者最小值。</p>
<p>这个最简单的实现算法效率是非常低的。</p>
<p>下面介绍正宗的冒泡排序算法实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正宗的冒泡排序算法实现代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = L-&gt;length - <span class="number">2</span>; j &gt;= i; j--)&#123;</span><br><span class="line">			<span class="comment">// j是从后往前循环</span></span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里改变的地方是在内循环中，<code>j</code>是从数组最后往前进行比较，并且是逐个往前进行相邻记录的比较，这样最大值或者最小值会在第一次循环过后，从后面浮现到第一个位置，如同气泡一样浮到上面。</p>
<p>这段实现代码其实还是可以进行优化的，例如待排序数组是<code>{2,1,3,4,5,6,7,8,9}</code>,需要进行递增排序，可以发现其实只需要交换前两个元素的位置即可完成，但是上述算法还是会在交换完这两者位置后继续进行循环，这样效率就不高了，所以可以在算法中增加一个标志，当有一次循环中没有进行数据交换，就证明数组已经是完成排序的，此时就可以退出算法，实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进版冒泡算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSortOptimz</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length &amp;&amp; flag; i++)&#123;</span><br><span class="line">		<span class="comment">// 若 flag为false则退出循环</span></span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = L-&gt;length - <span class="number">2</span>; j &gt;= i; j--)&#123;</span><br><span class="line">			<span class="comment">// j是从后往前循环</span></span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 如果有数据交换，则flag是true</span></span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法的时间复杂度是$O(n^2)$。</p>
<p>完整的冒泡排序算法代码可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/SortAlgorithms/BubbleSortTest.cpp" target="_blank" rel="external">BubbleSort</a>。</p>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><blockquote>
<p>简单选择排序算法(Simple Selection Sort)就是通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字中最小的记录，并和第$i(1\le i \le n)$个记录进行交换。</p>
</blockquote>
<p>下面是实现的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单选择排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, min;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">		min = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &lt; L-&gt;r[min])</span><br><span class="line">				min = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若min不等于i，说明找到最小值，进行交换</span></span><br><span class="line">		<span class="keyword">if</span> (min != i)</span><br><span class="line">			swap(L, i, min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单选择排序的最大特点就是交换移动数据次数相当少。分析其时间复杂度发现，无论最好最差的情况，比较次数都是一样的，都需要比较$\sum_{i=1}^{n-1} (n-i) = (n-1)+(n-2)+\cdots+2+1=\frac{n(n-1)}{2}$次。对于交换次数，最好的时候是交换0次，而最差的情况是$n-1$次。因此，总的时间复杂度是$O(n^2)$，虽然与冒泡排序一样的时间复杂度，但是其性能上还是略好于冒泡排序。</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><blockquote>
<p>直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增加1的有序表。</p>
</blockquote>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j,val;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="comment">// 将L-&gt;r[i]插入有序表中,使用val保存待插入的数组元素L-&gt;r[i]</span></span><br><span class="line">			val = L-&gt;r[i];</span><br><span class="line">			<span class="keyword">for</span> (j = i - <span class="number">1</span>; L-&gt;r[j]&gt;val; j--)</span><br><span class="line">				<span class="comment">// 记录后移</span></span><br><span class="line">				L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[j];	</span><br><span class="line">			<span class="comment">// 插入到正确位置</span></span><br><span class="line">			L-&gt;r[j + <span class="number">1</span>] =val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接插入排序算法是需要有一个保存待插入数值的辅助空间。</p>
<p>在时间复杂度方面，最好的情况是待排序的表本身就是有序的，如{2,3,4,5,6}，比较次数则是$n-1$次，然后不需要进行移动，时间复杂度是$O(n)$。</p>
<p>最差的情况就是待排序表是逆序的情况，如{6,5,4,3,2},此时需要比较$\sum_{i=2}^{n} i = \frac{(n+2)(n-1)}{2}$次，而记录的移动次数也达到最大值$\sum_{i=2}^{n} (i+1) = \frac{(n+4)(n-1)}{2}$次。</p>
<p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为$\frac{n^2}{4}$。因此，可以得出直接插入排序算法的时间复杂度是$O(n^2)$。同时也可以看出，直接插入排序算法会比冒泡排序和简单选择排序算法的性能要更好一些。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>上述三种排序算法的时间复杂度都是$O(n^2)$，而希尔排序是突破这个时间复杂度的第一批算法之一。</p>
<p>其实直接插入排序的效率在某些情况下是非常高效的，这些情况是指记录本来就很少或者待排序的表基本有序的情况，但是这两种情况都是特殊情况，在现实中比较少见。而希尔排序就是通过创造条件来改进直接插入排序的算法。</p>
<p>希尔排序的做法是<strong>将原本有大量记录数的记录进行分组，分割成若干个序列</strong>，这样每个子序列待排序的记录就比较少了，然后就可以对子序列分别进行直接插入排序，<strong>当整个序列基本有序时，再对全体记录进行一次直接插入排序。</strong></p>
<p>这里的<strong>基本有序是指小的关键字基本在前面，大的基本在后面，不大不小的在中间。</strong>像{2,1,3,6,4,7,5,8,9}可以称为基本有序。</p>
<p>这里的关键就是如何进行分割，希尔排序采取的是<strong>跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</strong></p>
<p>实现的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j,val;</span><br><span class="line">	<span class="keyword">int</span> increment = L-&gt;length;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="comment">// 增量序列</span></span><br><span class="line">		increment = increment / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = increment; i &lt;= L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i - increment])&#123;</span><br><span class="line">				<span class="comment">// 将L-&gt;r[i]插入有序表中,使用val保存待插入的数组元素L-&gt;r[i]</span></span><br><span class="line">				val = L-&gt;r[i];</span><br><span class="line">				<span class="keyword">for</span> (j = i - increment; j &gt;= <span class="number">0</span> &amp;&amp; L-&gt;r[j]&gt;val; j -= increment)</span><br><span class="line">					<span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">					L-&gt;r[j + increment] = L-&gt;r[j];</span><br><span class="line">				L-&gt;r[j + increment] = val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中增量的选取是<code>increment = increment / 3 + 1</code>，实际上增量的选取是非常关键的，现在还没有人找到一种最好的增量序列，但是大量研究表明，当增量序列是$\delta [k] = 2^{t-k+1} - 1 (0\le k \le t \le \lfloor log_2(n+1)\rfloor)$时，可以获得不错的效率，其时间复杂度是$O(n^{\frac{3}{2}})$，要好于直接插入排序的$O(n^2)$。当然，这里需要注意的是<strong>增量序列的最后一个增量值必须等于1才行</strong>。此外，由于记录是跳跃式的移动，<strong>希尔排序是不稳定的排序算法</strong>。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>有一个数量为Size个数的数组A，数组的值范围为(0 - Max)，然后创建一个大小为<code>Max+1</code>的数组B，每个元素都为0.从头遍历A，当读取到A[i]的时候，B[A[i]]的值+1，这样所有的A数组被遍历后，直接扫描B之后，输出表B就可以了。然后再根据B来对A进行排序。</p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得未排序数组中最大的一个元素值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxVal</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxVal = arr[<span class="number">0</span>]; <span class="comment">//假设最大为arr[0]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)  <span class="comment">//遍历比较，找到大的就赋值给maxVal</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">			maxVal = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxVal;  <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong input!"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> size = GetMaxVal(numbers,length) + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(size);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">		bucket[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算数组中每个元素出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = numbers[i];</span><br><span class="line">		bucket[j] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (bucket[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++)&#123;</span><br><span class="line">				numbers[count] = i;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>简单选择排序在待排序的$n$个记录中选择一个最小的记录需要比较$n-1$次，这是查找第一个数据，所以需要比较这么多次是比较正常的，但是可惜的是它没有把每一趟的比较结果保存下来，这导致在后面的比较中，实际有许多比较在前一趟中已经做过了。因此，如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就会变得很高了。</p>
<p>堆排序(Heap Sort)就是对简单选择排序进行的一种改进，并且效果非常明显。</p>
<blockquote>
<p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为最大堆或者大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为最小堆或者小顶堆。</p>
</blockquote>
<p>下图是一个例子，左边的是大顶堆，而右边的是小顶堆。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png" alt=""></p>
<p>而根据堆的定义，可以知道根结点一定是堆中所有结点最大或者最小者。如果按照层遍历的方式给结点从1开始编号，则结点之间满足下列关系：</p>
<script type="math/tex; mode=display">
\begin{cases}
k_i \ge k_{2i} \\\
k_i \ge k_{2i+1}
\end{cases}
或 
\begin{cases}
k_i \le k_{2i} \\\
k_i \le k_{2i+1}
\end{cases}
1 \le i \le \lfloor \frac{n}{2} \rfloor</script><p>如果将上图按照层遍历存入数组，则一定满足上述关系表达，得到的数组如下图所示。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png" alt=""></p>
<blockquote>
<p>堆排序的基本思想是，将待排序的序列构成一个最大堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素进行交换，此时末尾元素就是最大值），然后将剩余的$n-1$个序列重新构成一个堆，这样就会得到$n$个元素中的次最大值。如此反复执行，便能得到一个有序序列。</p>
</blockquote>
<p>下面将给出堆排序算法的代码实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知L-&gt;r[s...m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义</span></span><br><span class="line"><span class="comment">// 本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp, j;</span><br><span class="line">	temp = L-&gt;r[s];</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m - <span class="number">1</span>; j *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="comment">// 沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">		<span class="keyword">if</span> (j &lt; m-<span class="number">1</span> &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">			<span class="comment">// j是关键字中较大的记录的下标</span></span><br><span class="line">			++j;</span><br><span class="line">		<span class="keyword">if</span> (temp &gt;= L-&gt;r[j])</span><br><span class="line">			<span class="comment">// 当前值不需要进行调整</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		L-&gt;r[s] = L-&gt;r[j];</span><br><span class="line">		s = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	L-&gt;r[s] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = L-&gt;length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 将待排序的序列构成一个最大堆</span></span><br><span class="line">		HeapAdjust(L, i, L-&gt;length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始进行排序</span></span><br><span class="line">	<span class="keyword">for</span> (i = L-&gt;length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 将堆顶记录与当前未经排序的子序列的最后一个记录交换</span></span><br><span class="line">		swap(L, <span class="number">0</span>, i);</span><br><span class="line">		<span class="comment">// 重新调整为最大堆</span></span><br><span class="line">		HeapAdjust(L, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，堆排序分两步走，首先是将待排序的序列构造成最大堆，这也是<code>HeapSort()</code>中第一个循环所做的事情，第二个循环也就是第二步，进行堆排序，逐步将每个最大值的根结点和末尾元素进行交换，然后再调整成最大堆，重复执行。</p>
<p>而在第一步中构造最大堆的过程中，是从$\lfloor \frac{n}{2} \rfloor$的位置开始进行构造，这是从下往上、从右到左，将每个非叶结点当作根结点，将其和其子树调整成最大堆。</p>
<p>接下来就是分享堆排序的效率了。堆排序的运行时间主要是消耗在初始构造堆和在重建堆时的反复筛选上。</p>
<p>在构建堆的过程中，因为是从完全二叉树的最下层最右边的非叶结点开始构建，将它与其孩子进行比较和若有必要的交换，对每个非叶结点，最多进行两次比较和互换操作，这里需要进行这种操作的非叶结点数目是$\lfloor \frac{n}{2} \rfloor$个，所以整个构建堆的时间复杂度是$O(n)$。</p>
<p>在正式排序的时候，第$i$取堆顶记录重建堆需要用$O(log i)$的时间(完全二叉树的某个结点到根结点的距离是$\lfloor log_2i \rfloor + 1$)，并且需要取$n-1$次堆顶记录，因此，重建堆的时间复杂度是$O(nlogn)$。</p>
<p><strong>所以，总体上来说，堆排序的时间复杂度是$O(nlogn)$。</strong>由于堆排序对原始记录的排序状态并不敏感，因此它无论最好、最坏和平均时间复杂度都是$O(nlogn)$。同样由于记录的比较与交换是跳跃式进行，<strong>堆排序也不是稳定的排序算法。</strong></p>
<p>另外，由于初始构建堆需要的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>归并排序(Merging Sort)就是利用归并的思想实现的排序方法，它的原理是假设初始序列有$n$个记录，则可以看成是$n$个有序的子序列，每个子序列的长度为1，然后两两合并，得到$\lceil \frac{n}{2} \rceil$($\lceil x \rceil$表示不小于$x$的最小整数)个长度为2或1的有序子序列；再两两合并，$\cdots \cdots$，如此重复，直至得到一个长度为$n$的有序序列为止，这种排序方法称为2路归并排序。</p>
</blockquote>
<p>下面是介绍实现的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序,使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	MSort(L-&gt;r, L -&gt;r, <span class="number">0</span>, L-&gt;length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将SR[s..t]归并排序为TR1[s..t]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR1[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> TR2[MAXSIZE];</span><br><span class="line">	<span class="keyword">if</span> (s == t)</span><br><span class="line">		TR1[s] = SR[s];</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 将SR[s..t]平分为SR[s...m-1]和SR[m...t]</span></span><br><span class="line">		m = (s + t) / <span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		MSort(SR, TR2, s, m-<span class="number">1</span>);</span><br><span class="line">		MSort(SR, TR2, m, t);</span><br><span class="line">		<span class="comment">// 将TR2[s..m-1]和TR2[m..t]归并到TR1[s..t]</span></span><br><span class="line">		Merge(TR2, TR1, s, m-<span class="number">1</span>, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, k, l;</span><br><span class="line">	<span class="keyword">for</span> (j = m+<span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;</span><br><span class="line">		<span class="comment">// 将SR中记录由小到大并入TR</span></span><br><span class="line">		<span class="keyword">if</span> (SR[i] &lt; SR[j])</span><br><span class="line">			TR[k] = SR[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			TR[k] = SR[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= m)&#123;</span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= m - i; l++)</span><br><span class="line">			<span class="comment">// 将剩余的SR[i..m]复制到TR</span></span><br><span class="line">			TR[k + l] = SR[i + l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &lt;= n)&#123;</span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">			<span class="comment">// 将剩余的SR[j..n-1]复制到TR</span></span><br><span class="line">			TR[k + l] = SR[j + l];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是一个递归版本的归并排序实现算法，其中函数<code>MSort()</code>的作用是将待排序序列进行分割，然后<code>Merge()</code>函数会对需要归并的序列进行排序并两两归并在一起。</p>
<p><strong>归并排序的时间复杂度是$O(nlogn)$，并且无论是最好、最坏还是平均都是同样的时间性能。</strong>另外，在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，并且递归时需要深度为$log_2 n$的栈空间，因此空间复杂度是$O(n+logn)$。</p>
<p>另外，归并排序是使用两两比较，不存在跳跃，这在<code>Merge()</code>中的语句<code>if(SR[i]&lt;SR[j])</code>可以看出，<strong>所以归并排序是一个稳定的排序算法。</strong></p>
<p><strong>总体来说，归并排序是一个比较占用内存，但效率高且稳定的算法。</strong></p>
<p>下面会介绍一个非递归版本的归并排序算法实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 非递归版本的归并排序</span><br><span class="line">void MergeSort2(SqList *L)&#123;</span><br><span class="line">	// 申请额外空间</span><br><span class="line">	int* TR = (int *)malloc(L-&gt;length * sizeof(int));</span><br><span class="line">	int k = 1;</span><br><span class="line">	while (k &lt; L-&gt;length)&#123;</span><br><span class="line">		MergePass(L-&gt;r, TR, k, L-&gt;length);</span><br><span class="line">		// 子序列长度加倍</span><br><span class="line">		k = 2 * k;</span><br><span class="line">		MergePass(TR, L-&gt;r, k, L-&gt;length);</span><br><span class="line">		k = 2 * k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将SR[]中相邻长度为s的子序列两两归并到TR[]</span><br><span class="line">void MergePass(int SR[], int TR[], int s, int n)&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j;</span><br><span class="line">	while (i &lt;= n - 2 * s)&#123;</span><br><span class="line">		// 两两归并</span><br><span class="line">		Merge(SR, TR, i, i + s - 1, i + 2 * s - 1);</span><br><span class="line">		i = i + 2 * s;</span><br><span class="line">	&#125;</span><br><span class="line">	if (i &lt; n - s + 1)</span><br><span class="line">		// 归并最后两个子序列</span><br><span class="line">		Merge(SR, TR, i, i + s - 1, n - 1);</span><br><span class="line">	else&#123;</span><br><span class="line">		// 若最后剩下单个子序列</span><br><span class="line">		for (j = i; j &lt;= n - 1; j++)</span><br><span class="line">			TR[j] = SR[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]</span><br><span class="line">void Merge(int SR[], int TR[], int i, int m, int n)&#123;</span><br><span class="line">	int j, k, l;</span><br><span class="line">	for (j = m+1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;</span><br><span class="line">		// 将SR中记录由小到大并入TR</span><br><span class="line">		if (SR[i] &lt; SR[j])</span><br><span class="line">			TR[k] = SR[i++];</span><br><span class="line">		else</span><br><span class="line">			TR[k] = SR[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	if (i &lt;= m)&#123;</span><br><span class="line">		for (l = 0; l &lt;= m - i; l++)</span><br><span class="line">			// 将剩余的SR[i..m]复制到TR</span><br><span class="line">			TR[k + l] = SR[i + l];</span><br><span class="line">	&#125;</span><br><span class="line">	if (j &lt;= n)&#123;</span><br><span class="line">		for (l = 0; l &lt;= n - j; l++)</span><br><span class="line">			// 将剩余的SR[j..n-1]复制到TR</span><br><span class="line">			TR[k + l] = SR[j + l];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归版本的归并排序算法避免了递归时深度为$log_2 n$的栈空间，空间复杂度是$O(n)$，并且避免递归也在时间性能上有一定的提升。应该说，使用归并排序时，尽量考虑用非递归方法。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>在前面介绍的几种排序算法，希尔排序相当于直接插入排序的升级，它们属于插入排序类，而堆排序相当于简单选择排序的升级，它们是属于选择排序类，而接下来介绍的快速排序就是冒泡排序的升级，它们属于交换排序类。</p>
<blockquote>
<p>快速排序(Quick Sort)的基本思想是：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
</blockquote>
<p>下面给出实现的快速排序算法代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	QSort(L, <span class="number">0</span>, L-&gt;length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">		<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">		pivot = Partition(L, low, high);</span><br><span class="line">		<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">		QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 对高子序列递归排序</span></span><br><span class="line">		QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换待排序序列L中子表的记录，使枢轴记录到位，并返回其所在位置</span></span><br><span class="line"><span class="comment">// 并使得其之前位置的值小于它，后面位置的值大于它</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot_key;</span><br><span class="line">	<span class="comment">// 初始值设置为子表的第一个记录</span></span><br><span class="line">	pivot_key = L-&gt;r[low];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivot_key)</span><br><span class="line">			high--;</span><br><span class="line">		<span class="comment">// 将小于枢轴记录的值交换到低端</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivot_key)</span><br><span class="line">			low++;</span><br><span class="line">		<span class="comment">// 将大于枢轴记录的值交换到高端</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码同样是使用了递归，其中<code>Partition()</code>函数要做的就是先选取待排序序列中的一个关键字，然后将其放在一个位置，这个位置左边的值小于它，右边的值都大于它，这样的值被称为枢轴。</p>
<p>快速排序的时间性能取决于快速排序递归的深度。在最优情况下，<code>Partition()</code>每次都划分得很均匀，如果排序$n$个关键字，其递归树的深度技术$\lfloor log_ n \rfloor +1$，即需要递归$log_2n$次，其时间复杂度是$O(nlogn)$。而最坏的情况下，待排序的序列是正序或逆序，得到的递归树是斜树，最终其时间复杂度是$O(n^2)$。</p>
<p><strong>平均情况可以得到时间复杂度是$O(nlogn)$，而空间复杂度的平均情况是$O(logn)$。但是由于关键字的比较和交换是跳跃进行的，所以快速排序也是不稳定排序。</strong></p>
<h5 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h5><p>快速排序算法是有许多地方可以优化的，下面给出一些优化的方案。</p>
<h6 id="优化选取枢轴"><a href="#优化选取枢轴" class="headerlink" title="优化选取枢轴"></a>优化选取枢轴</h6><p>枢轴的值太大或者太小都会影响快速排序的性能，一个改进方法是<strong>三数取中</strong>法，即<strong>取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数</strong>。</p>
<p>需要在<code>Partition()</code>函数中做出下列修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pivot_key;</span><br><span class="line">	<span class="comment">// 使用三数取中法选取枢轴</span></span><br><span class="line">	<span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[low] &gt; L-&gt;r[high])</span><br><span class="line">		<span class="comment">// 保证左端最小</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m] &gt; L-&gt;r[high])</span><br><span class="line">		<span class="comment">// 保证中间较小</span></span><br><span class="line">		swap(L, high, m);</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m] &gt; L-&gt;r[low])</span><br><span class="line">		<span class="comment">// 保证左端较小</span></span><br><span class="line">		swap(L, m, low);</span><br><span class="line"></span><br><span class="line">	pivot_key = L-&gt;r[low];</span><br></pre></td></tr></table></figure>
<p>三数取中对小数组有很大的概率取到一个比较好的枢轴值，但是对于非常大的待排序的序列还是不足以保证得到一个比较好的枢轴值，因此还有一个办法是<strong>九数取中法</strong>，它先从数组中分三次取样，每次去三个数，三个样品各自取出中数，然后从这三个中数当中再取出一个中数作为枢轴。</p>
<h6 id="优化不必要的交换"><a href="#优化不必要的交换" class="headerlink" title="优化不必要的交换"></a>优化不必要的交换</h6><p>优化后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pivot_key = L-&gt;r[low];</span><br><span class="line"><span class="keyword">int</span> temp = pivot_key;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivot_key)</span><br><span class="line">		high--;</span><br><span class="line">	<span class="comment">// 将小于枢轴记录的值交换到低端</span></span><br><span class="line">	<span class="comment">// swap(L, low, high);</span></span><br><span class="line">	<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">	L-&gt;r[low] = L-&gt;r[high];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivot_key)</span><br><span class="line">		low++;</span><br><span class="line">	<span class="comment">// 将大于枢轴记录的值交换到高端</span></span><br><span class="line">	<span class="comment">// swap(L, low, high);</span></span><br><span class="line">	<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">	L-&gt;r[high] = L-&gt;r[low];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将枢轴值替换回L.r[low]</span></span><br><span class="line">L-&gt;r[low] = temp;</span><br><span class="line"><span class="keyword">return</span> low;</span><br></pre></td></tr></table></figure>
<p>这里可以减少多次交换数据的操作，性能上可以得到一定的提高。</p>
<h6 id="优化小数组时的排序方案"><a href="#优化小数组时的排序方案" class="headerlink" title="优化小数组时的排序方案"></a>优化小数组时的排序方案</h6><p>当数组比较小的时候，快速排序的性能其实还不如直接插入排序(直接插入排序是简单排序中性能最好的)。其原因是快速排序使用了递归操作，在有大量数据排序时，递归操作的影响是可以忽略的，但如果只有少数记录需要排序，这个影响就比较大，所以下面给出改进的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_LENGTH_INSERT_SORT <span class="number">7</span> </span></span><br><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class="line">		<span class="comment">// 当high - low 大于常数时用快速排序</span></span><br><span class="line">		<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">		pivot = Partition(L, low, high);</span><br><span class="line">		<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">		QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 对高子序列递归排序</span></span><br><span class="line">		QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 否则使用直接插入排序</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是先进行一个判断，当数组的数量大于一个预设定的常数时，才进行快速排序，否则就进行直接插入排序。这样可以保证最大化地利用两种排序的优势来完成排序工作。</p>
<h6 id="优化递归操作"><a href="#优化递归操作" class="headerlink" title="优化递归操作"></a>优化递归操作</h6><p>递归对性能是有一定影响的，<code>QSort()</code>在其尾部有两次递归操作，如果待排序的序列划分极端不平衡，递归的深度将趋近于$n$，而不是平衡时的$log_2 n$，这就不仅仅是速度快慢的问题了。栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此，如果能减少递归，将会大大提高性能。</p>
<p>下面给出对<code>QSort()</code>实施尾递归优化的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class="line">		<span class="comment">// 当high - low 大于常数时用快速排序</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">			<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">			pivot = Partition(L, low, high);</span><br><span class="line">			<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">			QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 尾递归</span></span><br><span class="line">			low = pivot + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 否则使用直接插入排序</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中使用<code>while</code>循环，并且去掉原来的对高子序列进行递归，改成代码<code>low = privot + 1</code>，那么在进行一次递归后，再进行循环，就相当于原来的<code>QSort(L,privot+1,high);</code>，结果相同，但是从递归变成了迭代，可以缩减堆栈深度，从而提高了整体性能。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述总共介绍了7种排序算法，首先是根据排序过程中借助的主要操作，将内排序分为：插入排序、交换排序、选择排序和归并排序，如下图所示。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png" alt=""></p>
<p>事实上，目前还没有十全十美的排序算法，都是各有优点和缺点，即使是快速排序算法，也只是整体上性能优越，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。</p>
<p>下面对这7种算法的各种指标进行对比，如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%954.png" alt=""></p>
<p>从算法的简单性来看，可以分为两类：</p>
<ul>
<li>简单算法：冒泡、简单选择、直接插入。</li>
<li>改进算法：快速、堆、希尔、归并。</li>
</ul>
<p>从平均情况看，快速、堆、归并三种改进算法都优于希尔排序，并远远胜过3种简单算法。</p>
<p>从最好情况看，冒泡和直接插入排序要更好一点，即当待排序序列是基本有序的时候，应该考虑这两种排序算法，而非4种复杂的改进算法。</p>
<p>从最坏情况看，堆和归并排序比其他排序算法都要更好。</p>
<p>从空间复杂度看，归并排序和快速排序都对空间有要求，而其他排序反而都只是$O(1)$的复杂度。</p>
<p>从稳定性上看，归并排序是改进算法中唯一稳定的算法。而不稳定的排序算法有“快些选堆”，即快速、希尔、选择和堆排序四种算法（书中给出的简单选择排序是不稳定的，但是从网上查找资料看到选择排序是一个不稳定的算法）。</p>
<p>排序算法的总结就到这里，实际上还是要根据实际问题来选择适合的排序算法。</p>
<p>全部排序算法的代码可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/SortAlgorithms" target="_blank" rel="external">排序算法实现代码</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是《大话数据结构》第九章排序算法的知识点总结。</p>
<h4 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h4><blockquo]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图的基本定义]]></title>
    <link href="http://ccc013.github.io/2016/11/08/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/"/>
    <id>http://ccc013.github.io/2016/11/08/图的基本定义/</id>
    <published>2016-11-08T09:18:08.000Z</published>
    <updated>2016-11-08T09:21:46.527Z</updated>
    <content type="html"><![CDATA[<p>这是《大话数据结构》第七章图的基本知识总结，首先是总结图的基本定义和相关的术语，包括有向图，无向图，连通图等术语的定义。</p>
<blockquote>
<p>图(Graph)是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为：<strong>G（V, E）</strong>，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p>
</blockquote>
<p>对于上述图的定义，需要注意的是：</p>
<ul>
<li>线性表中的数据元素被称为元素，树中将数据元素称为结点，而图中数据元素被称为<strong>顶点</strong></li>
<li>线性表可以没有数据元素，称为空表；树也可以没有结点，称为空树。但是图的定义中强调了顶点集合<strong>V</strong>是有穷非空的集合，所以图结构中不能没有顶点。</li>
<li>线性表中，相邻的数据元素之间具有线性关系；树结构中，相邻两层的结点具有层次关系。而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</strong></li>
</ul>
<h5 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h5><p>接下来会介绍各自图的定义，包括无向图与有向图，有向完全图和无向完全图，稀疏与稠密图等。</p>
<blockquote>
<p>无向边： 若顶点$v_i$ 到$v_j$之间的边没有方向，则称这条边为<strong>无向边(Edge)</strong>,用无序偶对$(v_i, v_j)$来表示。</p>
</blockquote>
<p>如果图中任意两个顶点之间的边都是无向边，则称该图是<strong>无向图</strong>。</p>
<p>如下图左边的图就是一个无向图$G_1$，$G_1 = （V_1,{E_1}）$，其中顶点集合 $V_1 = {A,B,C,D}$,边集合是$E_1 = {(A, B), (B, C), (C, D), (D, A), (A, C)}$。</p>
<blockquote>
<p>有向边： 若顶点$v_i$ 到$v_j$之间的边有方向，则称这条边为<strong>有向边，也称为弧(Arc)</strong>。用有序偶$<v_i, v_j="">$来表示，$v_i$称为弧尾，$v_j$称为弧头。</v_i,></p>
</blockquote>
<p>如果图中任意两个顶点之间的边都是有向边，则称该图是<strong>有向图</strong>。</p>
<p>如下图右边的图就是一个有向图 $G_2$，$G_2 =（V_2, {E_2}） $,其中顶点集合 $V_2 = {A,B,C,D}$,边集合是$E_2 = {<a, d="">, <b, a="">, <c, a="">, <b, c="">}$。</b,></c,></b,></a,></p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE1.png" alt=""></p>
<p>这里需要注意有向图中有向边的表示是不能随意乱写的，必须是按照定义中$<v_i, v_j="">$，弧尾在前，弧头在后的写法。</v_i,></p>
<blockquote>
<p>图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图是简单图。</p>
</blockquote>
<p>如下图所示都不是简单图，而我们主要讨论的都是简单图。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE2.png" alt=""></p>
<blockquote>
<p><strong>无向完全图</strong>是指在无向图中，任意两个顶点之间都存在边。</p>
</blockquote>
<p>含有$n$个顶点的无向完全图有$\frac{n\times (n-1)}{2}$条边。</p>
<blockquote>
<p><strong>有向完全图</strong>是指在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。</p>
</blockquote>
<p>含有$n$个顶点的有向完全图有$n\times (n-1)$条边。</p>
<p>由此可以得到一个结论：</p>
<p><strong>对于具有$n$个顶点和$e$条边数的图，无向图有$0 \le e \le \frac{n\times (n-1)}{2}$, 有向图有$0 \le e \le n \times (n-1)$</strong>。</p>
<blockquote>
<p>有很少边或弧的图称为稀疏图，反之称为稠密图。</p>
</blockquote>
<p>这里的稀疏与稠密都是相对而言的。</p>
<blockquote>
<p>与图的边或弧相关的数值称为<strong>权(Weight)</strong>，它可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为<strong>网(Network)</strong>。</p>
</blockquote>
<p>下图就是一个带权的图的例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE3.png" alt=""></p>
<blockquote>
<p>假设有两个图 $G = （V，{E}）$，和 $G^\prime = （V^\prime,  {E^\prime}） $,如果$V^\prime \subseteq V$, 且 $E^\prime \subseteq E$,则称$G^\prime$是$G$的子图。</p>
</blockquote>
<p>下面展示了无向图和有向图与其子图。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE4.png" alt=""></p>
<h5 id="图的顶点与边的关系"><a href="#图的顶点与边的关系" class="headerlink" title="图的顶点与边的关系"></a>图的顶点与边的关系</h5><blockquote>
<p>在无向图 $G=(V,{E})$，如果边 $(v, v^\prime) \in E$,则称顶点$v和v^\prime$互为<strong>邻接点(Adjacent)</strong>,即$v 和 v^\prime$相邻接。边$(v, v^\prime)$依附(incident)于顶点$v 和 v^\prime$，或者说$(v,v^\prime)$与顶点$v 和 v^\prime$相关联。<strong>顶点$v$的度(Degree)是和$v$相关联的边的数目，记为TD($v$)。</strong></p>
</blockquote>
<p>例如对于上图中上方的无向图，顶点A与B互为邻接点，边(A, B)依附于顶点A与B上，顶点A的度为3。通过计算，可以知道，<strong>无向图的边数是各顶点度数和的一半，即$e = \frac{1}{2} \sum_{i=1}^n TD(v_i)$。</strong></p>
<blockquote>
<p>有向图 $G=(V,{E})$,如果弧$<v,v^\prime> \in E$, 则称顶点$v$邻接到顶点$v^\prime$，顶点$v^\prime$邻接自顶点$v$。弧$<v,v^\prime>$和顶点$v,v^\prime$相关联。<strong>以顶点$v$为头的弧的数目称为$v$的入度(InDegree),记为$ID(v)$；以顶点$v$为尾的弧的数目称为$v$的出度(OutDegree),记为$OD(v)$,因此顶点$v$的度为$TD(v) = ID(v) + OD(v)$。</strong> </v,v^\prime></v,v^\prime></p>
</blockquote>
<p>例如对上图中下方的有向图，顶点A的入度是2（从B到A的弧，C到A的弧），出度是1（从A到D的弧），所以顶点A的度是3。同样通过计算，可以得到$e =\sum_{i=1}^n ID(v_i) = \sum_{i=1}^n OD(v_i) $。</p>
<blockquote>
<p>在无向图 $G=(V,{E})$中从顶点$v$到$v^\prime$的<strong>路径(Path)</strong>是一个顶点序列$(v=v_{i,0},v_{i,1},\cdots,v_{i,m}=v^\prime),其中(v_{i,j-1},v_{i,j}) \in E, 1 \le j \le m$。</p>
</blockquote>
<p>下图就展示了顶点B到顶点D的四种不同路径。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE5.png" alt=""></p>
<p>如果$G$是有向图，则路径也是有向的，顶点序列应满足$<v_{i,j-1}, v_{i,j}=""> \in E, 1 \le j \le m$。如下图所示，顶点B到D右两种路径，而顶点A到B就不存在路径。</v_{i,j-1},></p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE6.png" alt=""></p>
<blockquote>
<p><strong>路径的长度是路径上的边或弧的数目。</strong></p>
</blockquote>
<p>如上图有向图中，左侧的路径长度是2，经过两条弧，而右侧的路径长度是3，经过3条弧。</p>
<blockquote>
<p>第一个顶点到最后一个顶点相同的路径称为<strong>回路或环(Cycle)</strong>。序列中顶点不重复出现的路径称为<strong>简单路径</strong>。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为<strong>简单回路或简单环</strong>。</p>
</blockquote>
<p>下图中，两个图都是一个环，但左侧的图是一个简单环，而右侧图中顶点C重复出现，因此它不是一个简单环。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE7.png" alt=""></p>
<h5 id="连通图相关术语"><a href="#连通图相关术语" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h5><p>接下来会介绍有关连通图的定义和相关术语。</p>
<blockquote>
<p>无向图$G$中，如果从顶点$v$到$v^\prime$有路径，则称$v$和$v^\prime$是<strong>连通的。</strong>如果对于图中<strong>任意两个顶点$v_i、v_j \in V$，$v_i$和$v_j$都是连通的，则称$G$是连通图。</strong></p>
</blockquote>
<p><strong>无向图中的极大连通子图称为连通分量</strong>。这个连通分量的前提条件有：</p>
<ul>
<li>是子图；</li>
<li>子图是要连通的；</li>
<li>连通子图要有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<blockquote>
<p>有向图$G$中，如果对于每一对$v_i,v_j \in V, v_i \neq v_j$,从$v_i$到$v_j$和从$v_j$到$v_i$都存在路径，则称$G$是<strong>强连通图</strong>。有向图中的<strong>极大强连通子图</strong>称做有向图的<strong>强连通分量</strong>。</p>
</blockquote>
<p>如下图所示，图1并不是强连通图，因为顶点A到顶点D存在路径，但不存在从顶点D到顶点A的路径。图2就是强连通图，而且显然图2是图1的极大强连通子图，即是它的强连通分量。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE8.png" alt=""></p>
<p>接下来是连通图的生成树定义：</p>
<blockquote>
<p>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的 n-1 条边。</p>
</blockquote>
<p>如下图所示，图1是一个普通图，但是显然它不是生成树，当去掉两条构成环的边后，如图2或图3，就满足生成树的条件了，即n个顶点和n-1条边且连通的定义，它们都是一棵生成树。由此可以得知，<strong>如果一个图有n个顶点和小于n-1条边，则是非连通图；如果它多于n-1条边，则必定构成一个环。</strong>但有n-1条边也不一定是生成树，如图4。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE9.png" alt=""></p>
<p>接下来是有向树的定义：</p>
<blockquote>
<p>如果一个有向图中<strong>恰有一个顶点的入度为0，其余顶点的入度均为1</strong>，则是一棵有向树。</p>
</blockquote>
<p>这里入度为0的顶点就相当于树的根结点，而其余顶点的入度都是1，是因为树的非根结点的双亲只有1个。</p>
<blockquote>
<p>一个有向图的生成森林由<strong>若干棵有向树组成，含有图中全部顶点</strong>，但<strong>只有足以构成若干棵不相交的有向树的弧。</strong></p>
</blockquote>
<p>如下图所示，图1是一个有向图，再去掉一些弧后，得到图2和图3，也就是分解成两棵有向树，即图2和图3，而这两棵有向树也是图1有向图的生成森林。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE10.png" alt=""></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>图的基本定义就简单总结到这里，图的术语还是不比树的少，需要多看几遍，同时多使用，接下来会继续总结图的存储结构、遍历等知识点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是《大话数据结构》第七章图的基本知识总结，首先是总结图的基本定义和相关的术语，包括有向图，无向图，连通图等术语的定义。</p>
<blockquote>
<p>图(Graph)是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为：<strong>G（V, E）</str]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树2]]></title>
    <link href="http://ccc013.github.io/2016/10/28/%E4%BA%8C%E5%8F%89%E6%A0%912/"/>
    <id>http://ccc013.github.io/2016/10/28/二叉树2/</id>
    <published>2016-10-28T09:28:47.000Z</published>
    <updated>2016-10-28T09:31:15.149Z</updated>
    <content type="html"><![CDATA[<p>这是《大话数据结构》第六章树的内容，这里总结线索二叉树，二叉树、树和森林的转换以及赫夫曼树的知识点，其中赫夫曼树的总结是在做<a href="http://www.nowcoder.com/918856" target="_blank" rel="external">牛客网</a>上的数据结构选择题的时候，遇到有关这个知识点的时候总结的内容，主要是通过百度得到的，也有结合书本的内容。</p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h5 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h5><p>首先如下图所示的二叉树，其中<code>^</code>符号表示空指针域，对于一个有<code>n</code>个结点的二叉链表，每个结点都有指向左右孩子的两个指针域，所以一共有<code>2n</code>个指针域。而<code>n</code>个结点的二叉树是有<code>n-1</code>条分支线数，也就是存在$2n-(n-1)=n+1$个空指针域，这些空间是不存储任何东西，也就是浪费内存的资源。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt=""></p>
<p>另一方面，在对上图的二叉树做中序遍历时，可以得到<code>HDIBJEAFCG</code>这样的字符序列，通过这样的遍历，可以知道，结点<code>I</code>的前驱是<code>D</code>，后继是<code>B</code>。即我们可以知道任意一个结点的前驱和后继分别是哪个，但这是在经过遍历之后的结果，即每次使用都需要先遍历一次，才可以知道任意结点的前驱和后继。</p>
<p>综合上述两种情况，为了更好利用内存资源，节省时间，就有了<strong>线索二叉树</strong>了，我们将<strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就是线索二叉树了</strong>。</p>
<p><strong>线索化是对二叉树以某种次序遍历使其变为线索二叉树的过程。</strong></p>
<p>我们对上图的二叉树按照中序遍历的方式进行线索化，可以得到下图，其中虚线箭头是表示后继，实线箭头是前驱。这里设置二叉树的<strong>左指针是指向前驱，右指针指向后继。</strong></p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt=""></p>
<p>但是增加了线索后，需要解决的问题就是如何判断当前结点的左指针是指向其左孩子，还是前驱呢。这里就需要在每个结点增加两个标志域<code>ltag</code>和<code>rtag</code>，用来表示左右指针指向的是左右孩子还是前驱或者后继。</p>
<h5 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h5><p>二叉树的线索存储结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Link == 0 表示指向左右孩子指针； Thread == 1 表示指向前驱或者后继的线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Link, Thread&#125; PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树线索存储结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BiThrNode</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 结点数据  </span></span><br><span class="line">	TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> BiThrNode *lchild, *rchild;</span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    PointerTag RTag;</span><br><span class="line">&#125;  BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<p><strong>线索化的实质就是将二叉链表中的空指针改为指向前驱或者后继的线索</strong>，因此线索化的过程就是在遍历的过程中修改空指针的过程。</p>
<p>下面是中序遍历线索化的递归函数代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line">BiThrTree pre;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p)&#123;</span><br><span class="line">    InThreading(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)&#123;</span><br><span class="line">      <span class="comment">// 没有左孩子</span></span><br><span class="line">      p-&gt;LTag = Thread;</span><br><span class="line">      p-&gt;lchild = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;rchild)&#123;</span><br><span class="line">      <span class="comment">// 没有右孩子</span></span><br><span class="line">      p-&gt;RTag = Thread;</span><br><span class="line">      <span class="comment">// 指向后继，也就是当前结点p</span></span><br><span class="line">      p-&gt;rchild = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保持 pre 指向p的前驱</span></span><br><span class="line">    pre = p;</span><br><span class="line">    InThreading(p-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码可以得到线索二叉树，而对它进行遍历会发现相当于是操作一个双向链表一样。同样是在二叉线索链表上添加一个头结点，如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%913.png" alt=""></p>
<p>这里令二叉树的中序序列中的第一个结点<code>H</code>的左指针和最后一个结点<code>G</code>的右指针指向头结点，令头结点的左指针指向根结点，右指针指向结点<code>G</code>。这样做的好处是我们既可以从第一个结点开始顺其后继进行遍历，也可以从最后一个结点开始顺前驱进行遍历。</p>
<p>遍历的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span>&#123;</span><br><span class="line">  BiThrTree p;</span><br><span class="line">  <span class="comment">// p 指向根结点</span></span><br><span class="line">  p = T-&gt;lchild;</span><br><span class="line">  <span class="keyword">while</span>(p != T)&#123;</span><br><span class="line">    <span class="comment">// 空树或者遍历结束时，p == T</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;LTag == Link)</span><br><span class="line">      <span class="comment">// 循环到中序遍历序列的第一个结点</span></span><br><span class="line">      p = p-&gt;lchild;</span><br><span class="line">    <span class="comment">// 显示结点数据，也可以实现其他操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)&#123;</span><br><span class="line">      <span class="comment">// 根据线索，寻找后继结点，并输出数值或者进行其他操作</span></span><br><span class="line">      p = p-&gt;rchild;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p 指向当前结点的右孩子，暂时结束了根据线索来寻找后继结点</span></span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线索二叉链表的存储结构适用于<strong>如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继。</strong></p>
<h4 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h4><h5 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h5><p>树转换为二叉树的步骤如下：</p>
<ol>
<li><strong>加线</strong>。在所有兄弟结点之间加一条连线。</li>
<li><strong>去线</strong>。对树中每个结点，只保留<strong>它与第一个孩子结点的连线</strong>，删除它与其他孩子结点之间的连线。</li>
<li><strong>层次调整</strong>。以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。<strong>注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</strong></li>
</ol>
<p>上述步骤可以如下图所示一样：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%914.png" alt=""></p>
<h5 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h5><p>步骤如下：</p>
<ol>
<li>将每棵树先转为二叉树；</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，<strong>依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</strong>当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<p>下图就是一个森林转为二叉树的例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%915.png" alt=""></p>
<h5 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h5><p>二叉树转为树是树转为二叉树的逆过程，具体步骤如下：</p>
<ol>
<li>加线。若某结点的左孩子存在，则将其左孩子的所有右孩子结点都与当前结点连接起来。</li>
<li>去线。删除原来二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明。</li>
</ol>
<p>下图是一个例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%916.png" alt=""></p>
<h5 id="二叉树转为森林"><a href="#二叉树转为森林" class="headerlink" title="二叉树转为森林"></a>二叉树转为森林</h5><p>判断一棵二叉树能够转为森林还是一棵树的方法很简单，就是<strong>看其根结点是否有右孩子，如果有就是森林，没有就是一棵树。</strong></p>
<p>转换为森林的步骤如下：</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除，如此重复，直到所有右孩子连线都删除为止，得到分离后的二叉树。</li>
<li>将所有二叉树转为树即可。</li>
</ol>
<p>下图是一个例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%917.png" alt=""></p>
<h5 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h5><p>最后是介绍树和森林的遍历问题。</p>
<h6 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h6><p>树的遍历分为两种方式：</p>
<ol>
<li>先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>
</ol>
<p>如对下图的树，它的先根遍历序列是<code>ABEFCDG</code>，后根遍历序列是<code>EFBCGDA</code>。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%918.png" alt=""></p>
<h6 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h6><p>森林的遍历也是分两种：</p>
<ol>
<li><strong>前序遍历：</strong>先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如对于上述二叉树转为森林的例子中最后得到的三棵树的森林，前序遍历的序列是<code>ABCDEFGHJI</code>。</li>
<li><strong>后序遍历：</strong>是先访问森林中的第一棵树，然后用后根遍历的方法遍历每一棵子树，然后再访问根结点，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。同样还是刚才的例子，后根遍历的序列是<code>BCDAFEJHIG</code>。</li>
</ol>
<p>对照上述例子中的二叉树的前序和中序遍历结果可以发现，<strong>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</strong>同时，<strong>当以二叉链表作树的存储结构时</strong>，<strong>树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。</strong></p>
<h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><blockquote>
<p>定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，<strong>称这样的二叉树为最优二叉树，也称为赫夫曼树(Huffman Tree)。</strong>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
</blockquote>
<p>假设有$n$个权值，则构造出的赫夫曼树有$n$个叶子结点。 n个权值分别设为 $w_1,w_2,\ldots,w_n$，则赫夫曼树的构造规则为：</p>
<ol>
<li>将$w_1,w_2,\ldots,w_n$看成是有$n$ 棵树的森林(每棵树仅有一个结点)；</li>
<li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li>
<li>从森林中删除选取的两棵树，并将新树加入森林；</li>
<li>重复2、3步，直到森林中只剩一棵树为止，该树即为所求得的赫夫曼树。</li>
</ol>
<p>赫夫曼树的性质有：</p>
<ul>
<li>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从<strong>根结点到第L层结点的路径长度为L-1</strong>。</li>
<li>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</strong></li>
<li>树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为WPL</li>
<li><em>赫夫曼树的形状是不唯一的，但是它的带权路径长度WPL是唯一的。*</em></li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这部分内容是之前看《数据结构算法与应用：C++语言描述》时没有记录到的知识点，但是在做有关树的练习题的时候却有涉及到，比如线索二叉树和赫夫曼树，特别是后者，一般会考察如何构造赫夫曼树以及求其带权路径长度。刚好在《大话数据结构》中看到，就做下笔记，总结下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是《大话数据结构》第六章树的内容，这里总结线索二叉树，二叉树、树和森林的转换以及赫夫曼树的知识点，其中赫夫曼树的总结是在做<a href="http://www.nowcoder.com/918856" target="_blank" rel="external">牛客网]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搜索树1-二叉搜索树]]></title>
    <link href="http://ccc013.github.io/2016/08/31/%E6%90%9C%E7%B4%A2%E6%A0%911-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://ccc013.github.io/2016/08/31/搜索树1-二叉搜索树/</id>
    <published>2016-08-31T00:46:46.000Z</published>
    <updated>2016-10-25T11:50:21.630Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第11章搜索树的内容。</p>
<p>本节首先介绍的是二叉搜索树的内容。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>  在<a href="http://ccc013.github.io/2016/07/27/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%971-%E5%AD%97%E5%85%B8-%E8%B7%B3%E8%A1%A8/">跳表&amp;散列1-字典&amp;跳表</a>介绍了抽象数据类型<strong>Dictionary</strong>，从中可以发现当用<a href="http://ccc013.github.io/2016/08/07/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%972-%E6%95%A3%E5%88%97/">散列</a>来描述一个字典时，字典操作（包括插入、删除和搜索）所需要的平均时间是$\theta(1)$。而这些操作最坏情况下的时间正比于字典中的元素个数$n$。如果扩充字典的抽象数据类型描述，增加以下操作，那么散列将不能再提供比较好的评价性能：<br>  1) 按关键值的升序输出字典元素；<br>  2）按升序找到第k个元素；<br>  3）删除第k个元素。</p>
<p>  为了执行操作1），需要从表中取出数据，将它们排序后输出。如果使用除数是D的链表，那么能在$\theta(D+n)$的时间内取出元素，在$O(nlogn)$时间内完成排序和$\theta(n)$时间内输出，因此共需时间$O(D+nlogn)$。如果对散列使用线性开型寻址，则取出元素所需时间是$\theta(b)$,b是桶的个数，这时需要时间是$O(b+nlogn)$。<br>  如果使用链表，操作2）和3）可以在$O(D+n)$的时间内完成，如果使用线性开型寻址，它们可以在$\theta(b)$时间内完成。</p>
<p>  如果使用平衡搜索树，那么对字典的基本操作（搜索、插入和删除）能够在$O(logn)$的时间内完成，操作1）能在$\theta(n)$的时间内完成。通过使用带索引的平衡搜索树，也能够在$O(logn)$的时间内完成操作2）和3）。</p>
<p>  在学习平衡树之前，首先来看一种叫做二叉搜索树的简单结构。</p>
<blockquote>
<p>定义 [二叉搜索树] 二叉搜索树(binary search tree)是一棵可能为空的二叉树，一棵非空的二叉搜索树满足以下特征：<br>1）每个元素有一个关键值，并且没有任意两个元素有相同的关键值；因此，所有的关键值都是唯一的。<br>2）根节点左子树的关键值（如果有的话）小于根节点的关键值。<br>3）根节点右子树的关键值（如果有的话）大于根节点的关键值。<br>4）根节点的左右子树也都是儿茶搜索树。</p>
</blockquote>
<p>下图11-1给出3个含有不同关键值的二叉树，其中11-1a的二叉树满足了上述特征1-3，但是不满足特征4，而11-b和11-c的二叉树则是二叉搜索树。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>在放弃二叉搜索树中所有元素必须拥有不同关键值的要求，然后用小于等于代替特征2）中的小于，用大于等于代替特征3）中的大于，这样就可以得到一棵<strong>有重复值的二叉搜索树</strong>。</p>
<p><strong>带索引的二叉搜索树源于普通的二叉搜索树，它只是在每个节点中添加一个LeftSize域，这个域的值是该节点左子树的元素个数加1。</strong>下图11-2是两棵带索引的二叉搜索树。注意，LeftSize同时给出了一个元素在子树中的排名。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h3 id="类BSTree"><a href="#类BSTree" class="headerlink" title="类BSTree"></a>类BSTree</h3><p>  可以从<a href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/">二叉树的基本概念和实现</a>中介绍的类<strong>BinaryTree</strong>中派生类<strong>BSTree</strong>,这样可以大大简化类BSTree的设计，实现如下程序所示。另外，为了访问<strong>BinaryTree</strong>类的私有成员<strong>root</strong>，需要将类<strong>BSTree</strong>定义为<strong>BinaryTree</strong>的友元。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> BSTree : <span class="keyword">public</span> BinaryTree&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp;k, E&amp; e)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    BSTree&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp; e);</span><br><span class="line">    BSTree&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp;k, E&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ascend</span><span class="params">()</span></span>&#123; InOutput(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索元素的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> BSTree&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp;k, E &amp;e) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k匹配的元素</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data)</span><br><span class="line">            p = p-&gt;LeftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k&gt;p-&gt;data)</span><br><span class="line">            p = p-&gt;RightChild;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找到元素</span></span><br><span class="line">            e = p-&gt;data;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若在二叉搜索树中插入一个新元素e，首先要验证e的关键值与树中已有元素的关键值是否相同，这可以通过用e的关键值对二叉树进行搜索来实现。如果搜索不成功，那么新元素将被插入到搜索的中端点，下面给出插入函数的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">BSTree&lt;E, K&gt;&amp; BSTree&lt;E, K&gt;::Insert(<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 如果不出现重复，则插入e</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *p = root, *pp = <span class="number">0</span>;   <span class="comment">// p是搜索节点，pp是p的父节点</span></span><br><span class="line">    <span class="comment">// 寻找插入点</span></span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; p-&gt;data)</span><br><span class="line">            p = p-&gt;LeftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e&gt;p-&gt;data)</span><br><span class="line">            p = p-&gt;RightChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 出现重复</span></span><br><span class="line">            <span class="keyword">throw</span> BadInput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *r = <span class="keyword">new</span> BinaryTreeNode&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">if</span> (root)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; pp-&gt;data)</span><br><span class="line">            pp-&gt;LeftChild = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp-&gt;RightChild = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于删除操作，对包含被删除元素的节点p有三种情况：1）p是叶节点；2）p只有一个非空子树；3）p有两个非空子树。</p>
<p>对于第一种情况可以采用直接丢弃叶节点的方法来处理。</p>
<p>对于第二种情形，如果p没有父节点，即p是根节点，则将p丢弃，p的唯一孩子成为新的搜索树的根节点；如果p有父节点pp，则修改pp的指针，使其指向p的唯一孩子，然后删除节点p。</p>
<p>最后，对于第三种情形，<strong>只需要将元素替换成它的左子树中的最大元素或者右子树中的最小元素。</strong>注意，必须确保右子树中的最小元素以及左子树中的最大元素即不会在没有子树的节点中，也不会在只有一个子树的节点中。可以按下述方法来查找到左子树中的最大元素：<strong>首先移动到子树的根，然后沿着各节点的右孩子指针移动，直到右孩子指针为0为止。</strong>类似地，也可以找到右子树的最小元素：<strong>首先移动到子树的根，然后沿着各节点的左孩子指针移动，直到左孩子指针为0为止。</strong></p>
<p>下面程序给出删除操作实现，它一般使用左子树的最大元素来进行替换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line">BSTree&lt;E, K&gt;&amp; BSTree&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 删除关键值是k的元素，并将其放入e</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将p指向关键值是k的节点</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *p = root, *pp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != k)&#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data)</span><br><span class="line">            p = p-&gt;LeftChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;RightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">throw</span> BadInput();</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="comment">// 对树进行重构，处理p有两个孩子的情形</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;LeftChild &amp;&amp; p-&gt;RightChild)&#123;</span><br><span class="line">        <span class="comment">// 转换成有0或1个孩子的情形，在p的左子树中寻找最大元素</span></span><br><span class="line">        BinaryTreeNode&lt;E&gt; *s = p-&gt;LeftChild, *ps = p;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;RightChild)&#123;</span><br><span class="line">            ps = s;</span><br><span class="line">            s = s-&gt;RightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最大元素从s移动到p</span></span><br><span class="line">        p-&gt;data = s-&gt;data;</span><br><span class="line">        p = s;</span><br><span class="line">        pp = ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于p最多有一个孩子</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *c;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;LeftChild)</span><br><span class="line">        c = p-&gt;LeftChild;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = p-&gt;RightChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除p</span></span><br><span class="line">    <span class="keyword">if</span> (p == root)</span><br><span class="line">        root = c;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == pp-&gt;LeftChild)</span><br><span class="line">            pp-&gt;LeftChild = c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp-&gt;RightChild = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类DBSTree"><a href="#类DBSTree" class="headerlink" title="类DBSTree"></a>类DBSTree</h3><p>  若二叉搜索树中的不同元素可以包含相同的关键值，则称这种树是<strong>DBSTree</strong>。在实现该类的时候，只需要把<strong>BSTree::Insert</strong>的while循环改成如下所示即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p)&#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; p-&gt;data)</span><br><span class="line">        p = p-&gt;LeftChild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e&gt;p-&gt;data)</span><br><span class="line">        p = p-&gt;RightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更完整的例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SearchTrees/BSTree.h" target="_blank" rel="external">二叉搜索树的实现</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本节内容就简单介绍了二叉搜索树的代码实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第11章搜索树的内容。</p>
<p>本节首先介绍的是二叉搜索树的内容。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优先队列2-左高树]]></title>
    <link href="http://ccc013.github.io/2016/08/24/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%972-%E5%B7%A6%E9%AB%98%E6%A0%91/"/>
    <id>http://ccc013.github.io/2016/08/24/优先队列2-左高树/</id>
    <published>2016-08-24T10:50:30.000Z</published>
    <updated>2016-10-23T07:20:35.491Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本节将介绍另一种实现优先队列的数据结构—左高树</p>
<h3 id="高度与宽度优先的最大及最小左高树"><a href="#高度与宽度优先的最大及最小左高树" class="headerlink" title="高度与宽度优先的最大及最小左高树"></a>高度与宽度优先的最大及最小左高树</h3><p>  上一节讲述的堆结构是一种<strong>隐式数据结构</strong>，用完全二叉树表示的堆在数组中时隐式存储的（即没有明确的指针或其他数据能够重构这种结构）。由于没有存储结构信息，这种描述方法空间利用率很高，事实上是没有空间浪费，尽管堆结构的时间和空间效率都很高，但它不适合所有优先队列的应用，尤其是当需要合并两个优先队列或多个长度不同的队列时，需要借助其他数据结构来实现这类应用，比如<strong>左高树(leftist tree)</strong>。</p>
<p>  考察一棵二叉树，如下图9-6a所示，它有一类特殊的节点叫做<strong>外部节点，用来代替树中的空子树，其余节点叫做内部节点。</strong>增加了外部节点的二叉树被称为扩充二叉树，如下图9-6b所示，外部节点用阴影框表示，并且为了方便起见，这些节点用a~f标注。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%B7%A6%E9%AB%98%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  令$s(x)$是从节点$x$到它的子树的外部节点的所有路径横纵最短的一条，根据其定义可知，如果$x$是外部节点，则$s$=0，若$x$是内部节点，则其$s$值为$min{s(L),s(R)}+1$，其中$L,R$分别是$x$的左右子树。所以上述扩充二叉树各节点的s值如上图9-c所示。</p>
<blockquote>
<p>定义 [高度优先左高树] 当且仅当一棵二叉树的任何一个内部节点，<strong>其左孩子的$s$值大于等于右孩子的$s$值时</strong>，该二叉树是高度优先左高树(height-biased leftist tree,HBLT)。</p>
<p>定义 [最大(小)HBLT] 即同时是最大(小)树的HBLT; </p>
</blockquote>
<p>图9-6a所示的二叉树并不是HBLT，因为外部节点a的父节点，其左孩子$s$=0，右孩子$s$=1，不满足条件，如果将这两个子树进行交换就可以满足HBLT的条件。</p>
<blockquote>
<p>定理9-1 若x是一个HBLT的内部节点，则<br>1) 以$x$为根的子树的节点数目至少是$2^{s(x)}-1$.<br>2) 若子树$x$有$m$个节点，$s(x)$最多为$log_2(m+1)$<br>3) 通过最右路径（即路径是从$x$开始沿右孩子移动）从$x$到达外部节点的路径长度是$s(x)$。</p>
</blockquote>
<p><strong>可以通过考察子树的节点数目来得到另一类左高树。</strong>定义$x$的重量$w(x)$是以$x$为根的子树的内部节点数目。如果$x$是外部节点，则其重量为0；若$x$是内部节点，则其重量是其孩子节点的重量之和加1，如上图9-6d展示了二叉树各节点的重量。</p>
<blockquote>
<p>定义 [重量优先左高树] 当且仅当一棵二叉树的任何一个内部节点，其左孩子的$w$值大于等于右孩子的$w$时，该二叉树为重量优先左高树(weight-biased leftist tree,WBLT);</p>
</blockquote>
<p>[最大(小)WBLT]即同时又是最大(小)树的WBLT。</p>
<p>同HBLT类似，具有$m$个节点的WBLT的最右路径长度最多为$log_2(m+1)$。可以对WBLT和HBLT执行优先队列的查找、插入和删除操作，其时间复杂性与堆的相应操作相同。并且跟堆一样，WBLT和HBLT可以在线性时间内完成初始化。用WBLT或HBLT描述的两个优先队列可在对数时间内合并为一个，而堆描述的优先队列无法做到。</p>
<p>接下来将介绍HBLT的操作，而WBLT的查找、插入、删除、合并和初始化操作与HBLT非常相似。</p>
<h3 id="最大HBLT的插入"><a href="#最大HBLT的插入" class="headerlink" title="最大HBLT的插入"></a>最大HBLT的插入</h3><p>  <strong>插入操作可借助于合并操作来完成。</strong>它可以通过先建立一棵仅包含待插入元素的HBLT，然后与原来的HBLT合并即可。</p>
<h3 id="最大HBLT的删除"><a href="#最大HBLT的删除" class="headerlink" title="最大HBLT的删除"></a>最大HBLT的删除</h3><p>  根是最大元素，如果跟被删除，将留下分别以其左右孩子为根的两棵HBLT的子树，将其合并到一起，便得到包含除删除元素外所有元素的最大HBLT。</p>
<h3 id="合并两棵最大HBLT"><a href="#合并两棵最大HBLT" class="headerlink" title="合并两棵最大HBLT"></a>合并两棵最大HBLT</h3><p>  具有$n$个元素的最大HBLT，其最右路径的长度为$O(logn)$。合并操作操作仅需遍历欲合并的HBLT的最右路径，即仅需移动右孩子。</p>
<p> 合并策略最好用递归来实现。令$A,B$是需要合并的两棵最大HBLT，假设两者均不为空，为实现合并，首先需要检查两个根元素，较大者是合并后HBLT的根。假设$A$具有较大的根，且其左子树是$L$,$C$是由$A$的右子树与$B$合并而成的HBLT。所以$A,B$合并的结果是以$A$的根为根，$L,C$为左右子树的最大HBLT。如果$L$的$s$值小于$C$的$s$值，则$C$是右子树，$L$是左子树。</p>
<h3 id="初始化最大HBLT"><a href="#初始化最大HBLT" class="headerlink" title="初始化最大HBLT"></a>初始化最大HBLT</h3><p>  通过将$n$个元素插入到最初为空的最大HBLT中来进行初始化，所需时间是$O(logn)$。为得到具有线性时间的初始化算法，首先创建$n$个最大HBLT，每个树中仅包含$n$个元素中的某一个，这$n$棵树排成一个FIFO队列，然后从队列中依次删除两个HBLT，将其合并，然后再加入队列末尾，直到最后只有一棵HBLT。</p>
<h3 id="类MaxHBLT"><a href="#类MaxHBLT" class="headerlink" title="类MaxHBLT"></a>类MaxHBLT</h3><p>  最大HBLT的每个节点均需要$data,LeftChild,RightChild和s$四个域，相应的节点类是$HBLTNode$,如下代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> MaxHBLT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> HBLTNode&#123;</span><br><span class="line">    <span class="keyword">friend</span> MaxHBLT&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    T data;</span><br><span class="line">    HBLTNode&lt;T&gt;* LeftChild, *RightChild;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HBLTNode(<span class="keyword">const</span> T&amp;e, <span class="keyword">const</span> <span class="keyword">int</span> sh)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        s = sh;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而最大HBLT可用下面代码定义的类MaxHBLT来实现。类MaxHBLT的每个对象都有一个唯一的私有成员$root$，用来指向最大HBLT的根。构造函数在初始化时将其置为0，因此初始的最大HBLT是空。析构函数通过调用私有成员函数$Free$来删除HBLT中的所有节点，该函数按后序遍历整棵HBLT，每访问一个节点就删除该节点。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class MaxHBLT&#123;</span><br><span class="line">private:</span><br><span class="line">    HBLTNode&lt;T&gt; *root;</span><br><span class="line">    void PostOrder(void(*Visit)(HBLTNode&lt;T&gt;*u), HBLTNode&lt;T&gt;* t)&#123;</span><br><span class="line">        // 后序遍历</span><br><span class="line">        if (t)&#123;</span><br><span class="line">            PostOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">            PostOrder(Visit, t-&gt;RightChild);</span><br><span class="line">            Visit(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void free(HBLTNode&lt;T&gt;* t)&#123;</span><br><span class="line">        delete t;</span><br><span class="line">    &#125;</span><br><span class="line">    void Free(HBLTNode&lt;T&gt; *t)&#123;</span><br><span class="line">        PostOrder(free, t);</span><br><span class="line">        t = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void Meld(HBLTNode&lt;T&gt; * &amp;x, HBLTNode&lt;T&gt;* y);</span><br><span class="line">public:</span><br><span class="line">    MaxHBLT()&#123; root = 0 &#125;;</span><br><span class="line">    ~MaxHBLT()&#123; Free(root); &#125;</span><br><span class="line">    T Max()&#123;</span><br><span class="line">        if (!root)</span><br><span class="line">            throw OutOfBounds();</span><br><span class="line">        return root-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxHBLT&lt;T&gt;&amp; Insert(const T&amp; x);</span><br><span class="line">    MaxHBLT&lt;T&gt;&amp; DeleteMax(T&amp; x);</span><br><span class="line">    MaxHBLT&lt;T&gt;&amp; Meld(MaxHBLT&lt;T&gt;&amp; x)&#123;</span><br><span class="line">        Meld(root, x.root);</span><br><span class="line">        x.root = 0;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Initialize(T a[], int n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来先给出合并操作的函数实现代码，该函数首先要处理合并的树中至少有一个为空的特殊情况。当没有空树时要确保$x$指向根值较大的树，如果$x$不是指向根值较大的树，则将$x$和$y$的指针进行交换。接下来把$x$的右子树与以$y$为根的最大HBLT进行递归合并。合并后为保证整棵树是最大HBLT，$x$的左右孩子可能需要交换，这是通过计算$x$的$s$值来确定的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxHBLT&lt;T&gt;::Meld(HBLTNode&lt;T&gt;* &amp;x, HBLTNode&lt;T&gt;* y)&#123;</span><br><span class="line">    <span class="comment">// 合并两棵根分别是*x和*y的左高树，返回指向新根 x的指针</span></span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x)&#123;</span><br><span class="line">        x = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;data &lt; y-&gt;data)&#123;</span><br><span class="line">        <span class="comment">// 交换x和y</span></span><br><span class="line">        HBLTNode&lt;T&gt; * temp = y;</span><br><span class="line">        y = x;</span><br><span class="line">        x = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    Meld(x-&gt;RightChild, y);</span><br><span class="line">    <span class="keyword">if</span> (!x-&gt;LeftChild)&#123;</span><br><span class="line">        <span class="comment">// 左子树为空,交换子树</span></span><br><span class="line">        x-&gt;LeftChild = x-&gt;RightChild;</span><br><span class="line">        x-&gt;RightChild = <span class="number">0</span>;</span><br><span class="line">        x-&gt;s = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;LeftChild-&gt;s &lt; x-&gt;RightChild-&gt;s)&#123;</span><br><span class="line">            <span class="comment">// 交换左右子树</span></span><br><span class="line">            HBLTNode&lt;T&gt; * temp = x-&gt;LeftChild;</span><br><span class="line">            x-&gt;RightChild = x-&gt;LeftChild;</span><br><span class="line">            x-&gt;LeftChild = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;s = x-&gt;RightChild-&gt;s + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后给出插入，删除和初始化函数的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHBLT&lt;T&gt;&amp; MaxHBLT&lt;T&gt;::Insert(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将x插入左高树</span></span><br><span class="line">    HBLTNode&lt;T&gt;* q = <span class="keyword">new</span> HBLTNode&lt;T&gt;(x, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将q与原树合并</span></span><br><span class="line">    Meld(root, q);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHBLT&lt;T&gt;&amp; MaxHBLT&lt;T&gt;::DeleteMax(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除最大元素，并将其放入x</span></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line"></span><br><span class="line">    x = root-&gt;data;</span><br><span class="line">    HBLTNode&lt;T&gt;*L = root-&gt;LeftChild;</span><br><span class="line">    HBLTNode&lt;T&gt;*R = root-&gt;RightChild;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    root = L;</span><br><span class="line">    Meld(root, R);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxHBLT&lt;T&gt;::Initialize(T a[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="comment">// 初始化有n个元素的HBLT树</span></span><br><span class="line">    Queue&lt;HBLTNode&lt;T&gt;*&gt;Q(n);</span><br><span class="line">    <span class="comment">// 删除老节点</span></span><br><span class="line">    Free(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        HBLTNode&lt;T&gt;* q = <span class="keyword">new</span> HBLTNode&lt;T&gt;(a[i-<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        Q.Add(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断合并队列中的树；</span></span><br><span class="line">    HBLTNode&lt;T&gt;*b, *c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Q.Delete(b).Delete(c);</span><br><span class="line">        Meld(b, c);</span><br><span class="line">        <span class="comment">// 将合并后得到的树放入对了</span></span><br><span class="line">        Q.Add(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">        Q.Delete(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于上述函数的复杂性，构造函数只需要耗时$\theta(1)$,而析构函数需要$\theta(n)$，其中$n$是要删除的最大HBLT中的元素个数。<strong>Max</strong>函数的复杂性是$\theta(1)$，<strong>Insert,DeleteMax</strong>及共享成员函数<strong>Meld</strong>的复杂性与私有成员函数<strong>Meld</strong>的复杂性相同，由于私有成员函数<strong>Meld</strong>仅在以$<em>x$和$</em>y$为根的树的右子树中移动，因此其复杂性是$O(x-&gt;s+y-&gt;s)$。又由于$<em>x$和$</em>y$的最大$s$值分别为$log_2(m+1)$和$log_2(n+1)$,其中$m,n$分别是以$<em>x$和$</em>y$为根的最大HBLT中的元素个数，所以私有成员函数<strong>Meld</strong>的复杂性是$O(logmn)$。</p>
<p>更完整的代码例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/PriorityQueue/MaxHBLT.h" target="_blank" rel="external">最大高度优先左高树的实现</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本节将介绍另一种实现优先队列的数据结构—左高树</p>
<h3 id="高度与宽度优先的最大及最小左高树"><a href="#高度与宽度优先的最大及最小左高树" class="headerlin]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优先队列1--堆]]></title>
    <link href="http://ccc013.github.io/2016/08/23/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%971-%E5%A0%86/"/>
    <id>http://ccc013.github.io/2016/08/23/优先队列1-堆/</id>
    <published>2016-08-23T12:27:57.000Z</published>
    <updated>2016-10-23T07:19:13.371Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本小节主要介绍的是优先队列的定义以及其中一种实现方法—最大堆的实现，最后是堆的一个应用—堆排序。</p>
<p>优先队列删除元素时根据优先权高或低的次序，而不是元素进行队列的次序，这与之前第六章介绍的FIFO结构的队列不同。</p>
<p><strong>可以利用堆数据结构来高效地实现优先队列，堆是一棵完全二叉树</strong>。</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>优先队列（priority queue)是0个或多个元素的集合，每个元素都有一个优先权或值，对优先队列执行的操作有1）查找；2）插入一个新元素；3）删除。</p>
</blockquote>
<p>优先队列可以按搜索的是优先权大或小的元素分为最大优先队列或者最小优先队列，而删除操作则是用来删除对应查找的元素。另外，优先队列中的元素可以有相同的优先权，查找和删除操作可根据任意优先权进行。</p>
<p>下面给出最大优先队列的抽象数据类型，最小优先队列的抽象数据类型与之相似，只需要将最大改为最小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型MaxPriorityQueue&#123;</span><br><span class="line">实例</span><br><span class="line">    有限的元素集合，每个元素都有一个优先权</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空的优先队列</span><br><span class="line">    Size(): 返回队列中的元素数目</span><br><span class="line">    Max(): 返回具有最大优先权的元素</span><br><span class="line">    Insert(x): 将x插入队列</span><br><span class="line">    DeleteMax(x): 从队列中删除具有最大优先权的元素，并将该元素返回至x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>[最大树（最小树）] 每个节点的值都大于（小于）或等于其子节点（如果有的话）值的树。</p>
</blockquote>
<p>最大树与最小树的例子分别如下图9-1,9-2所示。虽然这些树都是二叉树，但最大树不必是二叉树，最大树或最小树节点的子节点个数可以大于2。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%861.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>[最大堆(最小堆)] 最大（最小）的完全二叉树。</p>
</blockquote>
<p>上图9-1b并所示的最大树并不是最大堆，因为它不是完全二叉树，而其他两个最大树是最大堆。同样，图9-2b也不是完全二叉树，所以也不是最小堆，其他两个最小树则是最小堆。</p>
<p>堆是完成二叉树，可以利用<a href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/">二叉树的基本概念和实现</a>中介绍的公式化描述方案，可用一维数组有效地描述堆，利用二叉树的特性4可将堆中的节点移动到其父节点或子节点处。<strong>另外，堆是完全二叉树，拥有n个元素的堆高度是$\left\lceil  log_2(n+1) \right\rceil$,因此，如果可在$O(height)$时间内完成插入和删除操作，其复杂性是$O(log_2n)$。</strong></p>
<h4 id="最大堆的插入"><a href="#最大堆的插入" class="headerlink" title="最大堆的插入"></a>最大堆的插入</h4><p>  如下图9-3a是一个具有5个元素的最大堆，当要加入一个元素的时候，因为堆是完全二叉树，得到的新树结构必然如9-3b所示，这个时候如果新元素的值是5，它比2要大，此时需要将2下移变成左孩子，如图9-3c所示，此外还要与根节点进行比较，这里如果新插入的元素值是21，就大于根节点的20了，此时还需要将20下移到原来2的位置，变成如图9-3d所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%862.png" alt="此处输入图片的描述"></p>
<p>  插入策略从叶到根只有单一路径，每层工作需耗时$\theta(1)$,因此实现此策略的时间复杂性是$O(height)=O(log_2n)$。</p>
<h4 id="最大堆的删除"><a href="#最大堆的删除" class="headerlink" title="最大堆的删除"></a>最大堆的删除</h4><p>  假设对图9-3d的最大堆进行删除，需要删除的是元素21，这个时候只剩下5个元素，需要重新构建最大堆的结构，那么最终应该得到如图9-3a的最大堆形式。然后接下来要删除的是元素20，并得到如图9-4b所示的结构，则首先10从位置5移出，但将其放在根节点的位置得到的不是最大堆，则把根节点的两个孩子15和2中较大的一个放到根节点，然后假设将10插入位置2，但是还不是最大堆，因此将14上移到位置2,10放到位置4，得到如图9-4c所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%863.png" alt="此处输入图片的描述"></p>
<p>  删除策略如插入策略一样，从堆的根节点到叶节点只有单一路径，每层工作需耗时$\theta(1)$,因此实现此策略的时间复杂性是$O(height)=O(log_2n)$。</p>
<h4 id="最大堆的初始化"><a href="#最大堆的初始化" class="headerlink" title="最大堆的初始化"></a>最大堆的初始化</h4><p>  现在假设开始有数组a，它有n个元素，n=10，它可以用如图9-5a所示的完全二叉树表示，但它不是最大堆。为了将其转化为最大堆，从第一个具有孩子的节点开始（即节点10），<strong>这个元素在数组中的位置是$i=[n/2]$，如果以这个元素为根的子树已经是最大堆，则不需要调整，否则必须调整子树成为最大堆，然后继续检查$i-1,i-2,\ldots$等节点为根的子树，直到检查到根节点为止。</strong></p>
<p>  对图9-5a所示的完全二叉树，首先i=5，因为$10&gt;1$,所以以位置i为根的子树已经是最大堆，接下来检查位置4的子树，$15&lt;17$,它不是最大堆，将其变为最大堆，可得到如图9-5b所示，然后依次检查位置3，位置2以及根节点，分别得到如图9-5c，d所示的最大堆。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%864.png" alt="此处输入图片的描述"></p>
<h4 id="类MaxHeap"><a href="#类MaxHeap" class="headerlink" title="类MaxHeap"></a>类MaxHeap</h4><p>  下面程序给出最大堆的类定义。n是私有成员，代表目前堆中的元素的个数；MaxSize是堆的最大容量；heap是存储堆元素的数组，默认大小是10。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> MaxHeap&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> CurrentSize, MaxSize;</span><br><span class="line">    T* heap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(<span class="keyword">int</span> MaxHeapSize = <span class="number">10</span>);</span><br><span class="line">    ~MaxHeap()&#123; <span class="keyword">delete</span>[] heap; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> CurrentSize; &#125;</span><br><span class="line">    <span class="function">T <span class="title">Max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    MaxHeap&lt;T&gt;&amp; Insert(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    MaxHeap&lt;T&gt;&amp; DeleteMax(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T a[], <span class="keyword">int</span> size, <span class="keyword">int</span> ArraySize)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面给出最大堆的插入、删除和初始化代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将x插入到最大堆中</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为x寻找插入位置</span></span><br><span class="line">    <span class="keyword">int</span> i = ++CurrentSize;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">1</span> &amp;&amp; x &gt; heap[i / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="comment">// 不能够将x放入heap[i]</span></span><br><span class="line">        heap[i] = heap[i / <span class="number">2</span>];  <span class="comment">// 将元素下移</span></span><br><span class="line">        i /= <span class="number">2</span>; <span class="comment">// 移向父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;::DeleteMax(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将最大元素放入x，并从堆中删除最大元素</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line"></span><br><span class="line">    x = heap[<span class="number">1</span>];    <span class="comment">// 最大元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重构堆</span></span><br><span class="line">    T y = heap[CurrentSize--];  <span class="comment">// 最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从根开始，为y寻找合适的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, ci = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (ci &lt;= CurrentSize)&#123;</span><br><span class="line">        <span class="comment">// heap[ci]应是i较大的孩子</span></span><br><span class="line">        <span class="keyword">if</span> (ci &lt; CurrentSize &amp;&amp; heap[ci] &lt; heap[ci + <span class="number">1</span>])</span><br><span class="line">            ci++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否能将y放入heap[i]</span></span><br><span class="line">        <span class="keyword">if</span> (y &gt;= heap[ci])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能</span></span><br><span class="line">        heap[i] = heap[ci];</span><br><span class="line">        <span class="comment">// 下移一层</span></span><br><span class="line">        i = ci;</span><br><span class="line">        ci *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::Initialize(T a[], <span class="keyword">int</span> size, <span class="keyword">int</span> ArraySize)&#123;</span><br><span class="line">    <span class="comment">// 把最大堆初始化为a</span></span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap = <span class="keyword">new</span> T[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= size; s++)&#123;</span><br><span class="line">        heap[s] = a[s - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    CurrentSize = size;</span><br><span class="line">    MaxSize = ArraySize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        T y = heap[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找放置y的位置</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">2</span> * i;</span><br><span class="line">        <span class="keyword">while</span> (c &lt;= CurrentSize)&#123;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; CurrentSize&amp;&amp;heap[c] &lt; heap[c + <span class="number">1</span>])</span><br><span class="line">                c++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (y &gt;= heap[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            heap[c / <span class="number">2</span>] = heap[c];</span><br><span class="line">            c *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[c / <span class="number">2</span>] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入代码中，i从新创建的叶节点位置CurrentSize开始，对从该位置到根的路径进行遍历，对每个位置，都检查是否到达跟(i=1)或在i处插入新元素不会改变最大树的性质—$x \le heap[i/2]$，只要满足其中一个条件，就可以在i处插入x，否则会执行循环体中的代码。插入操作的时间复杂性是$O(logn)$。</p>
<p>删除操作的时间复杂性也是$O(logn)$。</p>
<p>初始化函数<strong>Initialize</strong>中for循环每次所花时间是$O(logn)$,循环次数是n/2，总的复杂性是$O(nlogn)$。实际应用中，初始化操作的复杂性是$\theta(n)$。</p>
<p>更完整的代码例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/PriorityQueue/MaxHeap.h" target="_blank" rel="external">最大堆的实现</a>。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>  利用堆来实现n个元素的排序，所需时间是$O(nlogn)$,可以将先要排序的n个元素初始化为一个最大堆，然后每次从堆中提取（即删除）元素，各元素将按递减次序排列。初始化所需要的时间是$\theta(n)$,每次删除所需要的时间是$O(logn)$,因此总时间是$O(nlogn)$。</p>
<p>实现代码如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 利用堆排序算法对a[1:n]进行排序</span></span><br><span class="line">    MaxHeap&lt;T&gt; H(<span class="number">1</span>);</span><br><span class="line">    H.Initialize(a, n, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中逐个抽取元素</span></span><br><span class="line">    T x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        H.DeleteMax(x);</span><br><span class="line">        a[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆的析构函数中保存数组a</span></span><br><span class="line">    H.Deactivate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">20</span>, <span class="number">12</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    HeapSort(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%865.png" alt="此处输入图片的描述"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本小节主要介绍的是优先队列的定义以及其中一种实现方法—最大堆的实现，最后是堆的一个应用—堆排序。</p>
<p>优先队列删除元素时根据优先权高或低的次序，而不是元素进行队列的次序，这与之前第六章介]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的基本概念和实现]]></title>
    <link href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://ccc013.github.io/2016/08/18/二叉树的基本概念和实现/</id>
    <published>2016-08-18T07:05:01.000Z</published>
    <updated>2016-10-25T11:52:45.346Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。</p>
</blockquote>
<p>在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的<strong>孩子(children)</strong>，而Joe是他们的<strong>父母(parent)</strong>。有相同父母的孩子是<strong>兄弟(sibling)</strong>。Ann，Mary,John都是兄弟。此外，还有其他术语：<strong>孙子(grandchild),祖父(grandparent),祖先(ancestor),后代(descendent)等</strong>。树中没有孩子的元素称为<strong>叶子(leaf)</strong>。图中Ann,Mark,Sue和Chris是树的叶子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>树的另一个常用术语是<strong>级(level)</strong>。指定树根的级是1，其孩子的级是2，依次类推。上图中Joe的级是1，而Ann，Mary,John的级是2，然后Mark,Sue,Chris的级是3。</p>
<p><strong>元素的度是指其孩子的个数。</strong>叶节点的度是0。<strong>树的度是其元素度的最大值</strong>。所以上图中的度是3。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p>定义：二叉树(binary tree)t是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个称为根的元素，余下的元素（如果有的话）被组成2个二叉树，分别称为t的左子树和右子树。</p>
</blockquote>
<p><strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树可以为空，树不能为空</li>
<li>二叉树中每个元素都恰好有两棵子树（其中一个或两个可能为空）。而树中每个元素可以有若干子树。</li>
<li>在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树间是无序的。</li>
</ul>
<p>下图给出了表示数学表达式的二叉树，总共有3个数学表达式。每个操作符可以有一个或两个操作数，左操作数是操作符的左子树，而右操作数则是右子树。树中的叶节点是常量或者变量。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h3 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><blockquote>
<p><strong>特性1： 包含n(n&gt;0)个元素的二叉树边数是n-1。</strong></p>
</blockquote>
<p>证明 二叉树中每个元素 (除了根节点)有且只有一个父节点。在子节点与父节点间有且只有一条边，因此边数为n-1。</p>
<p><strong>二叉树的高度或者深度是指该二叉树的层数。</strong></p>
<blockquote>
<p><strong>特性2： 若二叉树的高度为h,$h \ge 0$,则该二叉树最少有h个元素，最多有$2^h - 1$个元素。</strong></p>
</blockquote>
<p>证明 因为每一层最少要有1个元素，因此元素数最少为h。每元素最多有2个子节点，则第i层节点元素最多为$2^i-1$个,i&gt;0。h=0时，元素的总数为0，也就是$2^0-1$。当h&gt;0时，元素的总数不会超过$\sum_{i=1}^h 2^{i-1}=2^h-1$。</p>
<blockquote>
<p><strong>特性3： 包含n个元素的二叉树的高度最大是n，最小是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
</blockquote>
<p>证明 因为每层至少有一个元素，因此高度不会超过n。由特性2，可以得知高度为h的二叉树最多有$2^h-1$个元素。因为$n \le 2^h-1$,因此$h \ge log_2(n+1)$。由于h是整数，所以$h \ge \left\lceil  log_2(n+1) \right\rceil$。</p>
<p><strong>当高度是h的二叉树恰好有$2^h - 1$个元素时，称其为满二叉树(full binary tree)。</strong>下图就是一个高度为4的满二叉树。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>假设对高度为h的满二叉树中的元素从上到下，从左到右的顺序进行从1到$2^h - 1$进行编号，如上图所示。假设从满二叉树中删除k个元素，其编号为$2^h - i, 1 \le i \le k$,所得到的二叉树称为<strong>完全二叉树(complete binary tree)</strong>。如下图给出的三棵完全二叉树。注意，<strong>满二叉树是完全二叉树的一个特例，并且有n个元素的完全二叉树的深度是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>在完全二叉树中，一个元素与其孩子的编号有非常好的对应关系。其关系在下面特性4中给出。</p>
<blockquote>
<p><strong>特性4： 设完全二叉树中一元素的序号是i，$1 \le i \le n$。则有以下关系成立：</strong><br>1) 当i=1时，该元素为二叉树的根，若i&gt;1,则该元素父节点的编号是$\left\lfloor i/2 \right\rfloor$。<br>2) 当2i&gt;n时，该元素没有左子树，否则，其左子树的编号是2i。<br>3) 若2i+1&gt;n时，该元素没有右子树，否则，其右子树的编号是2i+1。</p>
</blockquote>
<h3 id="二叉树描述"><a href="#二叉树描述" class="headerlink" title="二叉树描述"></a>二叉树描述</h3><h4 id="公式化描述"><a href="#公式化描述" class="headerlink" title="公式化描述"></a>公式化描述</h4><p>  二叉树的公式化描述利用特性4。二叉树可以作为缺少了部分元素的完全二叉树。下图给出了二叉树的两个例子。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  在公式化描述方法中，按照二叉树对元素的编号方法，将二叉树的元素存储在数组中。上图同时给出了二叉树的公式化描述，即图中右侧的数组表示。</p>
<p>  当缺少很多元素时，这种描述方法非常浪费空间。实际上，一个有n个元素的二叉树可能最多需要$2^n-1$的空间来存储。当每个节点都是其他节点的右孩子时，存储空间达到最大。如下图所示的一棵有四个元素的二叉树，这种类型的二叉树称为右斜二叉树。当缺少的元素比较少时，这种描述方法很有效。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h4 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h4><p>  <strong>二叉树最常用的描述方法是用链表或指针。</strong>每个元素都用一个有两个指针域的节点表示，这两个域是<strong>LeftChild和RightChild</strong>。除此两个指针域外，每个节点还有一个data域。其代码实现如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> BinaryTreeNode&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Visit</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* LeftChild, *RightChild;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTreeNode()&#123;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode(<span class="keyword">const</span> T&amp; e)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode(<span class="keyword">const</span> T&amp;e, BinaryTreeNode *l, BinaryTreeNode* r)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        LeftChild = l;</span><br><span class="line">        RightChild = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的边可以用一个从父节点到子节点的指针来描述。指针放在父节点的指针域中，因为包括n个元素的二叉树恰有n-1条边，所以有<code>2n-(n-1)=n+1</code>个指针域没有值，这些域被值为0。下图给出了公式化描述中第一幅图的二叉树的链表描述。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>二叉树中不设置指向父节点的指针一般不会有什么问题，因为在二叉树的大部分函数中并不需要此指针。</p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>  有四种遍历二叉树的方法：</p>
<ul>
<li><strong>前序遍历</strong></li>
<li><strong>中序遍历</strong></li>
<li><strong>后序遍历</strong></li>
<li><strong>逐层遍历</strong></li>
</ul>
<p>前3种遍历方法将在下面给出代码实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 前序遍历左子树</span></span><br><span class="line">        PreOrder(t-&gt;LeftChild);</span><br><span class="line">        <span class="comment">// 前序遍历右子树</span></span><br><span class="line">        PreOrder(t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        InOrder(t-&gt;LeftChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">        InOrder(t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        PostOrder(t-&gt;LeftChild);</span><br><span class="line">        PostOrder(t-&gt;RightChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三种方法，每个节点的左子树都在其右子树之前遍历。<strong>这三种遍历的区别在于对同一个节点在不同时刻进行访问。</strong>在进行前序遍历时，每个节点是在其左右子树被访问之前进行访问的；在中序遍历时，首先访问左子树，然后访问子树的根节点，最后访问右子树。在后序遍历时，当左右子树均访问完之后才访问子树的根节点。</p>
<p>下图给出上述三种方法对前文给出的数学表达式分别产生的结果，其中<code>Visit(t)</code>由<code>cout&lt;&lt; t-&gt;data;</code>代替。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>当对一棵数学表达式树进行前、中、后序遍历时，便分别得到表达式的前缀、中缀和后缀表达式。中缀（infix）形式就是平时书写的数学表达式。使用中缀形式的时候由于没有括号，可能会产生一些歧义，比如对于<code>x+y*z</code>，可以理解为<code>(x+y)*z</code>或者<code>x+(y*z)</code>，为了避免这种歧义，可以使用完全括号化的中缀表达式，每个操作符和相应的操作数都用一对括号括起来。下面是改进后的中序遍历算法的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Infix</span><span class="params">(BinaryTreeNode&lt;T&gt; *t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 输出完全括号的中缀表达式</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">        <span class="comment">// 左操作数</span></span><br><span class="line">        Infix(t-&gt;LeftChild);</span><br><span class="line">        <span class="comment">// 操作符</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t-&gt;data;</span><br><span class="line">        <span class="comment">// 右操作数</span></span><br><span class="line">        Infix(t-&gt;RightChild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在后缀(postfix)表达式中，每个操作符跟在操作数之后，操作数从左到右的顺序出现；在前缀(prefix)表达式中，操作符位于操作数之前。前缀和后缀表达式都不会存在歧义，不需要采用括号或者优先级。从左到右或者从右到左扫描表达式并采用操作数栈，可以很容易确定操作数和操作符的关系。若在扫描中遇到一个操作数，把它压入堆栈，遇到一个操作符，则将其与栈顶的操作数相匹配，把这些操作数推出栈，由操作符执行相应的计算，并将所得结果作为操作数压入堆栈。</p>
<p>逐层遍历就是<strong>按从顶层到底层的次序访问树中元素，在同一层中，从左到右进行访问。</strong>由于遍历中使用的是一个队列而不是栈，因此写一个按层遍历的递归程序很困难。下列程序是采用队列来实现对二叉树进行逐层遍历，队列中的元素指向二叉树节点，这里使用了之前<a href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%971-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">队列章节</a>中使用的类<strong>LinkedQueue</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对*t逐层遍历</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt;  Q;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 将t的右孩子放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;LeftChild)</span><br><span class="line">            Q.Add(t-&gt;LeftChild);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;RightChild)</span><br><span class="line">            Q.Add(t-&gt;RightChild);</span><br><span class="line">        <span class="comment">// 访问下一个节点</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Q.Delete(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述程序中，首先仅当树非空时，才进入<code>while</code>循环。首先访问根节点，然后将其子节点加到队列中。当队列添加操作失败时，由Add会引发<code>NoMem</code>异常，由于没有捕捉该异常，所以发生该异常时函数将退出。在添加操作成功后，就进行从队列中删除t元素，如果成功，则删除的元素会返回到t中，这个删除的元素也就是下一个要访问的节点。下次访问该节点的时候，又会将其左右子树加入到队列的尾部，然后下一个要访问的就是根节点的右子树（如果存在），如此就可以实现逐层遍历了。而如果删除失败就表明队列为空，也就是意味着遍历的结束。</p>
<p>假设二叉树中元素的数目是<code>n</code>。这四种遍历算法的空间复杂性均为$O(n)$,时间复杂性是$\theta(n)$。当t的高度是n的时候，通过观察期前序、中序和后序遍历时所使用的递归栈空间可得到上述结论。当t是满二叉树的时候，逐层遍历所需要的队列空间是$\theta(n)$。每个遍历算法花在树中每个节点上的时间是$\theta(1)$(假设访问一个节点的时间是$\theta(1)$)。</p>
<h3 id="抽象数据类型BinaryTree"><a href="#抽象数据类型BinaryTree" class="headerlink" title="抽象数据类型BinaryTree"></a>抽象数据类型BinaryTree</h3><p>  下面给出二叉树的抽象数据类型，这里只列出几个常用的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 BinaryTree&#123;</span><br><span class="line">实例</span><br><span class="line">    元素集合；如果不空，则被划分为根节点、左子树和右子树；</span><br><span class="line">    每个子树仍是一个二叉树</span><br><span class="line">操作</span><br><span class="line">    Create()：创建一个空的二叉树；</span><br><span class="line">    IsEmpty：如果二叉树为空，则返回 true ，否则返回false</span><br><span class="line">    Root(x)：取x为根节点；如果操作失败，则返回false，否则返回true</span><br><span class="line">    MakeTree(root,left，right)：创建一个二叉树，root作为根节点，left作为左子树， right作为右子树</span><br><span class="line">    BreakTree(root，left，right)：拆分二叉树</span><br><span class="line">    PreOrder：前序遍历</span><br><span class="line">    InOrder：中序遍历</span><br><span class="line">    PostOrder：后序遍历</span><br><span class="line">    LevelOrder：逐层遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类BinaryTree"><a href="#类BinaryTree" class="headerlink" title="类BinaryTree"></a>类BinaryTree</h3><p>  下面给出类<strong>BinaryTree</strong>的C++定义。函数<strong>Visit</strong>作为遍历函数的参数，以实现不同操作的实现。该定义中使用了链表描述的二叉树。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class BinaryTree&#123;</span><br><span class="line">private:</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *root;    // 根节点指针</span><br><span class="line">    void PreOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">    void Inorder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">    void PostOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">public:</span><br><span class="line">    BinaryTree()&#123; root = 0; &#125;</span><br><span class="line">    ~BinaryTree()&#123;&#125;;</span><br><span class="line">    bool IsEmpty() const&#123;</span><br><span class="line">        return ((root) ? false : true);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Root(T&amp; x)const;</span><br><span class="line">    void MakeTree(const T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);</span><br><span class="line">    void BreakTree(const T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);</span><br><span class="line">    void PreOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        PreOrder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void Inorder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        Inorder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void PostOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        PostOrder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void LevelOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u));</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面会给出共享成员函数<code>Root,MakeTree,BreakTree</code>的代码。函数<code>MakeTree</code>和<code>BreakTree</code>要求参与操作的三棵树应该互不相同，否则程序会得出错误的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;T&gt;::Root(T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 取根节点的data域，放入x，如果没有则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (root)&#123;</span><br><span class="line">        x = root-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::MakeTree(<span class="keyword">const</span> T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)&#123;</span><br><span class="line">    <span class="comment">// 将left，right和element合并成一棵新树，并且要求left和right及this必须是不同的树。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新树</span></span><br><span class="line">    root = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(element, left.root, right.root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止访问left和right</span></span><br><span class="line">    left.root = right.root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::BreakTree(T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)&#123;</span><br><span class="line">    <span class="comment">// left,right 和this必须是不同的树</span></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="comment">// 空树</span></span><br><span class="line">        <span class="keyword">throw</span> BadInput();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分解树</span></span><br><span class="line">    element = root-&gt;data;</span><br><span class="line">    left.root = root-&gt;LeftChild;</span><br><span class="line">    right.root = root-&gt;RightChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出四种遍历方法的实现代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        PreOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">        PreOrder(Visit, t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::Inorder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        Inorder(Visit, t-&gt;LeftChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">        Inorder(Visit, t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PostOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        PostOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">        PostOrder(Visit, t-&gt;RightChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::LevelOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;* u))&#123;</span><br><span class="line">    <span class="comment">// 逐层遍历</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt;Q;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *t;</span><br><span class="line">    t = root;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 将t的右孩子放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;LeftChild)</span><br><span class="line">            Q.Add(t-&gt;LeftChild);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;RightChild)</span><br><span class="line">            Q.Add(t-&gt;RightChild);</span><br><span class="line">        <span class="comment">// 访问下一个节点</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Q.Delete(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是对类BinaryTree的简单应用，程序中构造了一个四节点的二叉树，并进行了前序遍历以确定书中的节点数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"xcept.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"BinaryTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">BinaryTree&lt;<span class="keyword">int</span>&gt;a, x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ct</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    y.MakeTree(<span class="number">1</span>, a, a);</span><br><span class="line">    z.MakeTree(<span class="number">2</span>, a, a);</span><br><span class="line">    x.MakeTree(<span class="number">3</span>, y, z);</span><br><span class="line">    y.MakeTree(<span class="number">4</span>, x, a);</span><br><span class="line">    y.PreOrder(ct);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Tree y has "</span>&lt;&lt; count &lt;&lt;<span class="string">" nodes"</span>&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象数据类型及类的扩充"><a href="#抽象数据类型及类的扩充" class="headerlink" title="抽象数据类型及类的扩充"></a>抽象数据类型及类的扩充</h3><p>  本节将扩充之前给出的抽象数据类型，增加如下二叉树操作：</p>
<ul>
<li><strong>PreOutput():</strong>按前序方式输出数据域</li>
<li><strong>InOutput():</strong>按中序方式输出数据域</li>
<li><strong>PostOutput():</strong>按后序方式输出数据域</li>
<li><strong>LevelOutput():</strong>逐层输出数据域</li>
<li><strong>Delete():</strong>删除一棵二叉树，释放其节点</li>
<li><strong>Height():</strong>返回树的高度</li>
<li><strong>Size():</strong>返回树中节点数</li>
</ul>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>  四个输出函数可以通过定义一个私有静态成员函数Output来实现，该函数代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Output</span><span class="params">(BinaryTreeNode&lt;T&gt;*t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而四个共享输出函数的形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PreOrder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Inorder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PostOrder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LevelOrder(Output);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Visit操作的时间复杂性是$\theta(1)$,对包括n个节点的二叉树来说，每种遍历方法所花费的时间是$\theta(n)$(遍历成功的话），因此每种输出方法的时间复杂性均为$\theta(n)$。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>  要删除一棵二叉树，需要删除其所有节点，可以通过<strong>后序遍历</strong>在访问一个节点时，将其删除，也就是先删除左子树，然后右子树，最后删除根。因此函数<strong>Delete</strong>的形式如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PostOrder(Free, root);</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Free</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中函数<strong>Free</strong>是一个私有成员函数。要删除的二叉树有n个节点时，<strong>Delete</strong>函数的时间复杂性是$\theta(n)$。</p>
<h4 id="计算高度"><a href="#计算高度" class="headerlink" title="计算高度"></a>计算高度</h4><p>  <strong>通过进行后序遍历，可以得到二叉树的高度。</strong>首先得到左子树的高度hl，然后得到右子树的高度hr，则树的高度为<strong>max{hl,hr}+1</strong>。</p>
<p>  但是这里不能使用之前定义的后序遍历代码，因为在进行遍历的时候需要有返回值（也就是子树的高度）。所以首先需要在增加一个共享成员函数Height,其代码为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Height(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后增加一个私有成员函数<strong>Height</strong>，其实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> BinaryTree&lt;T&gt;::Height(BinaryTreeNode&lt;T&gt; *t)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回树*t的高度</span></span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左子树高度</span></span><br><span class="line">    <span class="keyword">int</span> hl = Height(t-&gt;LeftChild);</span><br><span class="line">    <span class="comment">// 右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> hr = Height(t-&gt;RightChild);</span><br><span class="line">    <span class="keyword">if</span> (hl &gt; hr)</span><br><span class="line">        <span class="keyword">return</span> ++hl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ++hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数的时间复杂性是$\theta(n)$。</p>
<h4 id="统计节点数"><a href="#统计节点数" class="headerlink" title="统计节点数"></a>统计节点数</h4><p>  可以用上述四种遍历方法中的任何一种来获取二叉树中的节点数，因为每种遍历方法都对每个节点仅访问一次，只要在访问每个节点的时候将一个全局计数器加1即可。所以首先在类<strong>BinaryTree</strong>定义外定义一个全局变量：<code>int _count;</code>,然后增加一个共享成员函数<strong>Size</strong>和私有成员函数<strong>Add1</strong>，其代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add1</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    _count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _count = <span class="number">0</span>;</span><br><span class="line">    PreOrder(Add1, root);</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<strong>Size</strong>的时间复杂性是$\theta(n)$。</p>
<p>对于类<strong>BinaryTree</strong>的定义以及测试例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/BinaryTree" target="_blank" rel="external">二叉树</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本节内容主要是介绍了树的基本概念以及二叉树的定义、特性和实现代码，包括四种遍历树的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><block]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳表&散列2-散列]]></title>
    <link href="http://ccc013.github.io/2016/08/07/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%972-%E6%95%A3%E5%88%97/"/>
    <id>http://ccc013.github.io/2016/08/07/跳表-散列2-散列/</id>
    <published>2016-08-07T10:38:48.000Z</published>
    <updated>2016-10-27T12:10:56.751Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节内容是介绍字典的另一种描述方法—散列。</p>
<h3 id="散列表描述"><a href="#散列表描述" class="headerlink" title="散列表描述"></a>散列表描述</h3><h4 id="理想散列"><a href="#理想散列" class="headerlink" title="理想散列"></a>理想散列</h4><blockquote>
<p>字典的另一种描述方法就是<strong>散列（hash）</strong>，它是用一个散列函数（hash function）把关键字映射到散列表（hash table）中的特定位置。</p>
</blockquote>
<p>也就是使用哈希表来描述字典了。</p>
<p>在理想情况下，如果元素e的关键字是k，散列函数是f，那么e在散列表中的位置为$f(k)$。要搜索关键字为k的元素，首先要计算出$f(k)$，然后看$f(k)$处是否有元素，如果有，则找到该元素，如果没有，说明该字典中不包含该元素。在前一种情况中，如果要删除该元素，只需要把表中$f(k)$位置置为空即可，在后一种情况中，可以通过把元素放在$f(k)$位置以实现插入。</p>
<p>理想情况下，初始化一个空字典需要的时间为$\theta(b)$(b是散列表中位置的个数），搜索、插入和删除操作的时间均为$\theta(1)$。在许多场合都可以使用理想的散列方法，但对于关键字变化范围太大的应用是不能创建这样一个散列表的。</p>
<h4 id="线性开型寻址散列"><a href="#线性开型寻址散列" class="headerlink" title="线性开型寻址散列"></a>线性开型寻址散列</h4><p>  当关键字的范围太大，不能用理想方法表示时，可以采用比关键字范围小的散列表以及把多个关键字映射到同一个位置的散列函数。虽然有多种函数映射方法，但最常用的还是<strong>除法映射</strong>。其形式如下：</p>
<script type="math/tex; mode=display">
f(k) = k \% D</script><p>其中k是关键字，而D是散列表的大小，也就是位置数，而%是求模操作符。散列表中的位置号从0到D-1，每一个位置称为<strong>桶（bucket）</strong>。若关键字不是正整数型（如int，long,char, unsigned char等），则在计算f(k)之前必须把它转换成非负整数。对于一个长字符串，可以采用取其2个或4个字母来变成无符号整数或无符号长整数的方法。f(k)是存储关键字为k的元素的<strong>起始桶</strong>，在良性情况下，起始桶中存储的元素即是关键字为K的元素。</p>
<p>下图中给出一个散列表ht，桶号从0到10，在图a中，表中只有3个元素，除数D是11，由于80%11=3，所以80的位置是3,40%11=7,65%11=10，每个元素都在相应的桶中，散列表中余下的桶为空。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%971.png" alt="此处输入图片的描述"></p>
<p>现在假设要插入58,58的起始桶应该是f(58)=58%11=3,但是此时该桶中已经放了80了，这个时候就发生了<strong>碰撞</strong>。一般来说，一个桶中是可以存储多个元素的，而存储桶中若没有空间就发生<strong>溢出</strong>。但在我们的表中，每个桶只能存储一个元素，因此同时发生了碰撞和溢出。这个时候处理58的最简单的办法就是将其存储到表中下一个可用的桶中，这种解决溢出的方法叫做<strong>线性开型寻址(linear open addressing)</strong>。</p>
<p>因此如图b所示，将58存放在4号桶中。假设下一个要插入的元素值是24，其起始桶应该是2，然后就放入2号桶中，然后要插入35，其起始桶是2号，使用线性开型寻址的方法，它将被放入5号桶，最后一个要插入的是98，而10号桶已经满了，此时它被插入0号桶中。<strong>因此，在寻找下一个可用桶时，表被视为环形的。</strong></p>
<p>下面给出采用线性开型寻址的散列表的类定义。在类定义中假定散列表中每个元素的类型都是E，每个元素都有一个类型为K的key域。key域是用来计算起始桶的，因此类型K必须能够适应取模操作%。散列表使用了两个数组，ht和empty。当且仅当ht[i]中不含有元素时，empty[i]为true。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> HashTable&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hSearch</span><span class="params">(<span class="keyword">const</span> K&amp; k)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 散列函数的除数</span></span><br><span class="line">    <span class="keyword">int</span> D;</span><br><span class="line">    <span class="comment">// 散列数组</span></span><br><span class="line">    E *ht;</span><br><span class="line">    <span class="comment">// 一维数组</span></span><br><span class="line">    <span class="keyword">bool</span> *empty;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HashTable(<span class="keyword">int</span> divisor = <span class="number">11</span>);</span><br><span class="line">    ~HashTable()&#123; </span><br><span class="line">        <span class="keyword">delete</span>[] ht;</span><br><span class="line">        <span class="keyword">delete</span>[] empty;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp; k, E&amp; e)</span><span class="keyword">const</span></span>;</span><br><span class="line">    HashTable&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp;e);</span><br><span class="line">    HashTable&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp;k, E&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索操作的实现，对于私有成员<strong>hSearch</strong>会返回b号桶的三种情况有：1）<code>empty[b] == false &amp;&amp; ht[b] == k</code>；2）<code>empty[b] == true</code>，即表中没有关键字值为k的元素；3）<code>empty[b] == true &amp;&amp; ht[b] != k</code>,且表已满。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">int</span> HashTable&lt;E, K&gt;::hSearch(<span class="keyword">const</span> K&amp; k)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 查找一个开地址表，如果存在，返回k的位置，否则返回插入点（如果有足够空间）</span></span><br><span class="line">    <span class="comment">// 起始桶</span></span><br><span class="line">    <span class="keyword">int</span> i = k % D;</span><br><span class="line">    <span class="comment">// 在起始桶开始</span></span><br><span class="line">    <span class="keyword">int</span> j = i;  </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty[j] || ht[j] == k)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        <span class="comment">// 下一个桶</span></span><br><span class="line">        j = (j + <span class="number">1</span>) % D;</span><br><span class="line">    &#125; <span class="keyword">while</span> (j != i); <span class="comment">// j== i 表示回到起始桶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表已经满</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> HashTable&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp; k, E&amp; e)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k相匹配的元素并放入e，如果不存在，则返回false;</span></span><br><span class="line">    <span class="keyword">int</span> b = hSearch(k);</span><br><span class="line">    <span class="keyword">if</span> (empty[b] || ht[b] != k)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = ht[b];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入和删除操作如下，其中书中没有实现删除操作，而是作为课后练习题，所以删除操作是自己实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">HashTable&lt;E, K&gt;&amp; HashTable&lt;E, K&gt;::Insert(<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 在散列表中插入一个元素</span></span><br><span class="line">    K k = e;</span><br><span class="line">    <span class="keyword">int</span> b = hSearch(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否能完成插入</span></span><br><span class="line">    <span class="keyword">if</span> (empty[b])&#123;</span><br><span class="line">        empty[b] = <span class="literal">false</span>;</span><br><span class="line">        ht[b] = e;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能插入，检查是否有重复值或者表满</span></span><br><span class="line">    <span class="keyword">if</span> (ht[b] == k)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key "</span> &lt;&lt; k &lt;&lt; <span class="string">" already in the HashTable\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The  HashTable is full.\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">HashTable&lt;E, K&gt;&amp; HashTable&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 删除与k相匹配的元素，并放入e</span></span><br><span class="line">    <span class="keyword">int</span> b = hSearch(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否能进行删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (empty[b])&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key "</span> &lt;&lt; k &lt;&lt; <span class="string">" is not in the HashTable\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以删除</span></span><br><span class="line">    e = ht[b];</span><br><span class="line">    empty[b] = <span class="literal">true</span>;</span><br><span class="line">    ht[b] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = b;</span><br><span class="line">    <span class="keyword">int</span> j = (b+<span class="number">1</span>) % D;</span><br><span class="line">    <span class="comment">// 从下一个桶开始搜索是否存在另一个起始桶一样的元素</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!empty[j])&#123;</span><br><span class="line">            <span class="keyword">if</span> (ht[j] % D == i)&#123;</span><br><span class="line">                empty[i] = <span class="literal">false</span>;</span><br><span class="line">                ht[i] = ht[j];</span><br><span class="line">                empty[j] = <span class="literal">true</span>;</span><br><span class="line">                ht[j] = <span class="number">0</span>;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j = (j + <span class="number">1</span>) % D;</span><br><span class="line">    &#125; <span class="keyword">while</span> (j != b || empty[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更详细的例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/HashTable.h" target="_blank" rel="external">字典—哈希表实现</a></p>
<p>设b是散列表中桶的个数，散列函数中D为除数，且b=D。初始化表的时间是$\theta(b)$。当表中有n个元素时，最坏情况下插入和搜索时间均为$\theta(n)$。而当所有n个关键字值都在同一个桶中时出现最坏的情况。通过比较散列在最坏情况下的复杂性与线性表在最坏情况下的复杂性，可以看到两者完全相同。</p>
<p>但散列的平均性能还是相当好的。用$S_n$和$U_n$来分别表示一次成功搜索和不成功搜索中平均搜索的桶的个数。对于线性开型寻址，有如下公式成立：</p>
<script type="math/tex; mode=display">
U_n \sim \frac{1}{2} (1+\frac{1}{(1-\alpha)^2}) \\
S_n \sim \frac{1}{2} (1+\frac{1}{1-\alpha})</script><p>其中$\alpha = \frac{n}{b}$是负载因子。</p>
<p>所以若$\alpha =0.5$，则在不成功搜索时平均搜索的桶的个数为2.5个，而成功搜索时则是1.5个。当$\alpha =0.8$，则是50.5和5.5。所以当负载因子为0.5时，使用线性开型寻址散列表的平均性能要比线性表好。</p>
<p>另一个影响性能的参数是D。<strong>当D是素数或者D没有小于20的素数因子时，可以使性能达到最佳（D等于桶的个数b）</strong>。</p>
<p>而确定D的值，首先要了解影响成功搜索和不成功搜索性能的因素。通过$S_n$和$U_n$的公式，可以确定$\alpha$的值,然后再结合n的值，可以得到b的最小许可值，然后找到一个比b大的最小整数，这个整数要么是素数，要么没有小于20的素数因子，这个整数即可作为D和b的值。</p>
<p>另一种计算D的方法是首先根据散列表的最大空间来确定b的最大可能值，然后取D为不大于这个最大值的整数，该整数要么是素数，要么没有小于20的素数因子。例如，如果在表中最多可以分配530个桶，则D和b的最佳选择为23(因23*23=529)。</p>
<h4 id="链表散列"><a href="#链表散列" class="headerlink" title="链表散列"></a>链表散列</h4><p>  当散列发生溢出的时候，链表是一种好的解决方法。下图给出了散列表在发生溢出时采用链表来进行解决的方法。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%972.png" alt="此处输入图片的描述"></p>
<p>  在该散列表的组织中，每个桶仅含有一个节点指针，所有的元素都是存储在该指针所指向的链表中。</p>
<p>  下面给出代码实现，该类使用了类<strong>SortedChain</strong>的成员。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> ChainHashTable&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 位置数</span></span><br><span class="line">    <span class="keyword">int</span> D;</span><br><span class="line">    <span class="comment">// 链表数组</span></span><br><span class="line">    SortedChain&lt;E, K&gt;* ht;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChainHashTable(<span class="keyword">int</span> divisor = <span class="number">11</span>)&#123;</span><br><span class="line">        D = divisor;</span><br><span class="line">        ht = <span class="keyword">new</span> SortedChain&lt;E, K&gt;[D];</span><br><span class="line">    &#125;</span><br><span class="line">    ~ChainHashTable()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ht;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp;k, E&amp; e)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ht[k%D].Search(k, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ChainHashTable&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">        ht[k%D].DistinctInsert(k, e);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ChainHashTable&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">        ht[k%D].Delete(k, e);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>一种改进方法是在每条链表中添加一个尾节点，尾节点中的关键字值最起码要比散列中所有元素的关键字值都大。</strong>如下图所示。在实际实现的过程中，所有的链表可以共用同一个尾节点。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%973.png" alt="此处输入图片的描述"></p>
<h4 id="线性开型寻址与链表散列的比较"><a href="#线性开型寻址与链表散列的比较" class="headerlink" title="线性开型寻址与链表散列的比较"></a>线性开型寻址与链表散列的比较</h4><p>  将线性开型寻址与没有尾节点的链表散列进行比较。令s为每个元素需占用的空间（以字节为单位），每个指针和每个整数类型的变量各占用2个字节空间。同时，设散列表中有b个桶和n个元素。首先注意到使用线性开型寻址时有$n \le b$,而使用链表散列则是n可能大于b。</p>
<p>  采用线性开型寻址所需要的空间为$b(s+2)$个字节，其中s为每个元素所占用的字节数。而使用链表所需要的空间为$2b+2n+ns$字节，当$n \lt \frac{bs}{s+2}$时，链表所用的空间要比开型寻址少。</p>
<p>  在最坏情况下，两种方法进行搜索，都需要搜索所有的n个元素。链表散列的平均搜索次数，其一次不成功搜索和一次成功搜索的平均搜索的桶数如下公式所示：</p>
<script type="math/tex; mode=display">
U_n   \sim \frac{\alpha+1}{2},\alpha \ge 1 \\
S_n   \sim 1+\frac{\alpha}{2}</script><p>将线性开型寻址的公式与链表散列的公式相比较，可以看到使用链表时的平均性能要优于使用线性开型寻址。例如，当$\alpha = 0.9$时，链表散列的一次不成功搜索，平均需要检查0.95个元素，一次成功搜索需要检查1.45个元素。而对于线性开型寻址，则是分别为50.5个5.5个元素。</p>
<h4 id="散列与跳表比较"><a href="#散列与跳表比较" class="headerlink" title="散列与跳表比较"></a>散列与跳表比较</h4><p>  散列与跳表均使用了随机过程来提高字典操作的性能。<strong>使用跳表时，插入操作用随机过程来决定一个元素的级数。</strong>这种级数分配不需要考虑插入元素的值。<strong>在散列中，当对不同元素进行插入时，散列函数随机地位不同元素分配桶，但散列函数需要使用元素的值。</strong></p>
<p>  <strong>通过使用随机过程，跳表和散列操作的平均复杂性分别为对数时间和常数时间。</strong>跳表的最坏时间复杂性为$(n+ MaxLevel)$，而散列的最坏时间复杂性为$\theta(n)$ 。跳表中指针平均占用的空间约为$Maxlevel+\frac{n}{1-p}$，在最坏情况下可能相当大。链表散列的指针所占用的空间为$D+n$。</p>
<p>不过，跳表比散列更灵活。例如，只需简单地沿着0级链就可以在线性时间内按升序输出所有的元素。而采用链表散列时，需要$\theta(D+n)$时间去收集n个元素并且需要$O(nlogn)$时间进行排序，之后才能输出。对于其他的操作，如查找或删除最大或最小元素，散列可能要花费更多的时间（仅考虑平均复杂性）。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本节介绍了字典的另一种实现方法—散列的实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节内容是介绍字典的另一种描述方法—散列。</p>
<h3 id="散列表描述"><a href="#散列表描述" class="headerlink" title="散列表描述"></a>散列]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳表&散列1-字典&跳表]]></title>
    <link href="http://ccc013.github.io/2016/07/27/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%971-%E5%AD%97%E5%85%B8-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/07/27/跳表-散列1-字典-跳表/</id>
    <published>2016-07-27T14:09:02.000Z</published>
    <updated>2016-10-27T12:10:14.361Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节会介绍字典和跳表。</p>
<p>对于一个有n个元素的有序数组，用折半搜索法进行搜索需要的时间是$O(logn)$,而对一个有序链表进行搜索所需要的时间是$O(n)$。我们可以通过对有序链表上的全部或部分节点增加额外的指针，来提供搜索性能。在搜索时，可以通过这些指针来跳过链表中若干个节点，因此没有必要从左到右搜索链表中的所有节点。</p>
<p><strong>增加了向前指针的链表叫做跳表。</strong>跳表采用随机技术决定链表中哪些节点应增加向前指针以及在节点中应增加多少个指针。采用这种随机技术，跳表中的搜索、插入和删除操作的时间均为$O(logn)$,然而，最坏情况下下时间复杂性却变成$\theta(n)$。而在一个有序数组或链表中进行插入/删除操作的时间为$O(n)$,最坏情况下为$\theta(n)$。</p>
<p><strong>散列法是用来搜索、插入和删除记录的另一种随机方法</strong>。与跳表相比，它的插入/删除操作时间提高到$\theta(1)$,最坏情况下仍为$\theta(n)$。尽管如此，在经常将所有元素按序输出或按序号搜索元素时，跳表的执行效率将优于散列。</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><blockquote>
<p>字典(dictionary)是一些元素的集合。每个元素有一个称作key的域，不同元素的key各不相同。</p>
</blockquote>
<p>抽象数据类型如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型Dictionary&#123;</span><br><span class="line">实例</span><br><span class="line">    具有不同关键字的元素集合</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空字典</span><br><span class="line">    Search(k,x): 搜索关键字为k的元素，结果放入x;如果没找到，则返回false，否则返回true；</span><br><span class="line">    Insert(x): 向字典中插入元素x</span><br><span class="line">    Delete(k,x): 删除关键字为k的元素，并将其放入x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若仅按照一个字典元素本身的关键字来访问该元素，则称为<strong>随机访问</strong>；而<strong>顺序访问</strong>是指按照关键字的递增顺序逐个访问字典中的元素。顺序访问需要借助于<strong>Begin(用来返回关键字最小的元素</strong>和<strong>Next（用来返回下一个元素）</strong>等操作来实现。</p>
<p>在有重复元素的字典与上述抽象数据类型定义的字典相似，只是它允许有相同的关键字。在有重复关键字的字典中，在搜索和删除时需要一个规则来消除歧义。也就是说，如果搜索或删除关键字为k的元素，那么在所有关键字为k的元素中应该返回或者删除哪一个。在有些字典应用中，可能需要，删除在某个时间以后插入的所有元素。</p>
<h3 id="线性表描述"><a href="#线性表描述" class="headerlink" title="线性表描述"></a>线性表描述</h3><p>  字典可以保存在线性序列($e_1,e_2,\cdots$)中，其中$e_i$是字典中的元素，其关键字从左到右依次增大。这里可以根据公式化描述或者链表描述自定义类SortedList和SortedChain。</p>
<p>  下面给出的是类SortedChain的定义。E表示链表元素的数据类型，K是链表中排序用到的关键字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> SORTEDCHAIN_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SORTEDCHAIN_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SortedChainNode&#123;</span><br><span class="line">    <span class="keyword">friend</span> SortedChain&lt;E, K&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    K key;</span><br><span class="line">    E data;</span><br><span class="line">    SortedChainNode&lt;E,K&gt; * link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SortedChain&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SortedChainNode&lt;E, K&gt;* first;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SortedChain()&#123; first = <span class="number">0</span>; &#125;</span><br><span class="line">    ~SortedChain();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp; k, E&amp; e)</span><span class="keyword">const</span></span>;</span><br><span class="line">    SortedChain&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp; k, E&amp;e);</span><br><span class="line">    SortedChain&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp; e);</span><br><span class="line">    SortedChain&lt;E, K&gt;&amp; DistinctInsert(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> E&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索和删除操作的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> SortedChain&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp; k, E&amp; e)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k匹配的元素，结果放入e，如果没有匹配的元素，则返回false</span></span><br><span class="line"></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* p = first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索与K相匹配的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; p&amp;&amp; p-&gt;key != k; p = p-&gt;link)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&amp;&amp;p-&gt;key == k)&#123;</span><br><span class="line">        e = p-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no key--"</span> &lt;&lt; k &lt;&lt; <span class="string">" in sortedChain\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SortedChain&lt;E, K&gt;&amp; SortedChain&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 删除与k相匹配的元素，并将其放入e</span></span><br><span class="line"></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* p = first;</span><br><span class="line">    <span class="comment">// 跟踪p</span></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* tp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; p-&gt;key != k; tp = p, p = p-&gt;link)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;key == k)&#123;</span><br><span class="line">        e = p-&gt;data;</span><br><span class="line">        <span class="comment">// 从链表中删除p所指向的元素</span></span><br><span class="line">        <span class="keyword">if</span> (tp)</span><br><span class="line">            tp-&gt;link = p-&gt;link;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// p是链表首节点</span></span><br><span class="line">            first = p-&gt;link;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> p;   </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no key--"</span> &lt;&lt; k &lt;&lt; <span class="string">" in sortedChain\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入操作如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SortedChain&lt;E, K&gt;&amp; SortedChain&lt;E, K&gt;::DistinctInsert(<span class="keyword">const</span> K&amp; k,<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 如果表中不存在关键值与e相同的元素，则插入e，否则引发异常BadInput</span></span><br><span class="line"></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* p = first;</span><br><span class="line">    <span class="comment">// 跟踪p</span></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* tp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动tp以便把e插入到tp之后</span></span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; p-&gt;key != k; tp = p, p = p-&gt;link);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;key == k)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is already key--"</span> &lt;&lt; k &lt;&lt; <span class="string">" in sortedChain,please choose another key.\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若没有出现重复关键值，则产生一个关键值为e的新节点</span></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* q = <span class="keyword">new</span> SortedChainNode&lt;E, K&gt;;</span><br><span class="line">    q-&gt;data = e;</span><br><span class="line">    q-&gt;key = k;</span><br><span class="line">    <span class="comment">// 将新节点插入到tp之后</span></span><br><span class="line">    q-&gt;link = p;</span><br><span class="line">    <span class="keyword">if</span> (tp)</span><br><span class="line">        tp-&gt;link = q;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        first = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类SortedChain提供了两种插入操作，上述<code>DistinctInset</code>操作保证链中所有元素有不同的关键字，而<code>Insert</code>允许有相同的关键字。</p>
<p>更详细的内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/SortedChain.h" target="_blank" rel="external">字典—链表实现</a></p>
<h3 id="跳表描述"><a href="#跳表描述" class="headerlink" title="跳表描述"></a>跳表描述</h3><h4 id="理想情况"><a href="#理想情况" class="headerlink" title="理想情况"></a>理想情况</h4><p>  在一个有序链表描述的具有n个元素的字典中进行搜索，至多需要进行n次比较，而如果在链表中部节点加一个指针，则比较次数可以减少到$\frac{n}{2}+1$。搜索的时候，首先将欲搜索元素与中间元素进行比较，如果欲搜索的元素较小，则仅需搜索链表的左半部分，否则，只需搜索链表的右半部分。</p>
<p>  如下图a所示是一个有序链表的七个元素，它有一个头节点和一个尾节点。节点中的数是该节点的值。对该链表搜索可能需要进行7次比较。如果使用图b的方法，在中间增加一个指针，则最坏情况下比较次数减少到4次。</p>
<p>  还可以像图c中一样，再在左半部分和右半部分各增加一个指针，这样可以进一步减少最坏情况下的比较次数。在该图中有3条链，0级链就是图a中的初始链，1级链包括第二，四，六个元素，而2级链只包括第四个元素。</p>
<p>  一个例子是要查找元素77，首先会跟40相比，由于$70 \gt 40$,则在1级链中与75比较，然后$77 \gt 75$，因此在0级链中与80比较，此时可以知道77不在字典中。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E8%B7%B3%E8%A1%A81.png" alt="此处输入图片的描述"></p>
<p>  <strong>通常0级链包括n个元素，1级链包括$\frac{n}{2}$个元素，2级链包括$\frac{n}{4}$个元素，而每$2^i$个元素就有一个i级链指针。当且仅当一个元素在0~i级链上，但不在i+1级（若该链存在）链上时，我们就是说该元素是i级链元素</strong>。所以图c中，40是2级链上唯一的元素，75是1级链元素，20、30、60、80是0级链元素。</p>
<p>  图c所示的结构就是<strong>跳表（skip list）</strong>。在该结构中有一组有层次的链。0级链式包含所有元素的有序链表，1级链是0级链的一个子集。<strong>i级链是i-1级链的子集</strong>。</p>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>  在进行插入和删除时，要想保持上图c的跳表结构，必须耗时$O(n)$。注意到在这种结构中，有<strong>$\frac{n}{2^i}$个元素为i级链元素</strong>，所以在进行插入时应尽量逼近这种结构。在进行插入时，新元素属于i级链的概率为$\frac{1}{2^i}$。在确定新元素的级时，应考虑各种可能的情况。因此，把新元素作为i级链元素的可能性为$p^i$,图c中p=0.5。对于一般的p，链的级数为$\lfloor (log_{\frac{1}{p}}n) \rfloor + 1$,在这种情况下，每p个i-1级链就有一个在i级链中。</p>
<p>  上图d是插入元素77的示例，新元素插在75和80之间，如图d中的虚线所示。插入时，要为新元素分配一个级，分配过程由随机数产生器完成。</p>
<p>  若新元素为i级链元素，则仅影响由虚线断开的0~i级链指针。上图e给出新插入元素77作为1级链表时链表的结构。</p>
<p>  对于删除操作，我们无法控制其结构。</p>
<h4 id="级的分配"><a href="#级的分配" class="headerlink" title="级的分配"></a>级的分配</h4><p>  在级基本的分配过程中，可以观察到，在一般跳表结构中，i-1级链中的元素属于i级链的概率为p。假设有一随机数产生器所产生的数在0到RAND_MAX之间，则下一次所产生的随机数小于等于<code>CutOff = p * RAND_MAX</code>的概率为p。因此，若下一随机数小于等于<code>CutOff</code>,则新元素应在1级链上，然后继续确定新元素是否在2级链上，这将由下一个随机数来决定，如果新的随机数继续小于等于<code>CutOff</code>,重复这个过程，直到一个随机数大于<code>CutOff</code>为止。</p>
<p>  所以可以用下列代码为要插入的元素分配级:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lev = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(rand() &lt;= CutOff)</span><br><span class="line">    lev++;</span><br></pre></td></tr></table></figure></p>
<p>  这种方法潜在的缺点是可能为某些元素分配特别大的级，从而导致一些元素的级远远超过$log_{\frac{1}{p}}N$,其中N为字典中预期的最大数目。为避免这种情况，可以设定一个上限lev。在有N个元素的跳表中，级MaxLevel的最大值为$\lceil log_{\frac{1}{p}}N \rceil -1$,可以采用此值作为上限。</p>
<p>  另一个缺点是即使采用上面给出的上限，但还是可能存在下面的情况，如在插入一个元素前有3条链，但在插入之后就有了10条链，此时，新插入元素的是9级，尽管在前面插入中没有出现3到8级的元素，也就是在此插入前并没有插入3到8级的元素。既然这些空级没有直接的好处，那么可以直接把新元素的级调整为3。</p>
<h4 id="类SkipNode"><a href="#类SkipNode" class="headerlink" title="类SkipNode"></a>类SkipNode</h4><p>  跳表结构的头节点需要有足够的指针域，以满足可能构造最大级数的需要，而尾节点不需要指针域。每个存有元素的节点都有一个data域和（级数+1）个指针域。下面给出自定义类<strong>SkipNode</strong>，指针域由数组link表示，其中link[i]表示i级链指针。构造函数为指针数组分配空间，对于一个lev级链元素，其size值为lev+1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SkipList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SkipNode&#123;</span><br><span class="line">    <span class="keyword">friend</span> SkipList&lt;E, K&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SkipNode(<span class="keyword">int</span> size)&#123;</span><br><span class="line">        link = <span class="keyword">new</span> SkipNode&lt;E, K&gt;*[size];</span><br><span class="line">    &#125;</span><br><span class="line">    ~SkipNode() &#123; <span class="keyword">delete</span>[] link; &#125;</span><br><span class="line"></span><br><span class="line">    E data;</span><br><span class="line">    <span class="comment">// 一维指针数组</span></span><br><span class="line">    SkipNode&lt;E, k&gt; **link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="类SkipList"><a href="#类SkipList" class="headerlink" title="类SkipList"></a>类SkipList</h4><p>  下面给出类<strong>SkipList</strong>的定义。MaxE是字典的最大容量。虽然给出的代码中允许元素数目超过MaxE，但若元素数目不超过MaxE，平均性能会更好一些。一个元素既在i-1级链上又在i级链上的概率是p，Large是一个比字典中任意一个数均大的值。尾节点的值为Large。0级链上的值（不包括头节点，因其没有值）从左到右按升序排列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SkipList&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Level</span><span class="params">()</span></span>;</span><br><span class="line">    SkipNode&lt;E, K&gt;* SaveSearch(<span class="keyword">const</span> K&amp; k);</span><br><span class="line">    <span class="comment">// 所允许的最大级数</span></span><br><span class="line">    <span class="keyword">int</span> MaxLevel;</span><br><span class="line">    <span class="comment">// 当前非空链的个数</span></span><br><span class="line">    <span class="keyword">int</span> Levels;</span><br><span class="line">    <span class="comment">// 用于确定级号</span></span><br><span class="line">    <span class="keyword">int</span> CutOff;</span><br><span class="line">    <span class="comment">// 一个很大的key值</span></span><br><span class="line">    K TailKey;</span><br><span class="line">    <span class="comment">// 头节点指针</span></span><br><span class="line">    SkipNode&lt;E, K&gt;* head;</span><br><span class="line">    <span class="comment">// 尾节点指针</span></span><br><span class="line">    SkipNode&lt;E, K&gt;* tail;</span><br><span class="line">    <span class="comment">// 指针数组</span></span><br><span class="line">    SkipNode&lt;E, K&gt;** last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SkipList(K Large, <span class="keyword">int</span> MaxE = <span class="number">10000</span>, <span class="keyword">float</span> p = <span class="number">0.5</span>);</span><br><span class="line">    ~SkipList();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp;k, E&amp;e)</span><span class="keyword">const</span></span>;</span><br><span class="line">    SkipList&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp; e);</span><br><span class="line">    SkipList&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp;k, E&amp;e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造函数和析构函数如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;::SkipList(K Large, <span class="keyword">int</span> MaxE, <span class="keyword">float</span> p)&#123;</span><br><span class="line">    CutOff = p * RAND_MAX;</span><br><span class="line">    MaxLevel = <span class="built_in">ceil</span>(<span class="built_in">log</span>(MaxE) / <span class="built_in">log</span>(<span class="number">1</span> / p)) - <span class="number">1</span>;</span><br><span class="line">    TailKey = Large;</span><br><span class="line">    <span class="comment">// 初始化随机发生器</span></span><br><span class="line">    randomize();</span><br><span class="line">    <span class="comment">// 对级号进行初始化</span></span><br><span class="line">    Levels = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建头节点、尾节点以及数组last</span></span><br><span class="line">    head = <span class="keyword">new</span> SkipNode&lt;E, K&gt;(MaxLevel + <span class="number">1</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> SkipNode&lt;E, K&gt;(<span class="number">0</span>);</span><br><span class="line">    last = <span class="keyword">new</span> SkipNode&lt;E, K&gt; *[MaxLevel + <span class="number">1</span>];</span><br><span class="line">    tail-&gt;data = Large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有级均置空，即将head指向tail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MaxLevel; i++)</span><br><span class="line">        head-&gt;link[i] = tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;::~SkipList()&#123;</span><br><span class="line">    SkipNode&lt;E, K&gt;* next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过删除0级链来删除所有节点</span></span><br><span class="line">    <span class="keyword">while</span> (head != tail)&#123;</span><br><span class="line">        next = head-&gt;link[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>搜索、插入和删除函数均要求对E进行重载，以便在E的成员之间、E与K的成员之间进行比较。从K到E的赋值和转换也必须定义。当每个元素都有一个整数域data和一个长整数域key，且元素的值由key给出时，可使用下列程序定义的重载。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> element&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">long</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    element&amp; <span class="keyword">operator</span>=(<span class="keyword">long</span> y)&#123;</span><br><span class="line">        key = y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">long</span> key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>SkipList</strong>有两个搜索函数。当需要定位一个值为k的元素时，可使用共享成员函数<strong>Search</strong>。该函数从最高级链（Levels级，仅含一个元素）开始查找，一直到0级链。在每一级链中尽可能地逼近要查找的元素。当从for循环退出时，正好处在欲寻找元素的左边。与0级链中的下一个元素进行比较，即可确定要找的元素是否在跳表中。</p>
<p>第二个搜索函数是私有成员函数<strong>SaveSearch</strong>，由插入和删除操作来调用。<strong>SaveSearch</strong>不仅包含了<strong>Search</strong>的功能，而且可把每一级中遇到的最后一个节点存放在数组last之中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp; k, E&amp; e)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k相匹配的元素，并将找到的元素放入e，如果不存在则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= TailKey)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 调整指针p，使其恰好指向可能与k相匹配的节点的前一个节点</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Levels; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="comment">// 逐级向下</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;link[i]-&gt;data &lt; k)</span><br><span class="line">            <span class="comment">// 在第i级链中搜索</span></span><br><span class="line">            p = p-&gt;link[i];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 检查是否下一个节点拥有关键值k</span></span><br><span class="line">    e = p-&gt;link[<span class="number">0</span>]-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> (e == k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipNode&lt;E, K&gt;* SkipList&lt;E, K&gt;::SaveSearch(<span class="keyword">const</span> K&amp; k)&#123;</span><br><span class="line">    <span class="comment">// 搜索k并保存最终所得到的位置</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Levels; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 逐级向下</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;link[i]-&gt;data &lt; k)</span><br><span class="line">            <span class="comment">// 在第i级链中搜索</span></span><br><span class="line">            p = p-&gt;link[i];</span><br><span class="line">        last[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;link[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出插入和删除操作的实现代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">int</span> SkipList&lt;E, K&gt;::Level()&#123;</span><br><span class="line">    <span class="comment">// 产生一个随机级号，该级号&lt;= MaxLevel</span></span><br><span class="line">    <span class="keyword">int</span> lev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (rand() &lt;= CutOff)</span><br><span class="line">        lev++;</span><br><span class="line">    <span class="keyword">return</span> (lev &lt;= MaxLevel) ? lev : MaxLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;&amp; SkipList&lt;E, K&gt;::Insert(<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 如果不存在重复，则插入e</span></span><br><span class="line">    K k = e;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= TailKey)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is larger than "</span> &lt;&lt; TailKey &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否重复</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = SaveSearch(k);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data == e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is already in SkipList\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不重复，为新节点确定级号</span></span><br><span class="line">    <span class="keyword">int</span> lev = Level();</span><br><span class="line">    <span class="keyword">if</span> (lev &gt; Levels)&#123;</span><br><span class="line">        lev = ++Levels;</span><br><span class="line">        last[lev] = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生新节点，并将新节点插入p之后</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*y = <span class="keyword">new</span> SkipNode&lt;E, K&gt;(lev + <span class="number">1</span>);</span><br><span class="line">    y-&gt;data = e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lev; i++)&#123;</span><br><span class="line">        <span class="comment">// 插入到第i级链</span></span><br><span class="line">        y-&gt;link[i] = last[i]-&gt;link[i];</span><br><span class="line">        last[i]-&gt;link[i] = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;&amp; SkipList&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp;k, E&amp;e)&#123;</span><br><span class="line">    <span class="comment">// 删除与k相匹配的元素，并将删除的元素放入e。</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= TailKey)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is larger than "</span> &lt;&lt; TailKey &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否存在与k相匹配的元素</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = SaveSearch(k);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data ！= e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is already in SkipList\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从跳表中删除节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Levels &amp;&amp; last[i]-&gt;link[i] == p; i++)</span><br><span class="line">        last[i]-&gt;link[i] = p-&gt;link[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改级数</span></span><br><span class="line">    <span class="keyword">while</span> (Levels &gt; <span class="number">0</span> &amp;&amp; head-&gt;link[Levels] == tail)</span><br><span class="line">        Levels--;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当跳表中有n个元素的时候，搜索、插入和删除操作的复杂性均为$O(n+MaxLevel)$。</p>
<p>更详细内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/SkipList.h" target="_blank" rel="external">跳表的实现</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本节首先介绍了字典的定义以及使用链表描述来实现字典，然后介绍了跳表及其代码实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节会介绍字典和跳表。</p>
<p>对于一个有n个元素的有序数组，用折半搜索法进行搜索需要的时间是$O(logn)$,而对一个有序链表进行搜索所需要的时间是$O(n)$。我们可以通过对有序链表]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[队列-基本概念及实现方法]]></title>
    <link href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%97-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://ccc013.github.io/2016/07/23/队列-基本概念及实现方法/</id>
    <published>2016-07-23T09:43:35.000Z</published>
    <updated>2016-10-21T14:24:06.929Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第六章队列的内容。</p>
<blockquote>
<p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行，因此，队列是一个<strong>先进先出(first-in-first-out,FIFO)的线性表</strong>。</p>
</blockquote>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><blockquote>
<p>定义  队列(queue)是一个线性表，其插入和删除操作分别在表的不同端进行。添加新元素的那一端称为队尾(rear),而删除元素的那一端被称为队首(front)。</p>
</blockquote>
<p>其抽象数据类型如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型Queue&#123;</span><br><span class="line">实例</span><br><span class="line">    有序线性表，一端称为front，另一端称为rear；</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空的队列；</span><br><span class="line">    IsEmpty(): 如果队列为空，则返回true，否则返回false；</span><br><span class="line">    IsFull(): 如果队列满，则返回true，否则返回false；</span><br><span class="line">    First(): 返回队列的第一个元素；</span><br><span class="line">    Last(): 返回队列的最后一个元素；</span><br><span class="line">    Add(x): 向队列中添加元素x；</span><br><span class="line">    Delete(x): 删除队首元素，并送入x；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="公式描述"><a href="#公式描述" class="headerlink" title="公式描述"></a>公式描述</h3><p>  使用公式$location(i)=i-1$来描述一个队列，那么所使用的数组是<code>queue[MaxSize]</code>,那么第一个元素是queue[0],第二个元素是queue<a href="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%971.png" target="_blank" rel="external">1</a>,$\cdots$。<strong>front总是为0，而rear始终是最后一个元素的位置，队列的长度为rear+1，对于一个空队列有rear=-1</strong>。</p>
<p>  按照上述公式描述队列，在添加一个元素的时候，需要将rear加1，并把新元素放入queue[rear]，其所需要的时间是$O(1)$。而删除一个元素，则需要将位置1到位置n的元素分别左移一个位置，即删除一个元素需要花费的时间是$\theta(n)$，n是删除完成后队列中的元素数目。因此，这个公式对于队列的删除操作会花费比较多时间，虽然其应用在堆栈的时候，堆栈的添加和删除操作所需时间只需要$\theta(1)$。</p>
<p>  这里考虑另一个公式$location(i)=location(1)+i-1$,它可以使得队列的删除操作所需要的时间减小至$\theta(1)$。因为在删除的时候，只需要简单的将location(1)加1即可。在用该公式的时候，<strong>front = location(1), rear=location(最后一个元素),一个空队列具有形状$rear \lt front$</strong>。</p>
<p>  如下图所示，每次操作将导致front右移一个位置。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%971.png" alt="此处输入图片的描述"></p>
<p>  当$rear \lt MaxSize-1$时才可以直接在队列的尾部添加新元素。若$rear = MaxSize-1且front \gt 0$时（表明队列未满），为了能够继续向队列添加新元素，必须将所有元素平移到队列的左端，如下图所示，以便在队列的右端留出空间。在使用新的公式情况下，最坏情况下的时间复杂性增加了$\theta(n)$，所以，新公式在提高删除操作执行效率的同时，却降低了添加操作的执行效率。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%972.png" alt="此处输入图片的描述"></p>
<p>  上述两个公式都各有缺点，所以这里就有了第三个公式，可以将队列的添加和删除操作在最坏情况下的时间复杂性均为$\theta(1)$,如下所示：</p>
<script type="math/tex; mode=display">
location(i) = (location(1)+i-1)\% MaxSize</script><p>这个时候用来描述队列的数组被视为一个环，如下所示，此时，<strong>front指向队列首元素的下一个位置（逆时针），而rear的含义不变</strong>。下图b是添加一个元素，而图c表示的是删除了一个元素。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%973.png" alt="此处输入图片的描述"></p>
<p>当且仅当front=rear时队列为空，但是由于队列满的条件也是front=rear，所以为了避免这种问题，可以不允许队列被填满，在添加元素前，先判断本次操作是否会导致队列被填满，如果是，则报错。因此，队列的最大容量实际上是MaxSize-1。</p>
<p>下面给出基于公式化描述的类Queue的代码实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Queue&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 与第一个元素在逆时针方向上相差一个位置</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">// 指向最后一个元素</span></span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    T* <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Queue(<span class="keyword">int</span> MaxQueueSize = <span class="number">10</span>);</span><br><span class="line">    ~Queue()&#123; <span class="keyword">delete</span>[] <span class="built_in">queue</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> front == rear; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((rear + <span class="number">1</span>) % MaxSize == front) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">First</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Last</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Queue&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    Queue&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面给出其添加和删除操作函数的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Queue&lt;T&gt;&amp; Queue&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将x添加到队列的尾部</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull())</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="built_in">queue</span>[rear] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Queue&lt;T&gt;&amp; Queue&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除第一个元素，并将其送入x</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">    x = <span class="built_in">queue</span>[front];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他成员函数实现可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Queue/Queue.h" target="_blank" rel="external">Queue-数组实现</a></strong>。</p>
<h3 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h3><p>  像堆栈一样，也可以使用链表来实现一个队列。此时需要两个变量<strong>front和rear</strong>分别跟踪队列的两端。这时有两种情形：从front开始链接到rear，如下图a所示，或者从rear开始链接到front，如下图b所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%974.png" alt="此处输入图片的描述"></p>
<p>  下面两张图分别展示了两种情形添加和删除操作，两种情形都适合于添加操作，而从front到rear的链接更便于删除操作的执行，因此，我们将采用从front到rear的链接模式。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%975.png" alt="此处输入图片的描述"> <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%976.png" alt="此处输入图片的描述"></p>
<p>  可以取处置<strong>front=rear=0，且当且仅当队列为空时front=0</strong>。下面程序给出自定义类<strong>LinkedQueue</strong>。除了析构函数外，链表队列所有成员函数的复杂性均为$\theta(1)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Node&#123;</span><br><span class="line">    <span class="keyword">friend</span> LinkedQueue&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt;* link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedQueue&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* front;</span><br><span class="line">    Node&lt;T&gt;* rear;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedQueue()&#123; front = rear = <span class="number">0</span>; &#125;</span><br><span class="line">    ~LinkedQueue();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((front) ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">First</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Last</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    LinkedQueue&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    LinkedQueue&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后同样是给出添加和删除操作的实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedQueue&lt;T&gt;&amp; LinkedQueue&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 添加元素x</span></span><br><span class="line">    Node&lt;T&gt;* p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;link = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (front)</span><br><span class="line">        <span class="comment">// 队列不为空</span></span><br><span class="line">        rear-&gt;link = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 队列为空</span></span><br><span class="line">        front = p;</span><br><span class="line">    rear = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedQueue&lt;T&gt;&amp; LinkedQueue&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除第一个元素，并放入x</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    x = front-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第一个节点</span></span><br><span class="line">    Node&lt;T&gt;* p = front;</span><br><span class="line">    front = front-&gt;link;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Queue/LinkedQueue.h" target="_blank" rel="external">链表实现的队列</a></strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本节主要是简单介绍了队列的定义以及使用数组和链表来实现的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第六章队列的内容。</p>
<blockquote>
<p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行，因此，队列是一个<strong>先进先出(first-in-first-out,FIFO)的线]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆栈2-应用]]></title>
    <link href="http://ccc013.github.io/2016/07/21/%E5%A0%86%E6%A0%882-%E5%BA%94%E7%94%A81/"/>
    <id>http://ccc013.github.io/2016/07/21/堆栈2-应用1/</id>
    <published>2016-07-21T11:05:25.000Z</published>
    <updated>2016-10-21T14:23:16.058Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，继续第五章堆栈的内容，这节是最后关于应用方面的内容。这节会介绍括号的匹配，汉诺塔，火车车厢重排三个问题。</p>
<h3 id="括号的匹配"><a href="#括号的匹配" class="headerlink" title="括号的匹配"></a>括号的匹配</h3><p>  括号的匹配就是要匹配一个字符串中的左、右括号。目标是编写一个C++程序，其输入为一个字符串，输出为相互匹配的括号以及未能匹配的括号。注意，括号匹配问题可用来解决C++程序中的{和}的匹配问题。</p>
<p>  可以观察到，<strong>如果从左至右扫描一个字符串，那么最近每个右括号将于最近遇到的未匹配的左括号相匹配</strong>。因此，我们可以在从左至右的扫描过程中，把所遇到的左括号放到堆栈内，每当遇到一个右括号时，就将它与栈顶的左括号(如果存在)相匹配，同时从栈顶删除该左括号。</p>
<p>  下面给出括号匹配问题实现的代码，其时间复杂性是$\theta(n),其中n$是输入串的长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大的字符串长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxLength = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatchedPairs</span><span class="params">(<span class="keyword">char</span>* expr)</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; s(MaxLength);</span><br><span class="line">    <span class="keyword">int</span> j, length = <span class="built_in">strlen</span>(expr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length; i++)&#123;</span><br><span class="line">        <span class="comment">// 从左到右扫描字符串</span></span><br><span class="line">        <span class="keyword">if</span> (expr[i - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">            <span class="comment">// 栈中添加左括号的位置索引值</span></span><br><span class="line">            s.Add(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i - <span class="number">1</span>] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                s.Delete(j);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No match for right parenthesis"</span> &lt;&lt; <span class="string">" at "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 堆栈中剩下的( 都是未匹配的</span></span><br><span class="line">    <span class="keyword">while</span> (!s.IsEmpty())&#123;</span><br><span class="line">        s.Delete(j);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No match for left parenthesis at "</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"xcept.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"Stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMathedParis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 测试括号匹配</span></span><br><span class="line">    <span class="keyword">char</span> expr[MaxLength];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type an expression of length at most "</span> &lt;&lt; MaxLength &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">cin</span>.getline(expr, MaxLength);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The pairs of matching parentheses in "</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">puts</span>(expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"are"</span> &lt;&lt; endl;</span><br><span class="line">    PrintMatchedPairs(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    testMathedParis();</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%881.png" alt="此处输入图片的描述"></p>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><blockquote>
<p>在汉诺塔问题中，已知有n个碟子和3座塔。初始时所有的碟子按从大到小次序从塔1的底部堆放至顶部，我们需要把碟子都移动到塔2，每次移动一个碟子，而且任何时候都不能把大碟放在小碟子的上面。</p>
</blockquote>
<p>一个非常优雅的解决办法是使用<strong>递归</strong>。为了把最大的碟子移动到塔2，可以先将其余的n-1个碟子移动到塔3，然后把最大的碟子移动到塔2。接下来是把塔3上的n-1个碟子移动到塔2，因此要借用塔1和塔2，此时可以完全忽视塔2上已经有一个碟子的事实，因为这个碟子是所有碟子中最大的一个。</p>
<p>下面是按照递归方式实现的代码。初始调用的语句是<code>TowersOfHanoi(n,1,2,3)</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉诺塔问题,把n个碟子从塔x移动到塔y，可借助于塔z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TowersOfHanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, x, z, y);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move top disk from tower "</span> &lt;&lt; x &lt;&lt; <span class="string">" to top of tower "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, z, y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序所花费的时间正比于所输出的信息行数目，而信息行的数目等价于碟子移动的次数，其碟子移动次数<code>moves(n)</code>如下所示：</p>
<script type="math/tex; mode=display">
moves(n)=
\begin{cases}
0 & n=0 \\\\
2moves(n-1)+1 & n>0
\end{cases}</script><p>也就是有$moves(n)=2^n-1$,所以上述函数的时间复杂性是$\theta(2^n)$。</p>
<p>上述函数只是输出把碟子从塔1移动到塔2所需要的碟子移动次序。假定希望给出每次移动之后三座塔的状态，即塔上的碟子及其次序，那么必须在内存中保留塔的状态，并在每次移动碟子之后，修改塔的状态。</p>
<p>由于从每个塔上移走碟子时是按照LIFO的方式进行，因此可以把每个塔表示成一个堆栈。三座塔在任何时候都总共拥有n个碟子，因此，如果使用链表形式的堆栈，只需申请n个元素所需要的空间。如果使用的是基于公式化描述的堆栈，则塔1和塔2的容量都必须是n，而塔3的容量必须为n-1，因而所需要的空间总数为3n-1。</p>
<p>前面的分析指出，汉诺塔问题的复杂性是以n为指数的函数，因此在可以接受的时间范围内，只能解决n值比较小(如$n\le 30$)的汉诺塔问题。而对于这些较小的n值，基于公式化描述和基于链表描述的堆栈在空间需求上的差别相当小，因此可以随意使用。</p>
<p>下面给出基于公式化描述的堆栈。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> HANOI_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> HANOI_H_</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"Stack.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Hanoi&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">useTowersOfHanoi</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TowersOfHanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; *S[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Hanoi::TowersOfHanoi(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)&#123;</span><br><span class="line">    <span class="comment">// 把n个碟子从塔x移动到塔y，可借助于塔z</span></span><br><span class="line">    <span class="comment">// 碟子编号</span></span><br><span class="line">    <span class="keyword">int</span> d; </span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, x, z, y);</span><br><span class="line">        <span class="comment">// 从x中移动走一个碟子</span></span><br><span class="line">        S[x]-&gt;Delete(d);</span><br><span class="line">        <span class="comment">// 放到y上</span></span><br><span class="line">        S[y]-&gt;Add(d);</span><br><span class="line">        ShowState();</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, z, y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useTowersOfHanoi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预处理程序</span></span><br><span class="line">    Hanoi X;</span><br><span class="line">    X.S[<span class="number">1</span>] = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    X.S[<span class="number">2</span>] = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    X.S[<span class="number">3</span>] = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = n; d &gt; <span class="number">0</span>; d--)</span><br><span class="line">        <span class="comment">// 将碟子放到塔1上</span></span><br><span class="line">        X.S[<span class="number">1</span>]-&gt;Add(d);</span><br><span class="line"></span><br><span class="line">    X.TowersOfHanoi(n, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>上述函数没有给出<code>ShowState()</code>方法的具体实现，这是由于该函数的实现取决于输出设备的性质（如计算机屏幕、打印机等）</p>
<h3 id="火车车厢重排"><a href="#火车车厢重排" class="headerlink" title="火车车厢重排"></a>火车车厢重排</h3><blockquote>
<p>一列货运列车共有n节车厢，每节车厢将停放在不同的车站。假定 n个车站的编号分别为1~n，货运列车按照第 n站至第1站的次序经过这些车站。车厢的编号与它们的目的地相同。为了便于从列车上卸掉相应的车厢，必须重新排列车厢，使各车厢从前至后按编号 1到n的次序排列。当所有的车厢都按照这种次序排列时，在每个车站只需卸掉最后一节车厢即可。</p>
</blockquote>
<p>这里可以在一个转轨站里完成车厢的重排工作，在转轨站中有一个入轨、一个出轨和k个缓冲铁轨（位于入轨和出轨之间），如下图所示，其中有k=3个缓冲铁轨H1，H2，和H3。下图a是一个初始的袋重排的车厢次序，而图b则是按照要求的次序重排后的结果。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%882.png" alt="此处输入图片的描述"></p>
<p>为了重排车厢，需从前至后依次检查入轨上的所有车厢。如果正在检查的车厢是下一个满足排列要求的车厢，可以直接把它放在出轨上。如果不是，则把它移动到缓冲铁轨上，直到按输出次序要求轮到它时才将它放到出轨上。缓冲铁轨是按照LIFO的方式使用的，因此车厢的进和出都是在缓存铁轨的顶部进行的。在重排车厢过程中，仅允许以下移动：</p>
<ul>
<li>车厢可以从入轨的前部（即右端）移动到一个缓冲铁轨的顶部或者出轨的左端</li>
<li>车厢可以从缓冲铁轨的顶部移动到出轨的左端</li>
</ul>
<p>考虑图a的情况，由于要求的次序是递增的方式，即1号是最先出轨，然后按顺序从2到9，因此在缓冲铁轨中也应该是从顶部到底部是递增的方式，即在顶部是编号小的，所以缓冲铁轨的中间状态如下所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%883.png" alt="此处输入图片的描述"></p>
<p>接下来剩下三个车厢，输出顺序就变得明了了。在这个分配过程中，主要是遵循这样一条规则：<strong>新的车厢u应送入这样的缓冲铁轨：其顶部的车厢编号v满足$v \gt u$，且v是所有满足这种条件的缓冲铁轨顶部车厢编号中最小的一个编号。</strong></p>
<p>对于图a的例子，进行车厢重排的时候，只需要3个缓冲铁轨就足够了，但是对于其他的初始次序，可能需要更多的缓冲铁轨。</p>
<p>因此，这里使用k个链表形式的堆栈来描述k个缓冲铁轨。下列函数<strong>Railroad</strong>用于确定重排n个车厢，它最多可使用k个缓冲铁轨并假定车厢的次序为p[1:n]。如果不能成功重排，函数将返回false，否则返回true。具体实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 火车车厢重排</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Railroad</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// k个缓冲铁轨，车厢初始排序为p[1:n], 如果重排成功，返回true，否则返回false，如果内存不足，则引发异常NoMem</span></span><br><span class="line">    <span class="comment">// 创建于缓冲铁轨对应的堆栈</span></span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt; *H = <span class="keyword">new</span> LinkedStack&lt;<span class="keyword">int</span>&gt;[k+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 下一次要输出的车厢</span></span><br><span class="line">    <span class="keyword">int</span> NowOut = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 缓冲铁轨中编号最小的车厢</span></span><br><span class="line">    <span class="keyword">int</span> minH = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// minH号车厢对应的缓冲铁轨</span></span><br><span class="line">    <span class="keyword">int</span> minS;</span><br><span class="line">    <span class="comment">// 进行车厢重排</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == NowOut)&#123;</span><br><span class="line">            <span class="comment">// 直接输出</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"More car "</span> &lt;&lt; p[i] &lt;&lt; <span class="string">" from input to output"</span> &lt;&lt; endl;</span><br><span class="line">            NowOut++;</span><br><span class="line">            <span class="keyword">while</span> (minH == NowOut)&#123;</span><br><span class="line">                Output(minH, minS, H, k, n);</span><br><span class="line">                NowOut++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 将p[i]送入某个缓冲铁轨</span></span><br><span class="line">            <span class="keyword">if</span> (!Hold(p[i], minH, minS, H, k, n))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面则给出函数<strong>Railroad</strong>中使用的函数<strong>Output和Hold</strong>的代码实现，前者主要是用于将一节车厢从缓冲铁轨中输出到出轨处，同时修改minH和minS，而后者则是根据分配规则将车厢c送入某个缓冲铁轨，并在必要的时候修改minH和minS。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">int</span>&amp; minH, <span class="keyword">int</span>&amp; minS, LinkedStack&lt;<span class="keyword">int</span>&gt; H[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 把车厢从缓冲铁轨送至出轨处，同时修改minS和minH</span></span><br><span class="line">    <span class="comment">// 车厢索引</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="comment">// 从堆栈minS中删除编号最小的车厢minH</span></span><br><span class="line">    H[minS].Delete(c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"More car "</span> &lt;&lt; minH &lt;&lt; <span class="string">" from holding track "</span> &lt;&lt; minS &lt;&lt; <span class="string">" to output\n"</span>;</span><br><span class="line">    <span class="comment">// 通过检查所有的栈顶，搜索新的minH和minS</span></span><br><span class="line">    minH = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!H[i].IsEmpty() &amp;&amp; (c = H[i].Top()) &lt; minH)&#123;</span><br><span class="line">            minH = c;</span><br><span class="line">            minS = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Hold</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span>&amp; minH, <span class="keyword">int</span>&amp; minS, LinkedStack&lt;<span class="keyword">int</span>&gt; H[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在一个缓冲铁轨中放入车厢c,如果没有可用的缓冲铁轨，返回false，如果空间不足，则引发异常NoMem</span></span><br><span class="line">    <span class="comment">// 目前最优的铁轨</span></span><br><span class="line">    <span class="keyword">int</span> BestTrack = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最优铁轨上的头辆车厢号</span></span><br><span class="line">    <span class="keyword">int</span> BestTop = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 车厢索引</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="comment">// 扫描缓冲铁轨</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!H[i].IsEmpty())&#123;</span><br><span class="line">            x = H[i].Top();</span><br><span class="line">            <span class="keyword">if</span> (c &lt; x &amp;&amp; x &lt; BestTop)&#123;</span><br><span class="line">                BestTop = c;</span><br><span class="line">                BestTrack = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 铁轨是空</span></span><br><span class="line">            <span class="keyword">if</span> (!BestTrack)</span><br><span class="line">                BestTrack = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!BestTrack)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 把车厢c送入缓冲铁轨</span></span><br><span class="line">    H[BestTrack].Add(c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"More car "</span> &lt;&lt; c &lt;&lt; <span class="string">" from input to holding track "</span> &lt;&lt; BestTrack &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 必要时修改minH和minS</span></span><br><span class="line">    <span class="keyword">if</span> (c &lt; minH)&#123;</span><br><span class="line">        minH = c;</span><br><span class="line">        minS = BestTrack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个函数Output和Hold的时间复杂性都是$\theta(k)$。而在函数Railroad中的while循环最多可以输出n-1节车厢，else语句也是最多有n-1节车厢被送入缓冲铁轨，因此，这两个函数所消耗的总时间是$O(kn)$。而Railroad函数中for循环部分的其余部分耗时$\theta(n)$,因此该函数的时间复杂性是$O(kn)$。</p>
<p>这里如果使用一个平衡折半搜索树来存储缓冲铁轨顶部的车厢编号（在第11章介绍），程序的复杂性可由将至$O(nlogk)$。</p>
<p>更详细的内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Stack/StackExamples.md" target="_blank" rel="external">我的Github</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本小节主要是介绍堆栈的三个应用，分别是括号的匹配，汉诺塔以及火车车厢重排问题，都是利用堆栈的LIFO性质。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，继续第五章堆栈的内容，这节是最后关于应用方面的内容。这节会介绍括号的匹配，汉诺塔，火车车厢重排三个问题。</p>
<h3 id="括号的匹配"><a href="#括号的匹配" class="headerlink" tit]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆栈1--基本概念及实现方法]]></title>
    <link href="http://ccc013.github.io/2016/07/12/%E5%A0%86%E6%A0%881-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://ccc013.github.io/2016/07/12/堆栈1-基本概念及实现方法/</id>
    <published>2016-07-12T07:22:48.000Z</published>
    <updated>2016-10-21T13:04:56.885Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这次是新的一章内容，第五章堆栈。</p>
<blockquote>
<p>堆栈数据结构是通过对线性表的插入和删除操作进行限制而得到的，即插入和删除操作都必须在表的同一端完成，因此堆栈是一个<strong>后进先出(last-in-first-out,LIFO)</strong>的数据结构。</p>
</blockquote>
<p>由于堆栈是一种特殊的线性表，所以可以很自然地从相应的线性表类中派生出堆栈类，既可以从基于公式描述的类<strong>LinearList</strong>类派生，也可以从基于链表结构的类<strong>Chain</strong>派生出堆栈类。</p>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>  这里给出堆栈的抽象数据类型描述<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型Stack&#123;</span><br><span class="line">实例</span><br><span class="line">    元素线性表，栈底，栈顶</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空的堆栈</span><br><span class="line">    IsEmpty(): 如果堆栈为空，则返回true，否则返回false</span><br><span class="line">    IsFull(): 如果堆栈满，则返回true，否则返回false</span><br><span class="line">    Top(): 返回栈顶元素</span><br><span class="line">    Add(x): 向堆栈中添加元素x</span><br><span class="line">    Delete(x): 删除栈顶元素，并将它传递给x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="派生类和继承"><a href="#派生类和继承" class="headerlink" title="派生类和继承"></a>派生类和继承</h3><p>  若类B是类A的限制版本，那么可以从类A派生出类B。<strong>我们称类A是基类，类B是派生类。</strong>从类A派生出的类B继承了基类A的所有成员——共享成员、保护成员和私有成员。类型为B的每个对象都与A所有的数据成员和函数相关联。<strong>类B可以采用如下三种基本方式之一来继承类A的成员————共享成员、保护成员和私有成员。</strong>比如，对于共享成员方式，可以采用如下语法形式：<code>class B:public A</code></p>
<p>  <strong>一个类可以从多个类派生而来</strong>。比如，类B从A和C派生而来，并且以共享成员方式继承A的属性，以私有成员方法继承C的属性，相应的语法形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B:<span class="keyword">public</span> A, <span class="keyword">private</span> C</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在所有继承方式中，基类A的私有成员仍是A的私有成员，类B的成员不能够访问它们。不同的继承方式仅影响对基类的保护成员和共享成员的访问。</p>
<p>当B按照共享成员方式从A派生出来，A的保护成员成为B的保护成员，A的共享成员成为B的共享成员。</p>
<p>如果继承方式是保护成员，那么A的共享成员和保护成员均成为B的保护成员。</p>
<p>如果继承方式是私有成员，那么A的共享成员和保护成员均成为B的私有成员。</p>
</blockquote>
<h3 id="公式化描述"><a href="#公式化描述" class="headerlink" title="公式化描述"></a>公式化描述</h3><p>  由于堆栈是一个受限的线性表，因此可以参考<a href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据描述1-线性表</a>中的公式化描述，令栈顶元素存储在<code>element[length-1]</code>，栈底元素存储在<code>element[0]</code>中。下列程序定义的Stack类将使用私有成员方法继承<a href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据描述1-线性表</a>中定义的类LinearList。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> INHERITSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> INHERITSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Stack : <span class="keyword">private</span> LinearList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> MaxStackSize = <span class="number">10</span>) : LinearList&lt;T&gt;(MaxStackSize)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LinearList&lt;T&gt;::isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Length() == GetMaxSize());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">Top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Stack&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    Stack&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::Top() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    T x;</span><br><span class="line">    Find(Length(), x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    Insert(Length(), x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    LinearList&lt;T&gt;::Delete(Length(), x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::Output(<span class="built_in">std</span>::ostream&amp; out)<span class="keyword">const</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        out &lt;&lt; element[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    out &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;out, <span class="keyword">const</span> Stack&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里，Stack的构造函数简单调用线性表的构造函数，提供的参数为堆栈的大小<strong>MaxStackSize</strong>。这里使用操作符<strong>::</strong>来区分基类和派生类的同名成员。</p>
<p>在实现函数<strong>IsFull</strong>时，由于Stack的成员不能直接访问基类的私有成员，因此可以在基类LinearList中增加一个保护成员的函数<strong>GetMaxSize</strong>，其实现如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMaxSize</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MaxSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Stack的效率"><a href="#Stack的效率" class="headerlink" title="Stack的效率"></a>Stack的效率</h4><p>  当T是一个内部数据类型时，堆栈的构造函数和析构函数的复杂性均为$\theta(1)$,当T时用户自定义的类时，构造函数和析构函数的复杂性均为$O(MaxStackSize)$。其余每个堆栈操作的复杂性均为$\theta(1)$。</p>
<p>  这里通过从<code>LinearList</code>派生<code>Stack</code>，一方面大大减少了编码量，另一方面也使得程序的可靠性得到很大提高，因为<code>LinearList</code>经过测试被认为是正确的。</p>
<p>  当然，继承有利的一方面，也有弊端。代码编写的简化带来了运行效率的损失。比如，为了向堆栈中添加一个元素，首先要确定堆栈的长度<code>Length()</code>，然后调用函数<code>Insert()</code>。<code>Insert()</code>函数首先会判断插入操作是否会越界，然后需要付出一个for循环的开销来执行0个元素的移动。为了消除额外的开销，可以把<code>Stack</code>定义为一个基类，而不是一个派生类。</p>
<p>  另一个潜在问题是派生类<code>Stack</code>也会受到<code>LinearList</code>本身所受限制的影响。比如，必须为数据类型为T的成员定义操作符&lt;&lt;和==，因为前者用于对线性表操作&lt;&lt;的重载，后者用于对<code>LinearList::Search</code>的重载。</p>
<h4 id="自定义Stack"><a href="#自定义Stack" class="headerlink" title="自定义Stack"></a>自定义Stack</h4><p>  下面是自定义Stack的类定义实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Stack&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 栈顶</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="comment">// 最大的栈顶值</span></span><br><span class="line">    <span class="keyword">int</span> MaxTop;</span><br><span class="line">    <span class="comment">// 堆栈元素数组</span></span><br><span class="line">    T* <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> MaxStackSize = <span class="number">10</span>);</span><br><span class="line">    ~Stack()&#123; <span class="keyword">delete</span>[] <span class="built_in">stack</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> top == -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == MaxTop; &#125;</span><br><span class="line">    <span class="function">T <span class="title">Top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Stack&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    Stack&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Stack&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面是类成员函数的定义实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack(<span class="keyword">int</span> MaxStackSize)&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    MaxTop = MaxStackSize - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">stack</span> = <span class="keyword">new</span> T[MaxStackSize];</span><br><span class="line">    top = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::Top()<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull())</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="built_in">stack</span>[++top] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除栈顶元素，并将其传送入x</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    x = <span class="built_in">stack</span>[top--];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Stack&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = x.top;</span><br><span class="line">    <span class="keyword">if</span> (x.IsEmpty())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no elements in stack"</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x.<span class="built_in">stack</span>[pos] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        pos--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过测试，自定义Stack在添加和删除操作要比通过继承而得到的类Stack的相应操作要更快。</p>
<h3 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h3><p>  上一节给出用数组实现堆栈的方法即优雅又高效，但是若同时使用多个堆栈，这种方法将浪费大量的空间。</p>
<p>  这里可以使用链表描述，下面给出自定义链表类<code>LinkedStack</code>的类定义声明。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Node&#123;</span><br><span class="line">    <span class="keyword">friend</span> LinkedStack&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt;* link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedStack&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedStack()&#123; top = <span class="number">0</span>; &#125;</span><br><span class="line">    ~LinkedStack();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> top == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Top</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">    LinkedStack&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    LinkedStack&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>其类成员函数实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedStack&lt;T&gt;::~LinkedStack()&#123;</span><br><span class="line">    Node&lt;T&gt;* next;</span><br><span class="line">    <span class="keyword">while</span> (top)&#123;</span><br><span class="line">        next = top-&gt;link;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkedStack&lt;T&gt;::IsFull()<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Node&lt;T&gt;* p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoMem)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T LinkedStack&lt;T&gt;::Top()<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedStack&lt;T&gt;&amp; LinkedStack&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 添加元素x</span></span><br><span class="line">    Node&lt;T&gt;* p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;link = top;</span><br><span class="line">    top = p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedStack&lt;T&gt;&amp; LinkedStack&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除元素，并传给x返回</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    x = top-&gt;data;</span><br><span class="line">    Node&lt;T&gt;* p = top;</span><br><span class="line">    top = top-&gt;link;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedStack&lt;T&gt;::Output(ostream&amp; out)&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        out &lt;&lt; <span class="string">"There is no elements in LinkedStack"</span>;</span><br><span class="line">    Node&lt;T&gt;* p = top;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        out &lt;&lt; p-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,LinkedStack&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里仅给出自定义链栈<code>LinkedStack</code>，同样可以通过继承线性表的链表实现类来派生出链栈，但是<code>LinkedStack</code>在添加和删除操作上的效率要更加高点。</p>
<p>代码实现可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/Stack" target="_blank" rel="external">Github</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本小节主要是介绍了堆栈的基本实现方法，分为数组实现和链表实现，实现的代码也是比较简单的。下面一节会介绍堆栈的一些应用，包括括号匹配，汉诺塔等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这次是新的一章内容，第五章堆栈。</p>
<blockquote>
<p>堆栈数据结构是通过对线性表的插入和删除操作进行限制而得到的，即插入和删除操作都必须在表的同一端完成，因此堆栈是一个<strong>后进先出(last]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵4-稀疏矩阵]]></title>
    <link href="http://ccc013.github.io/2016/07/07/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B54-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/07/07/数组和矩阵4-稀疏矩阵/</id>
    <published>2016-07-07T07:57:30.000Z</published>
    <updated>2016-10-24T12:08:02.522Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍稀疏矩阵的内容。这也是本章节最后一节内容。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>如果一个$m\times n$矩阵中有”许多”元素为0，则称该矩阵为<strong>稀疏矩阵(sparse)</strong></p>
</blockquote>
<p>对应的非稀疏的矩阵称为<strong>稠密矩阵(dense)</strong>。而实际上，稀疏矩阵和稠密矩阵之间并没有一个精确的界限。</p>
<p>$n\times n$的对角矩阵和三对角矩阵都是稀疏矩阵，二者都有$O(n)$个非0元素和$O(n^2)$个0元素。而对于一个$n\times n$的三角矩阵，它至少有$\frac{n(n-1)}{2}$个0元素，最多有$\frac{n(n+1)}{2}$个非0元素。在本节中，我们规定一个矩阵是稀疏矩阵，则其非0元素的数目应小于$n^2/3$,有些情况下应小于$n^2/5$,因此可以将三角矩阵视为稠密矩阵。</p>
<p>诸如对角矩阵和三对角矩阵这样的稀疏矩阵，其非0区域的结构很有规律，因此可以设计一个很简单的存储结构，该存储结构的大小就等于矩阵非0区域的大小，本小节主要考察具有不规则非0区域的稀疏矩阵。</p>
<h3 id="数组描述"><a href="#数组描述" class="headerlink" title="数组描述"></a>数组描述</h3><p>  对于下图a中的$4\times 8$矩阵可以按行主次序把非0元素映射到一维数组中，可到到:2,1,6,7,3,9,8,4,5。</p>
<p>  为了重建矩阵结构，必须记录每个非0元素所在的行号和列号，所以在把稀疏矩阵的非0元素映射到数组中时必须提供三个域:<strong>row(矩阵元素所在的行号)、col(矩阵元素所在列号)和value(矩阵元素的值)</strong>。为此定义了下列所示的模板类<strong>Term</strong>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Term&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果a是一个类型为Term的数组，那么下图a中的稀疏矩阵按行主次序存储到a中所得的结果就如图b所示。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B51.png" alt="此处输入图片的描述"></p>
<p>  除了存储数组a以外，还必须存储矩阵行数、矩阵列数和非0项的数目。所以存储上图a中的九个非0元素所需要的存储器字节数是<strong>21<em>sizeof(int)+9</em>sizeof(T)</strong>,这里每个非0元素都有两个int类型的行号和列号，然后加上总的矩阵行数，列数以及非0数目。</p>
<h4 id="类SparseMatrix"><a href="#类SparseMatrix" class="headerlink" title="类SparseMatrix"></a>类SparseMatrix</h4><p>  可以定义一个类SparseMatrix，如下所示，用来把稀疏矩阵按行主次序映射到一维数组中。在定义共享成员时，没有定义加法操作符+，因为它会创建一个临时结果，这个临时结果必须复制到所返回的环境才可以使用。由于SparseMatrix的复制构造函数将会复制每一个元素，因此操作符+中的复制代价太大，这里使用Add函数来避免这种情况的发生。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> SparseMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Append</span><span class="params">(<span class="keyword">const</span> Term&lt;T&gt;&amp; t)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="comment">// 非0元素的数目</span></span><br><span class="line">    <span class="keyword">int</span> terms;</span><br><span class="line">    <span class="comment">// 存储非0元素的数组</span></span><br><span class="line">    Term&lt;T&gt; *a;</span><br><span class="line">    <span class="comment">// 数组a的大小</span></span><br><span class="line">    <span class="keyword">int</span> MaxTerms;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SparseMatrix(<span class="keyword">int</span> maxTerms = <span class="number">0</span>);</span><br><span class="line">    ~SparseMatrix()&#123; <span class="keyword">delete</span>[] a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Transpose</span><span class="params">(SparseMatrix&lt;T&gt;&amp; b)</span>  <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> SparseMatrix&lt;T&gt; &amp;b, SparseMatrix&lt;T&gt;&amp;c)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> SparseMatrix&lt;T&gt;&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, SparseMatrix&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出构造函数，以及输入操作符和输出操作符，两者的时间复杂性都是$\theta(terms)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">SparseMatrix&lt;T&gt;::SparseMatrix(<span class="keyword">int</span> maxTerms)&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxTerms &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    MaxTerms = maxTerms;</span><br><span class="line">    a = <span class="keyword">new</span> Term&lt;T&gt;[maxTerms];</span><br><span class="line">    terms = rows = cols = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> SparseMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 输出矩阵的特征</span></span><br><span class="line">    out &lt;&lt; <span class="string">"rows = "</span> &lt;&lt; x.rows &lt;&lt; <span class="string">" columns = "</span> &lt;&lt; x.rows &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    out &lt;&lt; <span class="string">"nonzeros terms = "</span> &lt;&lt; x.terms &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="comment">// 输出非0元素，每行1个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.terms; i++)</span><br><span class="line">        out &lt;&lt; <span class="string">"a("</span> &lt;&lt; x.a[i].row &lt;&lt; <span class="string">", "</span> &lt;&lt; x.a[i].col &lt;&lt; <span class="string">") = "</span> &lt;&lt; x.a[i].value &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&gt;&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; in, SparseMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 输入矩阵的特征</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter number of rows, columns, and terms\n"</span>;</span><br><span class="line">    in &gt;&gt; x.rows &gt;&gt; x.cols &gt;&gt; x.terms;</span><br><span class="line">    <span class="keyword">if</span> (x.terms &gt; x.MaxTerms)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="comment">// 输入矩阵元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.terms; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter row, column, and value of term "</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        in &gt;&gt; x.a[i].row &gt;&gt; x.a[i].col &gt;&gt; x.a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在重载输入操作符&gt;&gt;的时候，如果输入的元素数目大于数组a的大小，则会引发一个异常。一种处理异常的方法是删除数组a，然后使用new重新分配一个更大的数组。</p>
<h4 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h4><p>  下面程序给出函数<strong>Tranpose</strong>的代码实现。转置后的矩阵被返回到b中。<br>  首先验证b中是否有足够的空间来存储被转置矩阵的非0元素。如果空间不足，要么重新分配一个更大的数组<strong>b.a</strong>,要么引发一个异常。在下面的程序中是选择引发异常。如果b中有足够的空间来容纳转置矩阵，则创建两个数组<strong>ColSize</strong>和<strong>RowNext</strong>。其中<code>ColSize[i]</code>是指矩阵第i列中的非0元素的数目，而<code>RowNext[i]</code>则是代表转置矩阵第i行的下一个非0元素在b中的位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SparseMatrix&lt;T&gt;::Transpose(SparseMatrix&lt;T&gt;&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 把*this的转置结果送入b中</span></span><br><span class="line">    <span class="comment">// 验证b有足够空间</span></span><br><span class="line">    <span class="keyword">if</span> (terms &gt; b.MaxTerms)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="comment">// 设置转置特征</span></span><br><span class="line">    b.cols = rows;</span><br><span class="line">    b.rows = cols;</span><br><span class="line">    b.terms = terms;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> *ColSize, *RowNext;</span><br><span class="line">    ColSize = <span class="keyword">new</span> <span class="keyword">int</span>[cols + <span class="number">1</span>];</span><br><span class="line">    RowNext = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cols; i++)</span><br><span class="line">        ColSize[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算*this每一列的非0元素数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; terms; i++)</span><br><span class="line">        ColSize[a[i].col]++;</span><br><span class="line">    <span class="comment">// 给出b中每一行的起始点</span></span><br><span class="line">    RowNext[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cols; i++)</span><br><span class="line">        RowNext[i] = RowNext[i - <span class="number">1</span>] + ColSize[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行转置操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; terms; i++)&#123;</span><br><span class="line">        <span class="comment">// 在b中的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = RowNext[a[i].col]++;</span><br><span class="line">        b.a[j].row = a[i].col;</span><br><span class="line">        b.a[j].col = a[i].row;</span><br><span class="line">        b.a[j].value = a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数Tranpose的时间复杂性是$O(cols+terms)$</p>
<h4 id="矩阵相加"><a href="#矩阵相加" class="headerlink" title="矩阵相加"></a>矩阵相加</h4><p>  在两个矩阵相加中使用了函数<code>Append</code>，它把一个非0项添加到一个稀疏矩阵的非0项数组的尾部，其时间复杂性是$\theta(1)$。实现代码如下，然后就是两个矩阵相加的实现函数Add，使用两个游标，分别是*this和矩阵b的游标，通过一个while循环来实现相加。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SparseMatrix&lt;T&gt;::Append(<span class="keyword">const</span> Term&lt;T&gt;&amp; t)&#123;</span><br><span class="line">    <span class="comment">// 把一个非0元素t添加到 *this之中</span></span><br><span class="line">    <span class="keyword">if</span> (terms &gt;= MaxTerms)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    a[terms] = t;</span><br><span class="line">    terms++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SparseMatrix&lt;T&gt;::Add(<span class="keyword">const</span> SparseMatrix&lt;T&gt;&amp; b, SparseMatrix&lt;T&gt;&amp; c)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 计算 c = (*this) + b</span></span><br><span class="line">    <span class="comment">// 验证可行性</span></span><br><span class="line">    <span class="keyword">if</span> (rows != b.rows || cols != b.cols)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    <span class="comment">// 设置结果矩阵c的特征</span></span><br><span class="line">    c.rows = rows;</span><br><span class="line">    c.cols = cols;</span><br><span class="line">    c.terms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义*this 和b 的游标</span></span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>, cb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ct &lt; terms &amp;&amp; cb &lt; b.terms)&#123;</span><br><span class="line">        <span class="comment">// 每一个元素的行主索引</span></span><br><span class="line">        <span class="keyword">int</span> indt = a[ct].row * cols + a[ct].col;</span><br><span class="line">        <span class="keyword">int</span> indb = b.a[cb].row * cols + b.a[cb].col;</span><br><span class="line">        <span class="keyword">if</span> (indt &lt; indb)&#123;</span><br><span class="line">            <span class="comment">// b的元素在后面</span></span><br><span class="line">            c.Append(a[ct]);</span><br><span class="line">            ct++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (indt == indb)&#123;</span><br><span class="line">                <span class="comment">// 位置相同</span></span><br><span class="line">                <span class="keyword">if</span> (a[ct].value + b.a[cb].value)&#123;</span><br><span class="line">                    <span class="comment">// 仅当和不为0时，才添加到c中</span></span><br><span class="line">                    Term&lt;T&gt; t;</span><br><span class="line">                    t.row = a[ct].row;</span><br><span class="line">                    t.col = a[ct].col;</span><br><span class="line">                    t.value = a[ct].value + b.a[cb].value;</span><br><span class="line">                    c.Append(t);</span><br><span class="line">                &#125;</span><br><span class="line">                ct++;</span><br><span class="line">                cb++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// b的元素在前面</span></span><br><span class="line">                c.Append(b.a[cb]);</span><br><span class="line">                cb++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制剩余元素</span></span><br><span class="line">    <span class="keyword">for</span> (; ct &lt; terms; ct++)</span><br><span class="line">        c.Append(a[ct]);</span><br><span class="line">    <span class="keyword">for</span> (; cb &lt; b.terms; cb++)</span><br><span class="line">        c.Append(b.a[cb]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数Add的时间复杂性是$O(terms+b.terms)$。而如果用二维数组来描述每个矩阵，则两个矩阵相加耗时$O(rows<em>cols)$，当<strong>terms+b.terms</strong>远小于**rows</em>cols**时，稀疏矩阵的加法执行效率将大大提高。</p>
<h3 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h3><p>  用一维数组来描述稀疏矩阵所存在的缺点是：<strong>当我们创建这个一维数组时，必须知道稀疏矩阵中的非0元素总数。</strong><br>  在我们自定义的类SparseMatrix中，当实际非0元素数目多于估计的初始化一维数组时设定的非0元素数目时，会引发一个异常。还有一种做法是可以分配一个更大的、新的数组，然后复制元素，并删除老的数组，但是这种做法会使得算法效率降低，并且也同样需要估计新数组需要多大的问题。</p>
<p>  因此，这里就如同线性表一样，除了使用数组描述，还有基于指针的描述，也就是<strong>链表描述</strong>。</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><blockquote>
<p>链表描述的一种可行方案是把每行的非0元素串接在一起，构成一个链表，如下图所示。</p>
</blockquote>
<p>图中每个非阴影节点代表稀疏矩阵中的一个非0元素，它有三个域：col(非0元素所在列号)、value(非0元素的值)和link(指向下一个非阴影节点的指针)。仅当矩阵某行中至少包含一个非0元素才会为该行创建一个链表。在行链表中，每个节点按其col值得升序进行排序。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B52.png" alt="此处输入图片的描述"></p>
<p>  然后再用一个链表将所有的行链表，即图中阴影链表收集在一起。各个阴影节点按其row值得升序排列，每个阴影节点可以被视为一个行链表的头节点，因此阴影链表可以被视为头节点链表。</p>
<h4 id="链表节点类型"><a href="#链表节点类型" class="headerlink" title="链表节点类型"></a>链表节点类型</h4><p>  这里分别定义图中非阴影节点<strong>CNode</strong>和阴影节点<strong>HeadNode</strong>，其代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> LINKMATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LINKMATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"ChainList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> CNode&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> CNode&lt;T&gt;&amp; y)&#123;</span><br><span class="line">        <span class="keyword">return</span> (value != y.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"column = "</span> &lt;&lt; col &lt;&lt; <span class="string">", value= "</span> &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> CNode&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    out &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> HeadNode&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="comment">// 行链表</span></span><br><span class="line">    Chain&lt;CNode&lt;T&gt;&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> HeadNode&lt;T&gt;&amp; y)&#123;</span><br><span class="line">        <span class="keyword">return</span> (row != y.row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"row = "</span> &lt;&lt; row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> HeadNode&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    out &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="类LinkMatrix"><a href="#类LinkMatrix" class="headerlink" title="类LinkMatrix"></a>类LinkMatrix</h4><p>  接下来就是定义类LinkMatrix，如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="comment">// 头节点链表</span></span><br><span class="line">    Chain&lt;HeadNode&lt;T&gt;&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkMatrix()&#123;&#125;</span><br><span class="line">    ~LinkMatrix()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Transpose</span><span class="params">(LinkMatrix&lt;T&gt;&amp; b)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp; b, LinkMatrix&lt;T&gt;&amp; c)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp;);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="重载-gt-gt"><a href="#重载-gt-gt" class="headerlink" title="重载&gt;&gt;"></a>重载&gt;&gt;</h4><p>  重载输入操作符&gt;&gt;。首先是要求输入矩阵的维数以及非0元素的个数。然后输入各个非0元素并把它们收集到各行链表中。用变量H代表当前行链表的头节点，如果下一个非0元素不属于当前行链表，则将当前行链表添加到矩阵x的头节点x.a之中；接下来，H被设置为指向一个新的行链表，同时将刚才那个非0元素添加到这个新的行链表之中。如果新的非0元素属于当前行链表，则只需要简单地把它添加到链表H.a中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; in, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 从输入流中输入矩阵x</span></span><br><span class="line">    <span class="comment">// 删除x中所有节点</span></span><br><span class="line">    x.a.Erase();</span><br><span class="line">    <span class="comment">// 获取矩阵特征</span></span><br><span class="line">    <span class="keyword">int</span> terms;  <span class="comment">// 输入的元素数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter numbers of rows, columns, and terms\n"</span>;</span><br><span class="line">    in &gt;&gt; x.rows &gt;&gt; x.cols &gt;&gt; terms;</span><br><span class="line">    <span class="comment">// 虚设第0行</span></span><br><span class="line">    HeadNode&lt;T&gt; H;  <span class="comment">// 当前行的头节点</span></span><br><span class="line">    H.row = <span class="number">0</span>;              <span class="comment">// 当前行号</span></span><br><span class="line">    <span class="comment">// 输入x的非0元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= terms; i++)&#123;</span><br><span class="line">        <span class="comment">// 输入下一个元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter row, column, and value of term "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">int</span> row, col;</span><br><span class="line">        T value;</span><br><span class="line">        in &gt;&gt; row &gt;&gt; col &gt;&gt; value;</span><br><span class="line">        <span class="comment">// 检查新元素是否属于当前行</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt; H.row)&#123;</span><br><span class="line">            <span class="comment">// 如果不是第0行，则把当前行的头节点H 添加到头节点链表x.a之中</span></span><br><span class="line">            <span class="keyword">if</span> (H.row)</span><br><span class="line">                x.a.Append(H);</span><br><span class="line">            <span class="comment">// 为新的一行准备H</span></span><br><span class="line">            H.row = row;</span><br><span class="line">            <span class="comment">// 置链表头指针first=0</span></span><br><span class="line">            H.a.Zero(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加新元素</span></span><br><span class="line">        CNode&lt;T&gt; *c = <span class="keyword">new</span> CNode&lt;T&gt;;</span><br><span class="line">        c-&gt;col = col;</span><br><span class="line">        c-&gt;value = value;</span><br><span class="line">        H.a.Append(*c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意矩阵的最后一行</span></span><br><span class="line">    <span class="keyword">if</span> (H.row)</span><br><span class="line">        x.a.Append(H);</span><br><span class="line">    H.a.Zero();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="重载-lt-lt"><a href="#重载-lt-lt" class="headerlink" title="重载&lt;&lt;"></a>重载&lt;&lt;</h4><p>  这里为了输出链表表示的稀疏矩阵，使用了一个链表遍历器依次检查头节点链表中的每个节点。代码的时间复杂性与非0元素的数目呈正比。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 把矩阵x送至输出流</span></span><br><span class="line">    ChainIterator&lt;HeadNode&lt;T&gt;&gt; p;   <span class="comment">// 头节点遍历器</span></span><br><span class="line">    <span class="comment">// 输出矩阵的维数</span></span><br><span class="line">    out &lt;&lt; <span class="string">"rows = "</span> &lt;&lt; x.rows &lt;&lt; <span class="string">",columns = "</span> &lt;&lt; x.cols &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="comment">// 将h指向第一个头节点</span></span><br><span class="line">    HeadNode&lt;T&gt; *h = p.Initialize(x.a);</span><br><span class="line">    <span class="keyword">if</span> (!h)&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"No non-zero terms\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次输出一行</span></span><br><span class="line">    <span class="keyword">while</span> (h)&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"row = "</span> &lt;&lt; h-&gt;row &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        out &lt;&lt; h-&gt;a &lt;&lt; <span class="string">"\n"</span>;        <span class="comment">// 输出行链表；</span></span><br><span class="line">        <span class="comment">// 下一个头节点</span></span><br><span class="line">        h = p.Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数Tranpose"><a href="#函数Tranpose" class="headerlink" title="函数Tranpose"></a>函数Tranpose</h4><p>  对于转置操作，可以采用箱子来从矩阵<em>this中收集位于同一行的非0元素。<em>*bin[i]</em></em>是结果矩阵b中第i行非0元素所对应的链表。其实现如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkMatrix&lt;T&gt;::Transpose(LinkMatrix&lt;T&gt;&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 转置 *this，并把结果放入b</span></span><br><span class="line">    b.a.Erase();</span><br><span class="line">    <span class="comment">// 创建用来收集b中各行元素的箱子</span></span><br><span class="line">    Chain&lt;CNode&lt;T&gt;&gt; *bin;</span><br><span class="line">    bin = <span class="keyword">new</span> Chain&lt;CNode&lt;T&gt;&gt;[cols + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 头节点遍历器</span></span><br><span class="line">    ChainIterator&lt;HeadNode&lt;T&gt;&gt; p;</span><br><span class="line">    <span class="comment">// h 指向*this的第一个头节点</span></span><br><span class="line">    HeadNode&lt;T&gt; *h = p.Initialize(a);</span><br><span class="line">    <span class="comment">// 把*this的元素复制到箱子中</span></span><br><span class="line">    <span class="keyword">while</span> (h)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = h-&gt;row;</span><br><span class="line">        <span class="comment">// 行链表遍历器</span></span><br><span class="line">        ChainIterator&lt;CNode&lt;T&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 将z指向行链表的第一个节点</span></span><br><span class="line">        CNode&lt;T&gt; *z = q.Initialize(h-&gt;a);</span><br><span class="line">        <span class="comment">// 临时节点</span></span><br><span class="line">        CNode&lt;T&gt; x;</span><br><span class="line">        <span class="comment">// *this第r行中的元素变成b中第r列的元素</span></span><br><span class="line">        x.col = r;</span><br><span class="line">        <span class="comment">// 检查*this第r行的所有非0元素</span></span><br><span class="line">        <span class="keyword">while</span> (z)&#123;</span><br><span class="line">            x.value = z-&gt;value;</span><br><span class="line">            bin[z-&gt;col].Append(x);</span><br><span class="line">            z = q.Next();</span><br><span class="line">        &#125;</span><br><span class="line">        h = p.Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置b的维数</span></span><br><span class="line">    b.rows = cols;</span><br><span class="line">    b.cols = rows;</span><br><span class="line">    <span class="comment">// 装配b的头节点链表</span></span><br><span class="line">    HeadNode&lt;T&gt; H;</span><br><span class="line">    <span class="comment">// 搜索箱子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cols; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!bin[i].isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 转置矩阵的第i行</span></span><br><span class="line">            H.row = i;</span><br><span class="line">            H.a = bin[i];</span><br><span class="line">            b.a.Append(H);</span><br><span class="line">            bin[i].Zero();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H.a.Zero();</span><br><span class="line">    <span class="keyword">delete</span>[] bin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中while循环所需要的时间与非0元素的数目呈线性关系，for循环所需要的时间则与输入矩阵的列数呈线性关系，因此总的时间与这两个量的和呈线性关系。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  到这里，第四章数组和矩阵的内容就结束了。本小节主要介绍稀疏矩阵的内容，暂时来说，对于数组描述的掌握是要更好于链表描述的，还需要好好琢磨琢磨，研究一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍稀疏矩阵的内容。这也是本章节最后一节内容。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念<]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵3-特殊矩阵]]></title>
    <link href="http://ccc013.github.io/2016/07/05/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B53-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/07/05/数组和矩阵3-特殊矩阵/</id>
    <published>2016-07-05T12:06:20.000Z</published>
    <updated>2016-10-24T12:06:38.423Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍几种特殊矩阵的内容。</p>
<h3 id="定义和应用"><a href="#定义和应用" class="headerlink" title="定义和应用"></a>定义和应用</h3><blockquote>
<p>方阵是指具有相同行数和列数的矩阵。</p>
</blockquote>
<p>一些常用的特殊方阵如下：</p>
<blockquote>
<ul>
<li><strong>对角矩阵</strong> $M$是一个对角矩阵，当前仅当$i \neq j$时，有$M(i,j)=0$。如下图a所示</li>
<li><strong>三对角矩阵</strong> $M$是一个三对角矩阵，当前仅当$|i-j| \gt 1$时有$M(i,j)=0$。如下图b所示</li>
<li><strong>下三角矩阵</strong> $M$是一个下三角矩阵，当前仅当$i\lt j$时有$M(i,j)=0$。如下图c所示</li>
<li><strong>上三角矩阵</strong> $M$是一个上三角矩阵，当前仅当$i\gt j$时有$M(i,j)=0$。如下图d所示</li>
<li><strong>对称矩阵</strong> $M$是一个对称矩阵，当前仅当对于所有的$i 和 j$有$M(i,j)=M(j,i)$。如下图e所示</li>
</ul>
</blockquote>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%9F%A9%E9%98%B52.png" alt="此处输入图片的描述"></p>
<h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>  可以采用<code>T d[n][n]</code>这样的二维数组来描述一个元素类型为T的$n \times n$对角矩阵D。<br>  使用数组元素<code>d[i-1][j-1]</code>来表示矩阵元素<strong>D(i,j)</strong>，这种描述形式所需要的存储空间为$n^2 * sizeof(T)$。</p>
<p>  由于一个对角矩阵最大包含n个非0元素，所以可以采用<code>T d[n]</code>一维数组来描述对角矩阵。其中使用<code>d[i-1]</code>表示矩阵元素<strong>D(i,i)</strong>，而根据对角矩阵的定义，所有未在一维数组中出现的矩阵元素均为0.</p>
<p>  这里使用如下自定义类<strong>DiagonalMatrix</strong>来实现这种描述。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> DIAGONALMATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DIAGONALMATRIX_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> DiagonalMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 矩阵维数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 存储对角元素的一维数组</span></span><br><span class="line">    T *d;       </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiagonalMatrix(<span class="keyword">int</span> size = <span class="number">10</span>): n(size)&#123;</span><br><span class="line">        d = <span class="keyword">new</span> T[n];</span><br><span class="line">    &#125;</span><br><span class="line">    ~DiagonalMatrix()&#123; <span class="keyword">delete</span>[] d; &#125;</span><br><span class="line">    DiagonalMatrix&lt;T&gt;&amp; Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="function">T <span class="title">Retrieve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">DiagonalMatrix&lt;T&gt;&amp; DiagonalMatrix&lt;T&gt;::Store(<span class="keyword">const</span> T&amp;x, <span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">    <span class="comment">// 将x存为D(i,j)</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">if</span> (i != j &amp;&amp; x != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 必须满足对角矩阵的条件：i != j 时，x必须为0</span></span><br><span class="line">        <span class="keyword">throw</span> MustBeZero();</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        d[i - <span class="number">1</span>] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T DiagonalMatrix&lt;T&gt;::Retrieve(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        <span class="keyword">return</span> d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>对于存储和搜索操作，提供了两个不同的函数，而不是使用重载操作符()来完成。此外在存储一个值时，必须保证不会在非对角线位置放置一个非0值；而搜索一个值时，没有必要检查对角线以外的值，因此有必要对这两种情形区别对待。两个函数的复杂性均为$\theta(1)$。</p>
<h3 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h3><p>  在一个$n \times n$三对角矩阵T中，非0元素排列在如下的三条对角线上：</p>
<ol>
<li>主对角线——<strong>i=j</strong></li>
<li>主对角线之下的对角线(称低对角线)——<strong>i=j+1</strong></li>
<li>主对角线之上的对角线(称高对角线)——<strong>i=j-1</strong></li>
</ol>
<p>这三条对角线上的元素总数为<strong>3n-2</strong>，故可以使用一个拥有3n-2个位置的一维数组来描述T。考察上述图b中所示的$4\times 4$三对角矩阵，三条对角线上总共10个元素。如果将其逐行映射到一维数组t中，则有<code>t[0:9]=[2,1,3,1,3,5,2,7,9,0]</code>;如果逐列映射到t中，则有<code>t=[2,3,1,1,5,3,2,9,7,0]</code>;如果按照对角线的次序，从最下面的对角线开始进行映射，则有<code>t=[3,5,9,2,1,2,0,1,3,7]</code>。所以这里有三种不同的方式来进行T到t的映射。<br>下面的程序定义了类<strong>TridiagonalMatrix</strong>,其中采用了对角线映射方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> TridiagonalMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    T *t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TridiagonalMatrix(<span class="keyword">int</span> size = <span class="number">10</span>) : n(size)&#123;</span><br><span class="line">        t = <span class="keyword">new</span> T[<span class="number">3</span> * n - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~TridiagonalMatrix()&#123;<span class="keyword">delete</span>[] t;&#125;</span><br><span class="line">    TridiagonalMatrix&lt;T&gt;&amp; Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="function">T <span class="title">Retrieve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">TridiagonalMatrix&lt;T&gt;&amp; TridiagonalMatrix&lt;T&gt;::Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">    <span class="comment">// 把x存为T(i,j)</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">switch</span> (i-j)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// 低对角线</span></span><br><span class="line">            t[i - <span class="number">2</span>] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">// 主对角线</span></span><br><span class="line">            t[n - <span class="number">2</span> + i] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">            <span class="comment">// 高对角线</span></span><br><span class="line">            t[<span class="number">2</span> * n - <span class="number">2</span> + i] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> MustBeZero();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T TridiagonalMatrix&lt;T&gt;::Retrieve(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">switch</span> (i - j)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 低对角线</span></span><br><span class="line">        <span class="keyword">return</span> t[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 主对角线</span></span><br><span class="line">        <span class="keyword">return</span> t[n - <span class="number">2</span> + i];</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 高对角线</span></span><br><span class="line">        <span class="keyword">return</span> t[<span class="number">2</span> * n - <span class="number">2</span> + i];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先是从最下面的对角线开始，也就是低对角线，那么T(i,j)对应的一维数组是t[i-2]，接着轮到主对角线的时候，只需要用i加上低对角线的元素总数，即n-2个，也就是对应数组t[n-2+i]，因为i是依次从1，按行逐渐增加；最后对于高对角线，也是同样的计算方法。</p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>  在三角矩阵中，无论是上三角还是下三角矩阵，非0元素总数均为$\frac{n(n+1)}{2}$。</p>
<p>  两种三角矩阵都可以用一个大小为$\frac{n(n+1)}{2}$的一维数组进行描述。考虑把一个下三角矩阵映射到一个一维数组$l$，可以采用按行和按列两种不同的方式进行映射。如果按行映射，上图c中$4\times 4$下三角矩阵可以得到$l[0:9] = (2,5,1,0,3,1,4,2,7,0)$;若按列的方式，得到$l[0:9] =(2,5,0,4,1,3,2,1,7,0)$。</p>
<p>  所以对于下三角矩阵中的一个元素$L(i,j)$，如果$i\lt j$,则$L(i,j)=0$;如果$i\le j$，则$L(i,j)$位于非0元素区域，且其对应的一维数组是<strong>t[$\frac{i(i-1)}{2}+j-1$]</strong>，其映射规则是先统计前i-1行的非0元素数量然后加上当前元素所在第i行的所在列数j-1。下面给出自定义类<strong>LowerMatrix</strong>实现下三角矩阵,并且是按行来映射。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LowerMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 矩阵维数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 存储对角元素的一维数组</span></span><br><span class="line">    T *t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LowerMatrix(<span class="keyword">int</span> size = <span class="number">10</span>) : n(size)&#123;</span><br><span class="line">        t = <span class="keyword">new</span> T[n*(n+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~LowerMatrix()&#123; <span class="keyword">delete</span>[] t; &#125;</span><br><span class="line">    LowerMatrix&lt;T&gt;&amp; Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="function">T <span class="title">Retrieve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LowerMatrix&lt;T&gt;&amp; LowerMatrix&lt;T&gt;::Store(<span class="keyword">const</span> T&amp;x, <span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">    <span class="comment">// 将x存为D(i,j)</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="comment">// 当前仅当 i &gt;= j时，(i,j)位于下三角</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">        t[i*(i - <span class="number">1</span>) / <span class="number">2</span> + j - <span class="number">1</span>] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> MustBeZero();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T LowerMatrix&lt;T&gt;::Retrieve(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">        <span class="keyword">return</span> t[i*(i - <span class="number">1</span>) / <span class="number">2</span> + j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上三角矩阵的实现方式也是相同的，只需要改变判断条件，将$i \ge j$变成$i \le j$即可。</p>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>  一个$n\times n$的对称矩阵可以用一个大小为$\frac{n(n+1)}{2}$的一维数组来描述，可参考三角矩阵的存储模式来存储矩阵的上三角或下三角，即可以根据已经存储的元素来推算出未存储的元素。即如果存储下三角的元素，当需要给出在上三角的元素，只需要将行和列对调，再来搜索即可得到需要的元素值，这样做可以更节省空间。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本小节主要是介绍几种特殊矩阵，都是属于方阵，分别是三角矩阵，三对角矩阵，上三角和下三角矩阵以及对称矩阵，并且都自定义类来实现这几种特殊的矩阵。</p>
<p>  更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍几种特殊矩阵的内容。</p>
<h3 id="定义和应用"><a href="#定义和应用" class="headerlink" title="定义和应用"></a>定义和应用</h3><bl]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵2-矩阵]]></title>
    <link href="http://ccc013.github.io/2016/06/30/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B52-%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/06/30/数组和矩阵2-矩阵/</id>
    <published>2016-06-30T11:29:36.000Z</published>
    <updated>2016-10-24T12:06:02.844Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍矩阵的基本概念以及自定义一个类Matrix实现基本的矩阵操作。</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="定义和操作"><a href="#定义和操作" class="headerlink" title="定义和操作"></a>定义和操作</h4><p>  一个$m\times n$的矩阵(matrix)是一个m行、n列的表，如下图所示，其中m和n是矩阵的维数。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%9F%A9%E9%98%B51.png" alt="此处输入图片的描述"></p>
<p>对于矩阵来说，最常见的操作就是矩阵转置、矩阵加和矩阵乘。</p>
<p>一个$m\times n$矩阵的转置矩阵是一个$n\times m$的矩阵$M^T$,它与$M$之间存在以下关系：</p>
<script type="math/tex; mode=display">
M^T(i,j) = M(j,i)\quad 1\le i\le n,\; 1\le j\le m</script><p>仅当两个矩阵的维数相同时，即具有相同的行数和列数，才可以对两个矩阵求和。两个$m\times n$矩阵$A和B$相加所得到的$m\times n$矩阵$C$如下：</p>
<script type="math/tex; mode=display">
C(i,j) =A(i,j)+B(i,j)\quad 1\le i\le n,\; 1\le j\le m</script><p>仅当一个$m\times n$矩阵$A$的列数与另一个$q\times p$矩阵$B$的行数相同，即<strong>n=q</strong>,才可以执行矩阵乘法$A*B$。其得到的$m\times p$矩阵$C$满足以下关系：</p>
<script type="math/tex; mode=display">
C(i,j) = \sum_{k=1}^nA(i,k)\ *\ B(k,j)\quad 1\le i\le m,\; 1\le j\le p</script><p>矩阵加的代码实现如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">( T **a, T **b, T **c, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 矩阵 a 和 b 相加得到矩阵 c .</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">             c[i][j] = a[i][j] + b[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵转置代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transpose</span><span class="params">(T **a, <span class="keyword">int</span> rows)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 对矩阵 a[0:rows-1][0:rows-1] 进行转置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; rows; j++)</span><br><span class="line">            Swap(a[i][j], a[j][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵乘法的代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mult</span><span class="params">(T **a, T **b, T **c, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// m x n 矩阵 a 与 n x p 矩阵 b相乘得到c</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++) &#123;</span><br><span class="line">            T sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                sum += a[i][k] * b[k][j];</span><br><span class="line">            c[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="类Matrix"><a href="#类Matrix" class="headerlink" title="类Matrix"></a>类Matrix</h4><p>  这里自定义一个类Matrix来实现矩阵的功能，在该类中，使用<strong>()</strong>来指定每个元素，并且各行和各列的索引值都是从1开始的。<br>  其类定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> MATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="comment">// 元素数组</span></span><br><span class="line">    T *element; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Matrix(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    Matrix(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m);</span><br><span class="line">    ~Matrix()&#123; <span class="keyword">delete</span>[] element; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rows</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> rows; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Columns</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> cols; &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">    Matrix&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m);</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>+() <span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt;&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp; m);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>构造函数，复制构造函数以及赋值运算符的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;::Matrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    <span class="keyword">if</span> ((!r || !c) &amp;&amp; (r || c))</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    rows = r;</span><br><span class="line">    cols = c;</span><br><span class="line">    element = <span class="keyword">new</span> T[r*c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;::Matrix(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    rows = m.rows;</span><br><span class="line">    cols = m.cols;</span><br><span class="line">    element = <span class="keyword">new</span> T[rows*cols];</span><br><span class="line">    <span class="keyword">int</span> size = rows * cols;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        element[i] = m.element[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)&#123;</span><br><span class="line">    <span class="comment">// 重载赋值运算符=</span></span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span> != &amp;m)&#123;</span><br><span class="line">        rows = m.rows;</span><br><span class="line">        cols = m.cols;</span><br><span class="line">        <span class="keyword">delete</span>[] element;</span><br><span class="line">        element = <span class="keyword">new</span> T[rows*cols];</span><br><span class="line">        <span class="keyword">int</span> size = rows * cols;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            element[i] = m.element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了重载矩阵下标操作法(),使用了C++的函数操作符()，与数组的下标操作法[]不同的是，该操作符可以带任意数量的参数。对于一个矩阵来说，需要两个整数参数。如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T&amp; Matrix&lt;T&gt;::<span class="keyword">operator</span>()(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个指向元素(i,j)的引用</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;rows || j&lt;<span class="number">1</span> || j&gt;cols)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">return</span> element[(i - <span class="number">1</span>)*cols + j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二元减法的代码如下，矩阵加法操作符，一元减法操作符，增值操作符和输出操作符的代码都比较类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt; Matrix&lt;T&gt;::<span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rows != m.rows || cols != m.cols)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    Matrix&lt;T&gt; w(rows, cols);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++)&#123;</span><br><span class="line">        w.element[i] = element[i] - m.element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵乘法实现如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt; Matrix&lt;T&gt;::<span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 矩阵乘法 返回w = (*this) * m</span></span><br><span class="line">    <span class="keyword">if</span> (cols != m.rows)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    Matrix&lt;T&gt; w(rows, m.cols);</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>, cm = <span class="number">0</span>, cw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++)&#123;</span><br><span class="line">        <span class="comment">// 计算出结果的第i行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m.cols; j++)&#123;</span><br><span class="line">            <span class="comment">// 计算w(i,j)的第一项</span></span><br><span class="line">            T sum = element[ct] * m.element[cm];</span><br><span class="line">            <span class="comment">// 累加其余项</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= cols; k++)&#123;</span><br><span class="line">                <span class="comment">// 指向*this第i行的下一个元素</span></span><br><span class="line">                ct++;</span><br><span class="line">                <span class="comment">// 指向m的第j列的下一项</span></span><br><span class="line">                cm += m.cols;</span><br><span class="line">                sum += element[ct] * m.element[cm];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存w(i,j)</span></span><br><span class="line">            w.element[cw++] = sum;</span><br><span class="line">            <span class="comment">// 重新调整至行首和下一列</span></span><br><span class="line">            ct -= cols - <span class="number">1</span>;</span><br><span class="line">            cm = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新调整至下一行的行首和第一列</span></span><br><span class="line">        ct += cols;</span><br><span class="line">        cm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a></p>
<h5 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h5><p>  当T是一个内部数据类型时，矩阵构造函数复杂性是$O(1)$，当T是一个用户自定义类时，构造函数的复杂性是$O(rows<em>cols)$，下标操作符的复杂性是$\theta(1)$,乘法操作符的复杂性是$O(rows</em>cols*m.cols)$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍矩阵的基本概念以及自定义一个类Matrix实现基本的矩阵操作。</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵1--数组]]></title>
    <link href="http://ccc013.github.io/2016/06/28/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B51-%E6%95%B0%E7%BB%84/"/>
    <id>http://ccc013.github.io/2016/06/28/数组和矩阵1-数组/</id>
    <published>2016-06-28T06:55:14.000Z</published>
    <updated>2016-10-24T12:04:16.134Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍数组的内容。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><blockquote>
<p>数据对象<strong>array</strong>的每个实例都是形如<strong>(index, value)</strong>的数据对集合，其中任意两对数据的<strong>index</strong>值都各不相同。</p>
</blockquote>
<p>数组的抽象数据类型描述如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 Array&#123;</span><br><span class="line">实例</span><br><span class="line">    形如 (index , value)的数据对集合，其中任意两对数据的 index 值都各不相同</span><br><span class="line">操作</span><br><span class="line">   Create()：创建一个空的数组</span><br><span class="line">   Store(index, value)：添加数据(index, value)，同时删除具有相同index值的数据对（如果存在）</span><br><span class="line">   Retrieve(index)：返回索引值为 index的数据对</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-数组"><a href="#C-数组" class="headerlink" title="C++数组"></a>C++数组</h4><p> 在C++中数组是一个标准的数据结构，但C++数组的索引(也称为下标)必须采用如下形式：$[i_1][i_2][i_3]\ldots [i_k]$.<br> $i_j$是一个非负整数，如果k为1，则数组是一个一维数组，如果k是2，则是二维数组。$i_1$是索引的第一个坐标，$i_2$是第二个，$i_k$是第k个。在C++中，值为整数类型的k维数组<code>score</code>可用如下语句来创建：</p>
<script type="math/tex; mode=display">
int\; \; score[u_1][u_2][u_2]\ldots [u_k]</script><p>该数组最大可用容纳$n = u_1u_2u_2\ldots u_k$个值。由于数组是存储int类型的整数，所以每个元素需要<code>sizeof(int)</code>个字节，因此，整个数组所需要的存储空间为<strong>sizeof(score) = n * sizeof(int)</strong>个字节。C++编译器将为数组预留这么多空间。加入预留空间的起始地址为<code>start</code>，则该空间将延伸至<code>start+sizeof(score)-1</code>。</p>
<h4 id="行主映射和列主映射"><a href="#行主映射和列主映射" class="headerlink" title="行主映射和列主映射"></a>行主映射和列主映射</h4><p>为了实现与数组相关的函数<code>Store</code>和<code>Retrieve</code>，必须确定<strong>索引值</strong>在<strong>[start,start+sizeof(score)-1]</strong>中的相应位置。实际上就是把数组索引$[i_1][i_2][i_3]\ldots [i_k]$映射到<code>[0,n-1]</code>中的某个数$map(i_1,i_2,i_3,\ldots ,i_k)$,使得该索引所对应的元素值存储在以下位置$start+map(i_1,i_2,i_3,\ldots ,i_k)*sizeof(int)$。</p>
<p>当数组维数是1时，即k=1，使用以下函数：$map(i_1) = i_1$</p>
<p>当数组维数是2时，各索引可按下图所示的表格形式进行排列。第一个坐标相同的位于同一行，第二个坐标相同的索引位于同一列。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%841.png" alt="此处输入图片的描述"><br>对上图从第一行开始，依次对每一行中的每个索引从左至右进行连续编号，即可得到下图a所示的映射结果。<strong>这种把二维数组中的位置映射为[0,n-1]中某个数的方式被称为行主映射</strong>。C++中即采用了这种行主映射模式。而下图b则给出了另一种模式，称为列主映射。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%842.png" alt="此处输入图片的描述"></p>
<p>行主映射中所对应的映射函数为：$map(i_1,i_2) = i_1 * u_2 + i_2$</p>
<p>其中$u_2$是数组的列数。这里的$i_1,i_2$都是从0开始。</p>
<p>根据上述的行主映射模式可以得到二维以上的映射函数。比如对于三维数组，其行主映射函数为$map(i_1,i_2,i_3) = i_1u_2u_3+i_2u_3+i_3$</p>
<p>对于k维数组，其行主映射函数为$map(i_1,i_2,i_3,\ldots ,i_k) = i_1u_2u_3\ldots u_k + i_2u_3\ldots u_k+\dots+i_{k-1}u_k+i_k$</p>
<h4 id="类Array1D"><a href="#类Array1D" class="headerlink" title="类Array1D"></a>类Array1D</h4><p>C++中虽然支持一维数组，但是这种支持还不够，比如不能使用超出正常范围之外的索引值，如索引值必须都是正整数，不能使用负数。</p>
<p>为了克服这些不足，定义了类Array1D,代码如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> ARRAY1D_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ARRAY1D_H_</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Array1D&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    T *element;     <span class="comment">// 一维数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array1D(<span class="keyword">int</span> size = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    Array1D(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; x);   </span><br><span class="line">    ~Array1D()&#123; <span class="keyword">delete</span>[] element; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    Array1D&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v);</span><br><span class="line">    <span class="comment">// 一元加法操作符</span></span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>+()<span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// 一元减法操作法</span></span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt;&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>该类每个实例X都是一个一维数组。X的元素都存储在数组<code>X.element</code>中，第i个元素为于<code>X.element[i]</code>，$0 \le i \lt size$。</p>
<p>这个类的共享成员包括: 构造函数，复制构造函数，析构函数，下标操作法[]，返回数组大小的函数Size，算术操作符+、-、*和+=。下面首先是给出构造函数和复制构造函数的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;::Array1D(<span class="keyword">int</span> sz)&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    size = sz;</span><br><span class="line">    element = <span class="keyword">new</span> T[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;::Array1D(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    size = v.size;</span><br><span class="line">    element = <span class="keyword">new</span> T[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        element[i] = v.element[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出重载操作符[]的代码，该操作符用来返回指向第i个元素的引用，可以使存储和查询操作很自然干的方式进行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T&amp; Array1D&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回第i个元素的引用</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">return</span> element[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来给出赋值操作符的代码。首先需要避免进行自我赋值，然后需要先释放目标数组<code>*this</code>所占用的空间，然后再分配一个新的空间，并进行赋值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;&amp; Array1D&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array1D&lt;T&gt;&amp;ｖ)&#123;</span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;v)&#123;</span><br><span class="line">        <span class="comment">// 不是自我赋值</span></span><br><span class="line">        size = v.size;</span><br><span class="line">        <span class="keyword">delete</span>[] element;</span><br><span class="line">        element = <span class="keyword">new</span> T[size];</span><br><span class="line">        <span class="comment">// 复制元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            element[i] = v.element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当<code>T</code>是一个内部C++数据类型(如int，float和char)时，构造函数和析构函数的复杂性是$\theta(1)$,而当T是一个用户自定义的类时，构造函数和析构函数的复杂性是$O(size)$。存在这种差异的原因是：<strong>当T是一个用户自定义类时，在用new(delete)创建(删除)数组element的过程中，对于element的每个元素都要调用一次T的构造函数(析构函数)。</strong>下标操作法[]的复杂性是$\theta(1)$,其他操作符的复杂性均为$O(size)$（注意复杂性不会是$\theta(size)$，因为所有操作符的代码都可以引发一个异常并提前终止）。</p>
<p>下面给出测试的代码及结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testArray1D</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; b(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        a[i] = i * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a is \n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b=a, so b is \n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= a+b,so c :\n"</span>;</span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; c(<span class="number">10</span>);</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; d(<span class="number">10</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a*c = \n"</span>;</span><br><span class="line">    d = a*c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; e(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c-b = \n"</span>;</span><br><span class="line">    e = c - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%843.png" alt="此处输入图片的描述"></p>
<p>完整例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a>.</p>
<h4 id="类Array2D"><a href="#类Array2D" class="headerlink" title="类Array2D"></a>类Array2D</h4><p>对于二维数组，可以定义一个类Array2D。程序如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> ARRAY2D_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ARRAY2D_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Array2D&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols; <span class="comment">// 数组维数</span></span><br><span class="line">    Array1D&lt;T&gt; *row;        <span class="comment">// 一维数组的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array2D(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>);</span><br><span class="line">    Array2D(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; m);</span><br><span class="line">    ~Array2D() &#123; <span class="keyword">delete</span>[] row; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rows</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> rows; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Columns</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> cols; &#125;</span><br><span class="line">    Array1D&lt;T&gt; &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v);</span><br><span class="line">    <span class="comment">// 一元加法操作符</span></span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>+()<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// 一元减法操作法</span></span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt;&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>在定义中使用一维数组<code>row</code>来存储每个行数组。</p>
<p>下面给出构造函数实现的代码，其中的方法<code>Resize</code>是<code>Array1D</code>新增加的一个成员函数，其实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;&amp; Array1D&lt;T&gt;::Resize(<span class="keyword">int</span> sz)&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] element;</span><br><span class="line">    size = sz;</span><br><span class="line">    element = <span class="keyword">new</span> T[sz];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array2D&lt;T&gt;::Array2D(<span class="keyword">int</span> r, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    <span class="keyword">if</span> ((!r || !c) &amp;&amp; (r || c))</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    rows = r;</span><br><span class="line">    cols = c;</span><br><span class="line">    row = <span class="keyword">new</span> Array1D&lt;T&gt;[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        row[i].Resize(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面则是给出复制构造函数的实现，复制构造函数首先会创建一个具有给定位置数的数组<code>row</code>，然后利用一维数组的赋值操作符复制二维数组中的每一行数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array2D&lt;T&gt;::Array2D(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; m)&#123;</span><br><span class="line">    rows = m.rows;</span><br><span class="line">    cols = m.cols;</span><br><span class="line">    <span class="comment">// 分配指向一维数组的数组</span></span><br><span class="line">    row = <span class="keyword">new</span> Array1D&lt;T&gt;[rows];</span><br><span class="line">    <span class="comment">// 复制每一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        row[i] = m.row[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>乘法操作符的实现类似于矩阵乘，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵乘</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array2D&lt;T&gt; Array2D&lt;T&gt;::<span class="keyword">operator</span>*(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; m)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cols != m.cols)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    Array2D&lt;T&gt; w(rows, m.cols);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m.cols; j++)&#123;</span><br><span class="line">                T sum = (*<span class="keyword">this</span>)[i][<span class="number">0</span>] * m[<span class="number">0</span>][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; cols; k++)</span><br><span class="line">                    sum += (*<span class="keyword">this</span>)[i][k] * m[k][j];</span><br><span class="line">                w[i][j] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本小节介绍了数组，并自定义了一个一维数组类<code>Array1D</code>以及二维数组类<code>Array2D</code>。</p>
<p>  虽然是增加了不少方法，但是感觉用起来是没有C++的数组那么方便。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍数组的内容。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="抽象数据类型"><a ]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
