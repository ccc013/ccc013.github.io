<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Cai's blog]]></title>
  <subtitle><![CDATA[Stay hungry, stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ccc013.github.io/"/>
  <updated>2016-08-24T10:53:12.434Z</updated>
  <id>http://ccc013.github.io/</id>
  
  <author>
    <name><![CDATA[cai]]></name>
    <email><![CDATA[429546420@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[优先队列2-左高树]]></title>
    <link href="http://ccc013.github.io/2016/08/24/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%972-%E5%B7%A6%E9%AB%98%E6%A0%91/"/>
    <id>http://ccc013.github.io/2016/08/24/优先队列2-左高树/</id>
    <published>2016-08-24T10:50:30.000Z</published>
    <updated>2016-08-24T10:53:12.434Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本节将介绍另一种实现优先队列的数据结构–左高树</p>
<h3 id="u9AD8_u5EA6_u4E0E_u5BBD_u5EA6_u4F18_u5148_u7684_u6700_u5927_u53CA_u6700_u5C0F_u5DE6_u9AD8_u6811"><a href="#u9AD8_u5EA6_u4E0E_u5BBD_u5EA6_u4F18_u5148_u7684_u6700_u5927_u53CA_u6700_u5C0F_u5DE6_u9AD8_u6811" class="headerlink" title="高度与宽度优先的最大及最小左高树"></a>高度与宽度优先的最大及最小左高树</h3><p>  上一节讲述的堆结构是一种<strong>隐式数据结构</strong>，用完全二叉树表示的堆在数组中时隐式存储的（即没有明确的指针或其他数据能够重构这种结构）。由于没有存储结构信息，这种描述方法空间利用率很高，事实上是没有空间浪费，尽管堆结构的时间和空间效率都很高，但它不适合所有优先队列的应用，尤其是当需要合并两个优先队列或多个长度不同的队列时，需要借助其他数据结构来实现这类应用，比如<strong>左高树(leftist tree)</strong>。</p>
<p>  考察一棵二叉树，如下图9-6a所示，它有一类特殊的节点叫做<strong>外部节点，用来代替树中的空子树，其余节点叫做内部节点。</strong>增加了外部节点的二叉树被称为扩充二叉树，如下图9-6b所示，外部节点用阴影框表示，并且为了方便起见，这些节点用a~f标注。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%B7%A6%E9%AB%98%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  令$s(x)$是从节点$x$到它的子树的外部节点的所有路径横纵最短的一条，根据其定义可知，如果$x$是外部节点，则$s$=0，若$x$是内部节点，则其$s$值为$min{s(L),s(R)}+1$，其中$L,R$分别是$x$的左右子树。所以上述扩充二叉树各节点的s值如上图9-c所示。</p>
<blockquote>
<p>定义 [高度优先左高树] 当且仅当一棵二叉树的任何一个内部节点，<strong>其左孩子的$s$值大于等于右孩子的$s$值时</strong>，该二叉树是高度优先左高树(height-biased leftist tree,HBLT)。</p>
<p>定义 [最大(小)HBLT] 即同时是最大(小)树的HBLT; </p>
</blockquote>
<p>图9-6a所示的二叉树并不是HBLT，因为外部节点a的父节点，其左孩子$s$=0，右孩子$s$=1，不满足条件，如果将这两个子树进行交换就可以满足HBLT的条件。</p>
<blockquote>
<p>定理9-1 若x是一个HBLT的内部节点，则<br>1) 以$x$为根的子树的节点数目至少是$2^{s(x)}-1$.<br>2) 若子树$x$有$m$个节点，$s(x)$最多为$log_2(m+1)$<br>3) 通过最右路径（即路径是从$x$开始沿右孩子移动）从$x$到达外部节点的路径长度是$s(x)$。</p>
</blockquote>
<p><strong>可以通过考察子树的节点数目来得到另一类左高树。</strong>定义$x$的重量$w(x)$是以$x$为根的子树的内部节点数目。如果$x$是外部节点，则其重量为0；若$x$是内部节点，则其重量是其孩子节点的重量之和加1，如上图9-6d展示了二叉树各节点的重量。</p>
<blockquote>
<p>定义 [重量优先左高树] 当且仅当一棵二叉树的任何一个内部节点，其左孩子的$w$值大于等于右孩子的$w$时，该二叉树为重量优先左高树(weight-biased leftist tree,WBLT);</p>
</blockquote>
<p>[最大(小)WBLT]即同时又是最大(小)树的WBLT。</p>
<p>同HBLT类似，具有$m$个节点的WBLT的最右路径长度最多为$log_2(m+1)$。可以对WBLT和HBLT执行优先队列的查找、插入和删除操作，其时间复杂性与堆的相应操作相同。并且跟堆一样，WBLT和HBLT可以在线性时间内完成初始化。用WBLT或HBLT描述的两个优先队列可在对数时间内合并为一个，而堆描述的优先队列无法做到。</p>
<p>接下来将介绍HBLT的操作，而WBLT的查找、插入、删除、合并和初始化操作与HBLT非常相似。</p>
<h3 id="u6700_u5927HBLT_u7684_u63D2_u5165"><a href="#u6700_u5927HBLT_u7684_u63D2_u5165" class="headerlink" title="最大HBLT的插入"></a>最大HBLT的插入</h3><p>  <strong>插入操作可借助于合并操作来完成。</strong>它可以通过先建立一棵仅包含待插入元素的HBLT，然后与原来的HBLT合并即可。</p>
<h3 id="u6700_u5927HBLT_u7684_u5220_u9664"><a href="#u6700_u5927HBLT_u7684_u5220_u9664" class="headerlink" title="最大HBLT的删除"></a>最大HBLT的删除</h3><p>  根是最大元素，如果跟被删除，将留下分别以其左右孩子为根的两棵HBLT的子树，将其合并到一起，便得到包含除删除元素外所有元素的最大HBLT。</p>
<h3 id="u5408_u5E76_u4E24_u68F5_u6700_u5927HBLT"><a href="#u5408_u5E76_u4E24_u68F5_u6700_u5927HBLT" class="headerlink" title="合并两棵最大HBLT"></a>合并两棵最大HBLT</h3><p>  具有$n$个元素的最大HBLT，其最右路径的长度为$O(logn)$。合并操作操作仅需遍历欲合并的HBLT的最右路径，即仅需移动右孩子。</p>
<p> 合并策略最好用递归来实现。令$A,B$是需要合并的两棵最大HBLT，假设两者均不为空，为实现合并，首先需要检查两个根元素，较大者是合并后HBLT的根。假设$A$具有较大的根，且其左子树是$L$,$C$是由$A$的右子树与$B$合并而成的HBLT。所以$A,B$合并的结果是以$A$的根为根，$L,C$为左右子树的最大HBLT。如果$L$的$s$值小于$C$的$s$值，则$C$是右子树，$L$是左子树。</p>
<h3 id="u521D_u59CB_u5316_u6700_u5927HBLT"><a href="#u521D_u59CB_u5316_u6700_u5927HBLT" class="headerlink" title="初始化最大HBLT"></a>初始化最大HBLT</h3><p>  通过将$n$个元素插入到最初为空的最大HBLT中来进行初始化，所需时间是$O(logn)$。为得到具有线性时间的初始化算法，首先创建$n$个最大HBLT，每个树中仅包含$n$个元素中的某一个，这$n$棵树排成一个FIFO队列，然后从队列中依次删除两个HBLT，将其合并，然后再加入队列末尾，直到最后只有一棵HBLT。</p>
<h3 id="u7C7BMaxHBLT"><a href="#u7C7BMaxHBLT" class="headerlink" title="类MaxHBLT"></a>类MaxHBLT</h3><p>  最大HBLT的每个节点均需要$data,LeftChild,RightChild和s$四个域，相应的节点类是$HBLTNode$,如下代码所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class MaxHBLT;&#10;&#10;template&#60;class T&#62;&#10;class HBLTNode&#123;&#10;    friend MaxHBLT&#60;T&#62;;&#10;private:&#10;    int s;&#10;    T data;&#10;    HBLTNode&#60;T&#62;* LeftChild, *RightChild;&#10;public:&#10;    HBLTNode(const T&#38;e, const int sh)&#123;&#10;        data = e;&#10;        s = sh;&#10;        LeftChild = RightChild = 0;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而最大HBLT可用下面代码定义的类MaxHBLT来实现。类MaxHBLT的每个对象都有一个唯一的私有成员$root$，用来指向最大HBLT的根。构造函数在初始化时将其置为0，因此初始的最大HBLT是空。析构函数通过调用私有成员函数$Free$来删除HBLT中的所有节点，该函数按后序遍历整棵HBLT，每访问一个节点就删除该节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class MaxHBLT&#123;&#10;private:&#10;    HBLTNode&#60;T&#62; *root;&#10;    void PostOrder(void(*Visit)(HBLTNode&#60;T&#62;*u), HBLTNode&#60;T&#62;* t)&#123;&#10;        // &#21518;&#24207;&#36941;&#21382;&#10;        if (t)&#123;&#10;            PostOrder(Visit, t-&#62;LeftChild);&#10;            PostOrder(Visit, t-&#62;RightChild);&#10;            Visit(t);&#10;        &#125;&#10;    &#125;&#10;    static void free(HBLTNode&#60;T&#62;* t)&#123;&#10;        delete t;&#10;    &#125;&#10;    void Free(HBLTNode&#60;T&#62; *t)&#123;&#10;        PostOrder(free, t);&#10;        t = 0;&#10;    &#125;&#10;    void Meld(HBLTNode&#60;T&#62; * &#38;x, HBLTNode&#60;T&#62;* y);&#10;public:&#10;    MaxHBLT()&#123; root = 0 &#125;;&#10;    ~MaxHBLT()&#123; Free(root); &#125;&#10;    T Max()&#123;&#10;        if (!root)&#10;            throw OutOfBounds();&#10;        return root-&#62;data;&#10;    &#125;&#10;    MaxHBLT&#60;T&#62;&#38; Insert(const T&#38; x);&#10;    MaxHBLT&#60;T&#62;&#38; DeleteMax(T&#38; x);&#10;    MaxHBLT&#60;T&#62;&#38; Meld(MaxHBLT&#60;T&#62;&#38; x)&#123;&#10;        Meld(root, x.root);&#10;        x.root = 0;&#10;        return *this;&#10;    &#125;&#10;    void Initialize(T a[], int n);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来先给出合并操作的函数实现代码，该函数首先要处理合并的树中至少有一个为空的特殊情况。当没有空树时要确保$x$指向根值较大的树，如果$x$不是指向根值较大的树，则将$x$和$y$的指针进行交换。接下来把$x$的右子树与以$y$为根的最大HBLT进行递归合并。合并后为保证整棵树是最大HBLT，$x$的左右孩子可能需要交换，这是通过计算$x$的$s$值来确定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void MaxHBLT&#60;T&#62;::Meld(HBLTNode&#60;T&#62;* &#38;x, HBLTNode&#60;T&#62;* y)&#123;&#10;    // &#21512;&#24182;&#20004;&#26869;&#26681;&#20998;&#21035;&#26159;*x&#21644;*y&#30340;&#24038;&#39640;&#26641;&#65292;&#36820;&#22238;&#25351;&#21521;&#26032;&#26681; x&#30340;&#25351;&#38024;&#10;    if (!y)&#10;        return;&#10;    if (!x)&#123;&#10;        x = y;&#10;        return;&#10;    &#125;&#10;    if (x-&#62;data &#60; y-&#62;data)&#123;&#10;        // &#20132;&#25442;x&#21644;y&#10;        HBLTNode&#60;T&#62; * temp = y;&#10;        y = x;&#10;        x = temp;&#10;    &#125;&#10;    Meld(x-&#62;RightChild, y);&#10;    if (!x-&#62;LeftChild)&#123;&#10;        // &#24038;&#23376;&#26641;&#20026;&#31354;,&#20132;&#25442;&#23376;&#26641;&#10;        x-&#62;LeftChild = x-&#62;RightChild;&#10;        x-&#62;RightChild = 0;&#10;        x-&#62;s = 1;&#10;    &#125;&#10;    else&#123;&#10;        if (x-&#62;LeftChild-&#62;s &#60; x-&#62;RightChild-&#62;s)&#123;&#10;            // &#20132;&#25442;&#24038;&#21491;&#23376;&#26641;&#10;            HBLTNode&#60;T&#62; * temp = x-&#62;LeftChild;&#10;            x-&#62;RightChild = x-&#62;LeftChild;&#10;            x-&#62;LeftChild = temp;&#10;        &#125;&#10;        x-&#62;s = x-&#62;RightChild-&#62;s + 1;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后给出插入，删除和初始化函数的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;MaxHBLT&#60;T&#62;&#38; MaxHBLT&#60;T&#62;::Insert(const T&#38; x)&#123;&#10;    // &#23558;x&#25554;&#20837;&#24038;&#39640;&#26641;&#10;    HBLTNode&#60;T&#62;* q = new HBLTNode&#60;T&#62;(x, 1);&#10;    // &#23558;q&#19982;&#21407;&#26641;&#21512;&#24182;&#10;    Meld(root, q);&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;MaxHBLT&#60;T&#62;&#38; MaxHBLT&#60;T&#62;::DeleteMax(T&#38; x)&#123;&#10;    // &#21024;&#38500;&#26368;&#22823;&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#25918;&#20837;x&#10;    if (!root)&#10;        throw OutOfBounds();&#10;&#10;    x = root-&#62;data;&#10;    HBLTNode&#60;T&#62;*L = root-&#62;LeftChild;&#10;    HBLTNode&#60;T&#62;*R = root-&#62;RightChild;&#10;    delete root;&#10;    root = L;&#10;    Meld(root, R);&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void MaxHBLT&#60;T&#62;::Initialize(T a[], int n)&#123;&#10;    // &#21021;&#22987;&#21270;&#26377;n&#20010;&#20803;&#32032;&#30340;HBLT&#26641;&#10;    Queue&#60;HBLTNode&#60;T&#62;*&#62;Q(n);&#10;    // &#21024;&#38500;&#32769;&#33410;&#28857;&#10;    Free(root);&#10;    for (int i = 1; i &#60;= n; i++)&#123;&#10;        HBLTNode&#60;T&#62;* q = new HBLTNode&#60;T&#62;(a[i-1], 1);&#10;        Q.Add(q);&#10;    &#125;&#10;&#10;    // &#19981;&#26029;&#21512;&#24182;&#38431;&#21015;&#20013;&#30340;&#26641;&#65307;&#10;    HBLTNode&#60;T&#62;*b, *c;&#10;    for (int i = 1; i &#60;= n - 1; i++) &#123;&#10;        Q.Delete(b).Delete(c);&#10;        Meld(b, c);&#10;        // &#23558;&#21512;&#24182;&#21518;&#24471;&#21040;&#30340;&#26641;&#25918;&#20837;&#23545;&#20102;&#10;        Q.Add(b);&#10;    &#125;&#10;&#10;    if (n)&#10;        Q.Delete(root);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于上述函数的复杂性，构造函数只需要耗时$\theta(1)$,而析构函数需要$\theta(n)$，其中$n$是要删除的最大HBLT中的元素个数。<strong>Max</strong>函数的复杂性是$\theta(1)$，<strong>Insert,DeleteMax</strong>及共享成员函数<strong>Meld</strong>的复杂性与私有成员函数<strong>Meld</strong>的复杂性相同，由于私有成员函数<strong>Meld</strong>仅在以$<em>x$和$</em>y$为根的树的右子树中移动，因此其复杂性是$O(x-&gt;s+y-&gt;s)$。又由于$<em>x$和$</em>y$的最大$s$值分别为$log_2(m+1)$和$log_2(n+1)$,其中$m,n$分别是以$<em>x$和$</em>y$为根的最大HBLT中的元素个数，所以私有成员函数<strong>Meld</strong>的复杂性是$O(logmn)$。</p>
<p>更完整的代码例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/PriorityQueue/MaxHBLT.h" target="_blank" rel="external">最大高度优先左高树的实现</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本节将介绍另一种实现优先队列的数据结构–左高树</p>
<h3 id="u9AD8_u5EA6_u4E0E_u5BBD_u5EA6_u4F18_u5148_u7684_u6700_u5927_u5]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优先队列1--堆]]></title>
    <link href="http://ccc013.github.io/2016/08/23/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%971-%E5%A0%86/"/>
    <id>http://ccc013.github.io/2016/08/23/优先队列1-堆/</id>
    <published>2016-08-23T12:27:57.000Z</published>
    <updated>2016-08-23T12:31:01.615Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本小节主要介绍的是优先队列的定义以及其中一种实现方法–最大堆的实现，最后是堆的一个应用–堆排序。</p>
<p>优先队列删除元素时根据优先权高或低的次序，而不是元素进行队列的次序，这与之前第六章介绍的FIFO结构的队列不同。</p>
<p><strong>可以利用堆数据结构来高效地实现优先队列，堆是一棵完全二叉树</strong>。</p>
<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>优先队列（priority queue)是0个或多个元素的集合，每个元素都有一个优先权或值，对优先队列执行的操作有1）查找；2）插入一个新元素；3）删除。</p>
</blockquote>
<p>优先队列可以按搜索的是优先权大或小的元素分为最大优先队列或者最小优先队列，而删除操作则是用来删除对应查找的元素。另外，优先队列中的元素可以有相同的优先权，查找和删除操作可根据任意优先权进行。</p>
<p>下面给出最大优先队列的抽象数据类型，最小优先队列的抽象数据类型与之相似，只需要将最大改为最小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411;MaxPriorityQueue&#123;&#10;&#23454;&#20363;&#10;    &#26377;&#38480;&#30340;&#20803;&#32032;&#38598;&#21512;&#65292;&#27599;&#20010;&#20803;&#32032;&#37117;&#26377;&#19968;&#20010;&#20248;&#20808;&#26435;&#10;&#25805;&#20316;&#10;    Create(): &#21019;&#24314;&#19968;&#20010;&#31354;&#30340;&#20248;&#20808;&#38431;&#21015;&#10;    Size(): &#36820;&#22238;&#38431;&#21015;&#20013;&#30340;&#20803;&#32032;&#25968;&#30446;&#10;    Max(): &#36820;&#22238;&#20855;&#26377;&#26368;&#22823;&#20248;&#20808;&#26435;&#30340;&#20803;&#32032;&#10;    Insert(x): &#23558;x&#25554;&#20837;&#38431;&#21015;&#10;    DeleteMax(x): &#20174;&#38431;&#21015;&#20013;&#21024;&#38500;&#20855;&#26377;&#26368;&#22823;&#20248;&#20808;&#26435;&#30340;&#20803;&#32032;&#65292;&#24182;&#23558;&#35813;&#20803;&#32032;&#36820;&#22238;&#33267;x&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u5806"><a href="#u5806" class="headerlink" title="堆"></a>堆</h3><h4 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>[最大树（最小树）] 每个节点的值都大于（小于）或等于其子节点（如果有的话）值的树。</p>
</blockquote>
<p>最大树与最小树的例子分别如下图9-1,9-2所示。虽然这些树都是二叉树，但最大树不必是二叉树，最大树或最小树节点的子节点个数可以大于2。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%861.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>[最大堆(最小堆)] 最大（最小）的完全二叉树。</p>
</blockquote>
<p>上图9-1b并所示的最大树并不是最大堆，因为它不是完全二叉树，而其他两个最大树是最大堆。同样，图9-2b也不是完全二叉树，所以也不是最小堆，其他两个最小树则是最小堆。</p>
<p>堆是完成二叉树，可以利用<a href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/">二叉树的基本概念和实现</a>中介绍的公式化描述方案，可用一维数组有效地描述堆，利用二叉树的特性4可将堆中的节点移动到其父节点或子节点处。<strong>另外，堆是完全二叉树，拥有n个元素的堆高度是$\left\lceil  log_2(n+1) \right\rceil$,因此，如果可在$O(height)$时间内完成插入和删除操作，其复杂性是$O(log_2n)$。</strong></p>
<h4 id="u6700_u5927_u5806_u7684_u63D2_u5165"><a href="#u6700_u5927_u5806_u7684_u63D2_u5165" class="headerlink" title="最大堆的插入"></a>最大堆的插入</h4><p>  如下图9-3a是一个具有5个元素的最大堆，当要加入一个元素的时候，因为堆是完全二叉树，得到的新树结构必然如9-3b所示，这个时候如果新元素的值是5，它比2要大，此时需要将2下移变成左孩子，如图9-3c所示，此外还要与根节点进行比较，这里如果新插入的元素值是21，就大于根节点的20了，此时还需要将20下移到原来2的位置，变成如图9-3d所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%862.png" alt="此处输入图片的描述"></p>
<p>  插入策略从叶到根只有单一路径，每层工作需耗时$\theta(1)$,因此实现此策略的时间复杂性是$O(height)=O(log_2n)$。</p>
<h4 id="u6700_u5927_u5806_u7684_u5220_u9664"><a href="#u6700_u5927_u5806_u7684_u5220_u9664" class="headerlink" title="最大堆的删除"></a>最大堆的删除</h4><p>  假设对图9-3d的最大堆进行删除，需要删除的是元素21，这个时候只剩下5个元素，需要重新构建最大堆的结构，那么最终应该得到如图9-3a的最大堆形式。然后接下来要删除的是元素20，并得到如图9-4b所示的结构，则首先10从位置5移出，但将其放在根节点的位置得到的不是最大堆，则把根节点的两个孩子15和2中较大的一个放到根节点，然后假设将10插入位置2，但是还不是最大堆，因此将14上移到位置2,10放到位置4，得到如图9-4c所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%863.png" alt="此处输入图片的描述"></p>
<p>  删除策略如插入策略一样，从堆的根节点到叶节点只有单一路径，每层工作需耗时$\theta(1)$,因此实现此策略的时间复杂性是$O(height)=O(log_2n)$。</p>
<h4 id="u6700_u5927_u5806_u7684_u521D_u59CB_u5316"><a href="#u6700_u5927_u5806_u7684_u521D_u59CB_u5316" class="headerlink" title="最大堆的初始化"></a>最大堆的初始化</h4><p>  现在假设开始有数组a，它有n个元素，n=10，它可以用如图9-5a所示的完全二叉树表示，但它不是最大堆。为了将其转化为最大堆，从第一个具有孩子的节点开始（即节点10），<strong>这个元素在数组中的位置是$i=[n/2]$，如果以这个元素为根的子树已经是最大堆，则不需要调整，否则必须调整子树成为最大堆，然后继续检查$i-1,i-2,\ldots$等节点为根的子树，直到检查到根节点为止。</strong></p>
<p>  对图9-5a所示的完全二叉树，首先i=5，因为$10&gt;1$,所以以位置i为根的子树已经是最大堆，接下来检查位置4的子树，$15&lt;17$,它不是最大堆，将其变为最大堆，可得到如图9-5b所示，然后依次检查位置3，位置2以及根节点，分别得到如图9-5c，d所示的最大堆。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%864.png" alt="此处输入图片的描述"></p>
<h4 id="u7C7BMaxHeap"><a href="#u7C7BMaxHeap" class="headerlink" title="类MaxHeap"></a>类MaxHeap</h4><p>  下面程序给出最大堆的类定义。n是私有成员，代表目前堆中的元素的个数；MaxSize是堆的最大容量；heap是存储堆元素的数组，默认大小是10。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class MaxHeap&#123;&#10;private:&#10;    int CurrentSize, MaxSize;&#10;    T* heap;&#10;public:&#10;    MaxHeap(int MaxHeapSize = 10);&#10;    ~MaxHeap()&#123; delete[] heap; &#125;&#10;    int Size() const&#123; return CurrentSize; &#125;&#10;    T Max()&#123;&#10;        if (CurrentSize == 0)&#10;            throw OutOfBounds();&#10;        return heap[1];&#10;    &#125;&#10;    MaxHeap&#60;T&#62;&#38; Insert(const T&#38; x);&#10;    MaxHeap&#60;T&#62;&#38; DeleteMax(T&#38; x);&#10;    void Initialize(T a[], int size, int ArraySize);&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>下面给出最大堆的插入、删除和初始化代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;MaxHeap&#60;T&#62;&#38; MaxHeap&#60;T&#62;::Insert(const T&#38; x)&#123;&#10;    // &#23558;x&#25554;&#20837;&#21040;&#26368;&#22823;&#22534;&#20013;&#10;    if (CurrentSize == MaxSize)&#10;        throw NoMem();&#10;&#10;    // &#20026;x&#23547;&#25214;&#25554;&#20837;&#20301;&#32622;&#10;    int i = ++CurrentSize;&#10;    while (i != 1 &#38;&#38; x &#62; heap[i / 2])&#123;&#10;        // &#19981;&#33021;&#22815;&#23558;x&#25918;&#20837;heap[i]&#10;        heap[i] = heap[i / 2];  // &#23558;&#20803;&#32032;&#19979;&#31227;&#10;        i /= 2; // &#31227;&#21521;&#29238;&#33410;&#28857;&#10;    &#125;&#10;&#10;    heap[i] = x;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;MaxHeap&#60;T&#62;&#38; MaxHeap&#60;T&#62;::DeleteMax(T&#38; x)&#123;&#10;    // &#23558;&#26368;&#22823;&#20803;&#32032;&#25918;&#20837;x&#65292;&#24182;&#20174;&#22534;&#20013;&#21024;&#38500;&#26368;&#22823;&#20803;&#32032;&#10;    if (CurrentSize == 0)&#10;        throw OutOfBounds();&#10;&#10;    x = heap[1];    // &#26368;&#22823;&#20803;&#32032;&#10;&#10;    // &#37325;&#26500;&#22534;&#10;    T y = heap[CurrentSize--];  // &#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#10;&#10;    // &#20174;&#26681;&#24320;&#22987;&#65292;&#20026;y&#23547;&#25214;&#21512;&#36866;&#30340;&#20301;&#32622;&#10;    int i = 1, ci = 2;&#10;    while (ci &#60;= CurrentSize)&#123;&#10;        // heap[ci]&#24212;&#26159;i&#36739;&#22823;&#30340;&#23401;&#23376;&#10;        if (ci &#60; CurrentSize &#38;&#38; heap[ci] &#60; heap[ci + 1])&#10;            ci++;&#10;&#10;        // &#21028;&#26029;&#26159;&#21542;&#33021;&#23558;y&#25918;&#20837;heap[i]&#10;        if (y &#62;= heap[ci])&#10;            break;&#10;&#10;        // &#19981;&#33021;&#10;        heap[i] = heap[ci];&#10;        // &#19979;&#31227;&#19968;&#23618;&#10;        i = ci;&#10;        ci *= 2;&#10;    &#125;&#10;    heap[i] = y;&#10;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void MaxHeap&#60;T&#62;::Initialize(T a[], int size, int ArraySize)&#123;&#10;    // &#25226;&#26368;&#22823;&#22534;&#21021;&#22987;&#21270;&#20026;a&#10;    delete[] heap;&#10;    heap = new T[size + 1];&#10;    for (int s = 1; s &#60;= size; s++)&#123;&#10;        heap[s] = a[s - 1];&#10;    &#125;&#10;    CurrentSize = size;&#10;    MaxSize = ArraySize;&#10;&#10;    //&#20135;&#29983;&#19968;&#20010;&#26368;&#22823;&#22534;&#10;    for (int i = CurrentSize / 2; i &#62;= 1; i--)&#123;&#10;        T y = heap[i];&#10;&#10;        // &#23547;&#25214;&#25918;&#32622;y&#30340;&#20301;&#32622;&#10;        int c = 2 * i;&#10;        while (c &#60;= CurrentSize)&#123;&#10;            if (c &#60; CurrentSize&#38;&#38;heap[c] &#60; heap[c + 1])&#10;                c++;&#10;&#10;            if (y &#62;= heap[c])&#10;                break;&#10;&#10;            heap[c / 2] = heap[c];&#10;            c *= 2;&#10;        &#125;&#10;        heap[c / 2] = y;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入代码中，i从新创建的叶节点位置CurrentSize开始，对从该位置到根的路径进行遍历，对每个位置，都检查是否到达跟(i=1)或在i处插入新元素不会改变最大树的性质–$x \le heap[i/2]$，只要满足其中一个条件，就可以在i处插入x，否则会执行循环体中的代码。插入操作的时间复杂性是$O(logn)$。</p>
<p>删除操作的时间复杂性也是$O(logn)$。</p>
<p>初始化函数<strong>Initialize</strong>中for循环每次所花时间是$O(logn)$,循环次数是n/2，总的复杂性是$O(nlogn)$。实际应用中，初始化操作的复杂性是$\theta(n)$。</p>
<p>更完整的代码例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/PriorityQueue/MaxHeap.h" target="_blank" rel="external">最大堆的实现</a>。</p>
<h3 id="u5806_u6392_u5E8F"><a href="#u5806_u6392_u5E8F" class="headerlink" title="堆排序"></a>堆排序</h3><p>  利用堆来实现n个元素的排序，所需时间是$O(nlogn)$,可以将先要排序的n个元素初始化为一个最大堆，然后每次从堆中提取（即删除）元素，各元素将按递减次序排列。初始化所需要的时间是$\theta(n)$,每次删除所需要的时间是$O(logn)$,因此总时间是$O(nlogn)$。</p>
<p>实现代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void HeapSort(T a[], int n)&#123;&#10;    // &#21033;&#29992;&#22534;&#25490;&#24207;&#31639;&#27861;&#23545;a[1:n]&#36827;&#34892;&#25490;&#24207;&#10;    MaxHeap&#60;T&#62; H(1);&#10;    H.Initialize(a, n, n);&#10;&#10;    // &#20174;&#26368;&#22823;&#22534;&#20013;&#36880;&#20010;&#25277;&#21462;&#20803;&#32032;&#10;    T x;&#10;    for (int i=n - 1; i &#62;= 0; i--)&#123;&#10;        H.DeleteMax(x);&#10;        a[i] = x;&#10;    &#125;&#10;&#10;    // &#22312;&#22534;&#30340;&#26512;&#26500;&#20989;&#25968;&#20013;&#20445;&#23384;&#25968;&#32452;a&#10;    H.Deactivate();&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;&#10;    int a[] = &#123; 20, 12, 35, 15, 10, 80, 30, 17, 2, 1 &#125;;&#10;    HeapSort(a, 10);&#10;    for (int i = 0; i &#60; 10; i++)&#10;        cout &#60;&#60; a[i] &#60;&#60; &#34;, &#34;;&#10;&#10;    cout &#60;&#60; &#34;\n&#34;;&#10;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%865.png" alt="此处输入图片的描述"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本小节主要介绍的是优先队列的定义以及其中一种实现方法–最大堆的实现，最后是堆的一个应用–堆排序。</p>
<p>优先队列删除元素时根据优先权高或低的次序，而不是元素进行队列的次序，这与之前第六章介]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的基本概念和实现]]></title>
    <link href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://ccc013.github.io/2016/08/18/二叉树的基本概念和实现/</id>
    <published>2016-08-18T07:05:01.000Z</published>
    <updated>2016-08-18T07:05:37.766Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。</p>
</blockquote>
<p>在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的<strong>孩子(children)</strong>，而Joe是他们的<strong>父母(parent)</strong>。有相同父母的孩子是<strong>兄弟(sibling)</strong>。Ann，Mary,John都是兄弟。此外，还有其他术语：<strong>孙子(grandchild),祖父(grandparent),祖先(ancestor),后代(descendent)等</strong>。树中没有孩子的元素称为<strong>叶子(leaf)</strong>。图中Ann,Mark,Sue和Chris是树的叶子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>树的另一个常用术语是<strong>级(level)</strong>。指定树根的级是1，其孩子的级是2，依次类推。上图中Joe的级是1，而Ann，Mary,John的级是2，然后Mark,Sue,Chris的级是3。</p>
<p><strong>元素的度是指其孩子的个数。</strong>叶节点的度是0。<strong>树的度是其元素度的最大值</strong>。所以上图中的度是3。</p>
<h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p>定义：二叉树(binary tree)t是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个称为根的元素，余下的元素（如果有的话）被组成2个二叉树，分别称为t的左子树和右子树。</p>
</blockquote>
<p><strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树可以为空，树不能为空</li>
<li>二叉树中每个元素都恰好有两棵子树（其中一个或两个可能为空）。而树中每个元素可以有若干子树。</li>
<li>在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树间是无序的。</li>
</ul>
<p>下图给出了表示数学表达式的二叉树，总共有3个数学表达式。每个操作符可以有一个或两个操作数，左操作数是操作符的左子树，而右操作数则是右子树。树中的叶节点是常量或者变量。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h3 id="u4E8C_u53C9_u6811_u7684_u7279_u6027"><a href="#u4E8C_u53C9_u6811_u7684_u7279_u6027" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><blockquote>
<p><strong>特性1： 包含n(n&gt;0)个元素的二叉树边数是n-1。</strong></p>
</blockquote>
<p>证明 二叉树中每个元素 (除了根节点)有且只有一个父节点。在子节点与父节点间有且只有一条边，因此边数为n-1。</p>
<p><strong>二叉树的高度或者深度是指该二叉树的层数。</strong></p>
<blockquote>
<p><strong>特性2： 若二叉树的高度为h,$h \ge 0$,则该二叉树最少有h个元素，最多有$2^h - 1$个元素。</strong></p>
</blockquote>
<p>证明 因为每一层最少要有1个元素，因此元素数最少为h。每元素最多有2个子节点，则第i层节点元素最多为$2^i-1$个,i&gt;0。h=0时，元素的总数为0，也就是$2^0-1$。当h&gt;0时，元素的总数不会超过$\sum_{i=1}^h 2^{i-1}=2^h-1$。</p>
<blockquote>
<p><strong>特性3： 包含n个元素的二叉树的高度最大是n，最小是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
</blockquote>
<p>证明 因为每层至少有一个元素，因此高度不会超过n。由特性2，可以得知高度为h的二叉树最多有$2^h-1$个元素。因为$n \le 2^h-1$,因此$h \ge log_2(n+1)$。由于h是整数，所以$h \ge \left\lceil  log_2(n+1) \right\rceil$。</p>
<p><strong>当高度是h的二叉树恰好有$2^h - 1$个元素时，称其为满二叉树(full binary tree)。</strong>下图就是一个高度为4的满二叉树。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>假设对高度为h的满二叉树中的元素从上到下，从左到右的顺序进行从1到$2^h - 1$进行编号，如上图所示。假设从满二叉树中删除k个元素，其编号为$2^h - i, 1 \le i \le k$,所得到的二叉树称为<strong>完全二叉树(complete binary tree)</strong>。如下图给出的三棵完全二叉树。注意，<strong>满二叉树是完全二叉树的一个特例，并且有n个元素的完全二叉树的深度是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>在完全二叉树中，一个元素与其孩子的编号有非常好的对应关系。其关系在下面特性4中给出。</p>
<blockquote>
<p><strong>特性4： 设完全二叉树中一元素的序号是i，$1 \le i \le n$。则有以下关系成立：</strong><br>1) 当i=1时，该元素为二叉树的根，若i&gt;1,则该元素父节点的编号是$\left\lfloor i/2 \right\rfloor$。<br>2) 当2i&gt;n时，该元素没有左子树，否则，其左子树的编号是2i。<br>3) 若2i+1&gt;n时，该元素没有右子树，否则，其右子树的编号是2i+1。</p>
</blockquote>
<h3 id="u4E8C_u53C9_u6811_u63CF_u8FF0"><a href="#u4E8C_u53C9_u6811_u63CF_u8FF0" class="headerlink" title="二叉树描述"></a>二叉树描述</h3><h4 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h4><p>  二叉树的公式化描述利用特性4。二叉树可以作为缺少了部分元素的完全二叉树。下图给出了二叉树的两个例子。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  在公式化描述方法中，按照二叉树对元素的编号方法，将二叉树的元素存储在数组中。上图同时给出了二叉树的公式化描述，即图中右侧的数组表示。</p>
<p>  当缺少很多元素时，这种描述方法非常浪费空间。实际上，一个有n个元素的二叉树可能最多需要$2^n-1$的空间来存储。当每个节点都是其他节点的右孩子时，存储空间达到最大。如下图所示的一棵有四个元素的二叉树，这种类型的二叉树称为右斜二叉树。当缺少的元素比较少时，这种描述方法很有效。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h4 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h4><p>  <strong>二叉树最常用的描述方法是用链表或指针。</strong>每个元素都用一个有两个指针域的节点表示，这两个域是<strong>LeftChild和RightChild</strong>。除此两个指针域外，每个节点还有一个data域。其代码实现如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class BinaryTreeNode&#123;&#10;    friend void Visit(BinaryTreeNode&#60;T&#62; *);&#10;    friend void InOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void PreOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void PostOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void LevelOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void main(void);&#10;private:&#10;    T data;&#10;    BinaryTreeNode&#60;T&#62;* LeftChild, *RightChild;&#10;public:&#10;    BinaryTreeNode()&#123;&#10;        LeftChild = RightChild = 0;&#10;    &#125;&#10;    BinaryTreeNode(const T&#38; e)&#123;&#10;        data = e;&#10;        LeftChild = RightChild = 0;&#10;    &#125;&#10;    BinaryTreeNode(const T&#38;e, BinaryTreeNode *l, BinaryTreeNode* r)&#123;&#10;        data = e;&#10;        LeftChild = l;&#10;        RightChild = r;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的边可以用一个从父节点到子节点的指针来描述。指针放在父节点的指针域中，因为包括n个元素的二叉树恰有n-1条边，所以有<code>2n-(n-1)=n+1</code>个指针域没有值，这些域被值为0。下图给出了公式化描述中第一幅图的二叉树的链表描述。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>二叉树中不设置指向父节点的指针一般不会有什么问题，因为在二叉树的大部分函数中并不需要此指针。</p>
<h3 id="u4E8C_u53C9_u6811_u904D_u5386"><a href="#u4E8C_u53C9_u6811_u904D_u5386" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>  有四种遍历二叉树的方法：</p>
<ul>
<li><strong>前序遍历</strong></li>
<li><strong>中序遍历</strong></li>
<li><strong>后序遍历</strong></li>
<li><strong>逐层遍历</strong></li>
</ul>
<p>前3种遍历方法将在下面给出代码实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void PreOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    if (t)&#123;&#10;        // &#35775;&#38382;&#26681;&#33410;&#28857;&#10;        Visit(t);&#10;        // &#21069;&#24207;&#36941;&#21382;&#24038;&#23376;&#26641;&#10;        PreOrder(t-&#62;LeftChild);&#10;        // &#21069;&#24207;&#36941;&#21382;&#21491;&#23376;&#26641;&#10;        PreOrder(t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    if (t)&#123;&#10;        // &#20013;&#24207;&#36941;&#21382;&#24038;&#23376;&#26641;&#10;        InOrder(t-&#62;LeftChild);&#10;        Visit(t);&#10;        InOrder(t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void PostOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    if (t)&#123;&#10;        // &#21518;&#24207;&#36941;&#21382;&#24038;&#23376;&#26641;&#10;        PostOrder(t-&#62;LeftChild);&#10;        PostOrder(t-&#62;RightChild);&#10;        Visit(t);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三种方法，每个节点的左子树都在其右子树之前遍历。<strong>这三种遍历的区别在于对同一个节点在不同时刻进行访问。</strong>在进行前序遍历时，每个节点是在其左右子树被访问之前进行访问的；在中序遍历时，首先访问左子树，然后访问子树的根节点，最后访问右子树。在后序遍历时，当左右子树均访问完之后才访问子树的根节点。</p>
<p>下图给出上述三种方法对前文给出的数学表达式分别产生的结果，其中<code>Visit(t)</code>由<code>cout&lt;&lt; t-&gt;data;</code>代替。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>当对一棵数学表达式树进行前、中、后序遍历时，便分别得到表达式的前缀、中缀和后缀表达式。中缀（infix）形式就是平时书写的数学表达式。使用中缀形式的时候由于没有括号，可能会产生一些歧义，比如对于<code>x+y*z</code>，可以理解为<code>(x+y)*z</code>或者<code>x+(y*z)</code>，为了避免这种歧义，可以使用完全括号化的中缀表达式，每个操作符和相应的操作数都用一对括号括起来。下面是改进后的中序遍历算法的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Infix(BinaryTreeNode&#60;T&#62; *t)&#123;&#10;    // &#36755;&#20986;&#23436;&#20840;&#25324;&#21495;&#30340;&#20013;&#32512;&#34920;&#36798;&#24335;&#10;    if (t)&#123;&#10;        cout &#60;&#60; &#34;(&#34;;&#10;        // &#24038;&#25805;&#20316;&#25968;&#10;        Infix(t-&#62;LeftChild);&#10;        // &#25805;&#20316;&#31526;&#10;        cout &#60;&#60; t-&#62;data;&#10;        // &#21491;&#25805;&#20316;&#25968;&#10;        Infix(t-&#62;RightChild);&#10;        cout &#60;&#60; &#34;)&#34;;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在后缀(postfix)表达式中，每个操作符跟在操作数之后，操作数从左到右的顺序出现；在前缀(prefix)表达式中，操作符位于操作数之前。前缀和后缀表达式都不会存在歧义，不需要采用括号或者优先级。从左到右或者从右到左扫描表达式并采用操作数栈，可以很容易确定操作数和操作符的关系。若在扫描中遇到一个操作数，把它压入堆栈，遇到一个操作符，则将其与栈顶的操作数相匹配，把这些操作数推出栈，由操作符执行相应的计算，并将所得结果作为操作数压入堆栈。</p>
<p>逐层遍历就是<strong>按从顶层到底层的次序访问树中元素，在同一层中，从左到右进行访问。</strong>由于遍历中使用的是一个队列而不是栈，因此写一个按层遍历的递归程序很困难。下列程序是采用队列来实现对二叉树进行逐层遍历，队列中的元素指向二叉树节点，这里使用了之前<a href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%971-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">队列章节</a>中使用的类<strong>LinkedQueue</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void LevelOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#23545;*t&#36880;&#23618;&#36941;&#21382;&#10;    LinkedQueue&#60;BinaryTreeNode&#60;T&#62;*&#62;  Q;&#10;    while (t)&#123;&#10;        Visit(t);&#10;        // &#23558;t&#30340;&#21491;&#23401;&#23376;&#25918;&#20837;&#38431;&#21015;&#10;        if (t-&#62;LeftChild)&#10;            Q.Add(t-&#62;LeftChild);&#10;        if (t-&#62;RightChild)&#10;            Q.Add(t-&#62;RightChild);&#10;        // &#35775;&#38382;&#19979;&#19968;&#20010;&#33410;&#28857;&#10;        try&#123;&#10;            Q.Delete(t);&#10;        &#125;&#10;        catch (OutOfBounds)&#123;&#10;            return;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述程序中，首先仅当树非空时，才进入<code>while</code>循环。首先访问根节点，然后将其子节点加到队列中。当队列添加操作失败时，由Add会引发<code>NoMem</code>异常，由于没有捕捉该异常，所以发生该异常时函数将退出。在添加操作成功后，就进行从队列中删除t元素，如果成功，则删除的元素会返回到t中，这个删除的元素也就是下一个要访问的节点。下次访问该节点的时候，又会将其左右子树加入到队列的尾部，然后下一个要访问的就是根节点的右子树（如果存在），如此就可以实现逐层遍历了。而如果删除失败就表明队列为空，也就是意味着遍历的结束。</p>
<p>假设二叉树中元素的数目是<code>n</code>。这四种遍历算法的空间复杂性均为$O(n)$,时间复杂性是$\theta(n)$。当t的高度是n的时候，通过观察期前序、中序和后序遍历时所使用的递归栈空间可得到上述结论。当t是满二叉树的时候，逐层遍历所需要的队列空间是$\theta(n)$。每个遍历算法花在树中每个节点上的时间是$\theta(1)$(假设访问一个节点的时间是$\theta(1)$)。</p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578BBinaryTree"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578BBinaryTree" class="headerlink" title="抽象数据类型BinaryTree"></a>抽象数据类型BinaryTree</h3><p>  下面给出二叉树的抽象数据类型，这里只列出几个常用的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411; BinaryTree&#123;&#10;&#23454;&#20363;&#10;    &#20803;&#32032;&#38598;&#21512;&#65307;&#22914;&#26524;&#19981;&#31354;&#65292;&#21017;&#34987;&#21010;&#20998;&#20026;&#26681;&#33410;&#28857;&#12289;&#24038;&#23376;&#26641;&#21644;&#21491;&#23376;&#26641;&#65307;&#10;    &#27599;&#20010;&#23376;&#26641;&#20173;&#26159;&#19968;&#20010;&#20108;&#21449;&#26641;&#10;&#25805;&#20316;&#10;    Create()&#65306;&#21019;&#24314;&#19968;&#20010;&#31354;&#30340;&#20108;&#21449;&#26641;&#65307;&#10;    IsEmpty&#65306;&#22914;&#26524;&#20108;&#21449;&#26641;&#20026;&#31354;&#65292;&#21017;&#36820;&#22238; true &#65292;&#21542;&#21017;&#36820;&#22238;false&#10;    Root(x)&#65306;&#21462;x&#20026;&#26681;&#33410;&#28857;&#65307;&#22914;&#26524;&#25805;&#20316;&#22833;&#36133;&#65292;&#21017;&#36820;&#22238;false&#65292;&#21542;&#21017;&#36820;&#22238;true&#10;    MakeTree(root,left&#65292;right)&#65306;&#21019;&#24314;&#19968;&#20010;&#20108;&#21449;&#26641;&#65292;root&#20316;&#20026;&#26681;&#33410;&#28857;&#65292;left&#20316;&#20026;&#24038;&#23376;&#26641;&#65292; right&#20316;&#20026;&#21491;&#23376;&#26641;&#10;    BreakTree(root&#65292;left&#65292;right)&#65306;&#25286;&#20998;&#20108;&#21449;&#26641;&#10;    PreOrder&#65306;&#21069;&#24207;&#36941;&#21382;&#10;    InOrder&#65306;&#20013;&#24207;&#36941;&#21382;&#10;    PostOrder&#65306;&#21518;&#24207;&#36941;&#21382;&#10;    LevelOrder&#65306;&#36880;&#23618;&#36941;&#21382;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u7C7BBinaryTree"><a href="#u7C7BBinaryTree" class="headerlink" title="类BinaryTree"></a>类BinaryTree</h3><p>  下面给出类<strong>BinaryTree</strong>的C++定义。函数<strong>Visit</strong>作为遍历函数的参数，以实现不同操作的实现。该定义中使用了链表描述的二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class BinaryTree&#123;&#10;private:&#10;    BinaryTreeNode&#60;T&#62; *root;    // &#26681;&#33410;&#28857;&#25351;&#38024;&#10;    void PreOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t);&#10;    void Inorder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t);&#10;    void PostOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t);&#10;public:&#10;    BinaryTree()&#123; root = 0; &#125;&#10;    ~BinaryTree()&#123;&#125;;&#10;    bool IsEmpty() const&#123;&#10;        return ((root) ? false : true);&#10;    &#125;&#10;    bool Root(T&#38; x)const;&#10;    void MakeTree(const T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right);&#10;    void BreakTree(const T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right);&#10;    void PreOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u))&#123;&#10;        PreOrder(Visit, root);&#10;    &#125;&#10;    void Inorder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u))&#123;&#10;        Inorder(Visit, root);&#10;    &#125;&#10;    void PostOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u))&#123;&#10;        PostOrder(Visit, root);&#10;    &#125;&#10;    void LevelOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u));&#10;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面会给出共享成员函数<code>Root,MakeTree,BreakTree</code>的代码。函数<code>MakeTree</code>和<code>BreakTree</code>要求参与操作的三棵树应该互不相同，否则程序会得出错误的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;bool BinaryTree&#60;T&#62;::Root(T&#38; x)const&#123;&#10;    // &#21462;&#26681;&#33410;&#28857;&#30340;data&#22495;&#65292;&#25918;&#20837;x&#65292;&#22914;&#26524;&#27809;&#26377;&#21017;&#36820;&#22238;false&#10;    if (root)&#123;&#10;        x = root-&#62;data;&#10;        return true;&#10;    &#125;&#10;else&#10;    return false;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::MakeTree(const T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right)&#123;&#10;    // &#23558;left&#65292;right&#21644;element&#21512;&#24182;&#25104;&#19968;&#26869;&#26032;&#26641;&#65292;&#24182;&#19988;&#35201;&#27714;left&#21644;right&#21450;this&#24517;&#39035;&#26159;&#19981;&#21516;&#30340;&#26641;&#12290;&#10;&#10;    // &#21019;&#24314;&#26032;&#26641;&#10;    root = new BinaryTreeNode&#60;T&#62;(element, left.root, right.root);&#10;&#10;    // &#38459;&#27490;&#35775;&#38382;left&#21644;right&#10;    left.root = right.root = 0;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::BreakTree(T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right)&#123;&#10;    // left,right &#21644;this&#24517;&#39035;&#26159;&#19981;&#21516;&#30340;&#26641;&#10;    if (!root)&#10;        // &#31354;&#26641;&#10;        throw BadInput();&#10;&#10;    // &#20998;&#35299;&#26641;&#10;    element = root-&#62;data;&#10;    left.root = root-&#62;LeftChild;&#10;    right.root = root-&#62;RightChild;&#10;&#10;    delete root;&#10;    root = 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出四种遍历方法的实现代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::PreOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#21069;&#24207;&#36941;&#21382;&#10;    if (t)&#123;&#10;        Visit(t);&#10;        PreOrder(Visit, t-&#62;LeftChild);&#10;        PreOrder(Visit, t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::Inorder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#20013;&#24207;&#36941;&#21382;&#10;    if (t)&#123;&#10;        Inorder(Visit, t-&#62;LeftChild);&#10;        Visit(t);&#10;        Inorder(Visit, t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::PostOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#21518;&#24207;&#36941;&#21382;&#10;    if (t)&#123;&#10;        PostOrder(Visit, t-&#62;LeftChild);&#10;        PostOrder(Visit, t-&#62;RightChild);&#10;        Visit(t);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::LevelOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;* u))&#123;&#10;    // &#36880;&#23618;&#36941;&#21382;&#10;    LinkedQueue&#60;BinaryTreeNode&#60;T&#62;*&#62;Q;&#10;    BinaryTreeNode&#60;T&#62; *t;&#10;    t = root;&#10;    while (t)&#123;&#10;        Visit(t);&#10;        // &#23558;t&#30340;&#21491;&#23401;&#23376;&#25918;&#20837;&#38431;&#21015;&#10;        if (t-&#62;LeftChild)&#10;            Q.Add(t-&#62;LeftChild);&#10;        if (t-&#62;RightChild)&#10;            Q.Add(t-&#62;RightChild);&#10;        // &#35775;&#38382;&#19979;&#19968;&#20010;&#33410;&#28857;&#10;        try&#123;&#10;            Q.Delete(t);&#10;        &#125;&#10;        catch (OutOfBounds)&#123;&#10;            return;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是对类BinaryTree的简单应用，程序中构造了一个四节点的二叉树，并进行了前序遍历以确定书中的节点数目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#34;xcept.h&#34;&#10;#include&#34;BinaryTree.h&#34;&#10;&#10;using std::cout;&#10;using std::endl;&#10;using std::cin;&#10;&#10;int count = 0;&#10;BinaryTree&#60;int&#62;a, x, y, z;&#10;&#10;template&#60;class T&#62;&#10;void ct(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    count++;&#10;&#125;&#10;&#10;void main(void)&#123;&#10;    y.MakeTree(1, a, a);&#10;    z.MakeTree(2, a, a);&#10;    x.MakeTree(3, y, z);&#10;    y.MakeTree(4, x, a);&#10;    y.PreOrder(ct);&#10;    cout &#60;&#60;&#34;Tree y has &#34;&#60;&#60; count &#60;&#60;&#34; nodes&#34;&#60;&#60; endl;&#10;&#10;    system(&#34;pause&#34;);&#10;    return;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B_u53CA_u7C7B_u7684_u6269_u5145"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B_u53CA_u7C7B_u7684_u6269_u5145" class="headerlink" title="抽象数据类型及类的扩充"></a>抽象数据类型及类的扩充</h3><p>  本节将扩充之前给出的抽象数据类型，增加如下二叉树操作：</p>
<ul>
<li><strong>PreOutput():</strong>按前序方式输出数据域</li>
<li><strong>InOutput():</strong>按中序方式输出数据域</li>
<li><strong>PostOutput():</strong>按后序方式输出数据域</li>
<li><strong>LevelOutput():</strong>逐层输出数据域</li>
<li><strong>Delete():</strong>删除一棵二叉树，释放其节点</li>
<li><strong>Height():</strong>返回树的高度</li>
<li><strong>Size():</strong>返回树中节点数</li>
</ul>
<h4 id="u8F93_u51FA"><a href="#u8F93_u51FA" class="headerlink" title="输出"></a>输出</h4><p>  四个输出函数可以通过定义一个私有静态成员函数Output来实现，该函数代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void Output(BinaryTreeNode&#60;T&#62;*t)&#123;&#10;    cout &#60;&#60; t-&#62;data &#60;&#60; &#34;, &#34;;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而四个共享输出函数的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void PreOutput()&#123;&#10;    PreOrder(Output, root);&#10;    cout &#60;&#60; endl;&#10;&#125;&#10;void InOutput()&#123;&#10;    Inorder(Output, root);&#10;    cout &#60;&#60; endl;&#10;&#125;&#10;void PostOutput()&#123;&#10;    PostOrder(Output, root);&#10;    cout &#60;&#60; endl;&#10;&#125;&#10;void PreOutput()&#123;&#10;    LevelOrder(Output);&#10;    cout &#60;&#60; endl;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Visit操作的时间复杂性是$\theta(1)$,对包括n个节点的二叉树来说，每种遍历方法所花费的时间是$\theta(n)$(遍历成功的话），因此每种输出方法的时间复杂性均为$\theta(n)$。</p>
<h4 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h4><p>  要删除一棵二叉树，需要删除其所有节点，可以通过<strong>后序遍历</strong>在访问一个节点时，将其删除，也就是先删除左子树，然后右子树，最后删除根。因此函数<strong>Delete</strong>的形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Delete()&#123;&#10;    PostOrder(Free, root);&#10;    root = 0;&#10;&#125;&#10;static void Free(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    delete t;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中函数<strong>Free</strong>是一个私有成员函数。要删除的二叉树有n个节点时，<strong>Delete</strong>函数的时间复杂性是$\theta(n)$。</p>
<h4 id="u8BA1_u7B97_u9AD8_u5EA6"><a href="#u8BA1_u7B97_u9AD8_u5EA6" class="headerlink" title="计算高度"></a>计算高度</h4><p>  <strong>通过进行后序遍历，可以得到二叉树的高度。</strong>首先得到左子树的高度hl，然后得到右子树的高度hr，则树的高度为<strong>max{hl,hr}+1</strong>。</p>
<p>  但是这里不能使用之前定义的后序遍历代码，因为在进行遍历的时候需要有返回值（也就是子树的高度）。所以首先需要在增加一个共享成员函数Height,其代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Height() const&#123;&#10;    return Height(root);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后增加一个私有成员函数<strong>Height</strong>，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;int BinaryTree&#60;T&#62;::Height(BinaryTreeNode&#60;T&#62; *t)const&#123;&#10;    // &#36820;&#22238;&#26641;*t&#30340;&#39640;&#24230;&#10;    if (!t)&#10;        return 0;&#10;    // &#24038;&#23376;&#26641;&#39640;&#24230;&#10;    int hl = Height(t-&#62;LeftChild);&#10;    // &#21491;&#23376;&#26641;&#30340;&#39640;&#24230;&#10;    int hr = Height(t-&#62;RightChild);&#10;    if (hl &#62; hr)&#10;        return ++hl;&#10;    else&#10;        return ++hr;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数的时间复杂性是$\theta(n)$。</p>
<h4 id="u7EDF_u8BA1_u8282_u70B9_u6570"><a href="#u7EDF_u8BA1_u8282_u70B9_u6570" class="headerlink" title="统计节点数"></a>统计节点数</h4><p>  可以用上述四种遍历方法中的任何一种来获取二叉树中的节点数，因为每种遍历方法都对每个节点仅访问一次，只要在访问每个节点的时候将一个全局计数器加1即可。所以首先在类<strong>BinaryTree</strong>定义外定义一个全局变量：<code>int _count;</code>,然后增加一个共享成员函数<strong>Size</strong>和私有成员函数<strong>Add1</strong>，其代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void Add1(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    _count++;&#10;&#125;&#10;&#10;int Size()&#123;&#10;    _count = 0;&#10;    PreOrder(Add1, root);&#10;    return _count;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<strong>Size</strong>的时间复杂性是$\theta(n)$。</p>
<p>对于类<strong>BinaryTree</strong>的定义以及测试例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/BinaryTree" target="_blank" rel="external">二叉树</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节内容主要是介绍了树的基本概念以及二叉树的定义、特性和实现代码，包括四种遍历树的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳表&散列2-散列]]></title>
    <link href="http://ccc013.github.io/2016/08/07/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%972-%E6%95%A3%E5%88%97/"/>
    <id>http://ccc013.github.io/2016/08/07/跳表-散列2-散列/</id>
    <published>2016-08-07T10:38:48.000Z</published>
    <updated>2016-08-07T10:54:23.902Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节内容是介绍字典的另一种描述方法–散列。</p>
<h3 id="u6563_u5217_u8868_u63CF_u8FF0"><a href="#u6563_u5217_u8868_u63CF_u8FF0" class="headerlink" title="散列表描述"></a>散列表描述</h3><h4 id="u7406_u60F3_u6563_u5217"><a href="#u7406_u60F3_u6563_u5217" class="headerlink" title="理想散列"></a>理想散列</h4><blockquote>
<p>字典的另一种描述方法就是<strong>散列（hash）</strong>，它是用一个散列函数（hash function）把关键字映射到散列表（hash table）中的特定位置。</p>
</blockquote>
<p>也就是使用哈希表来描述字典了。</p>
<p>在理想情况下，如果元素e的关键字是k，散列函数是f，那么e在散列表中的位置为$f(k)$。要搜索关键字为k的元素，首先要计算出$f(k)$，然后看$f(k)$处是否有元素，如果有，则找到该元素，如果没有，说明该字典中不包含该元素。在前一种情况中，如果要删除该元素，只需要把表中$f(k)$位置置为空即可，在后一种情况中，可以通过把元素放在$f(k)$位置以实现插入。</p>
<p>理想情况下，初始化一个空字典需要的时间为$\theta(b)$(b是散列表中位置的个数），搜索、插入和删除操作的时间均为$\theta(1)$。在许多场合都可以使用理想的散列方法，但对于关键字变化范围太大的应用是不能创建这样一个散列表的。</p>
<h4 id="u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u6563_u5217"><a href="#u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u6563_u5217" class="headerlink" title="线性开型寻址散列"></a>线性开型寻址散列</h4><p>  当关键字的范围太大，不能用理想方法表示时，可以采用比关键字范围小的散列表以及把多个关键字映射到同一个位置的散列函数。虽然有多种函数映射方法，但最常用的还是<strong>除法映射</strong>。其形式如下：<br>$$<br>f(k) = k \% D<br>$$<br>其中k是关键字，而D是散列表的大小，也就是位置数，而%是求模操作符。散列表中的位置号从0到D-1，每一个位置称为<strong>桶（bucket）</strong>。若关键字不是正整数型（如int，long,char, unsigned char等），则在计算f(k)之前必须把它转换成非负整数。对于一个长字符串，可以采用取其2个或4个字母来变成无符号整数或无符号长整数的方法。f(k)是存储关键字为k的元素的<strong>起始桶</strong>，在良性情况下，起始桶中存储的元素即是关键字为K的元素。</p>
<p>下图中给出一个散列表ht，桶号从0到10，在图a中，表中只有3个元素，除数D是11，由于80%11=3，所以80的位置是3,40%11=7,65%11=10，每个元素都在相应的桶中，散列表中余下的桶为空。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%971.png" alt="此处输入图片的描述"></p>
<p>现在假设要插入58,58的起始桶应该是f(58)=58%11=3,但是此时该桶中已经放了80了，这个时候就发生了<strong>碰撞</strong>。一般来说，一个桶中是可以存储多个元素的，而存储桶中若没有空间就发生<strong>溢出</strong>。但在我们的表中，每个桶只能存储一个元素，因此同时发生了碰撞和溢出。这个时候处理58的最简单的办法就是将其存储到表中下一个可用的桶中，这种解决溢出的方法叫做<strong>线性开型寻址(linear open addressing)</strong>。</p>
<p>因此如图b所示，将58存放在4号桶中。假设下一个要插入的元素值是24，其起始桶应该是2，然后就放入2号桶中，然后要插入35，其起始桶是2号，使用线性开型寻址的方法，它将被放入5号桶，最后一个要插入的是98，而10号桶已经满了，此时它被插入0号桶中。<strong>因此，在寻找下一个可用桶时，表被视为环形的。</strong></p>
<p>下面给出采用线性开型寻址的散列表的类定义。在类定义中假定散列表中每个元素的类型都是E，每个元素都有一个类型为K的key域。key域是用来计算起始桶的，因此类型K必须能够适应取模操作%。散列表使用了两个数组，ht和empty。当且仅当ht[i]中不含有元素时，empty[i]为true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;class HashTable&#123;&#10;private:&#10;    int hSearch(const K&#38; k)const;&#10;    // &#25955;&#21015;&#20989;&#25968;&#30340;&#38500;&#25968;&#10;    int D;&#10;    // &#25955;&#21015;&#25968;&#32452;&#10;    E *ht;&#10;    // &#19968;&#32500;&#25968;&#32452;&#10;    bool *empty;&#10;public:&#10;    HashTable(int divisor = 11);&#10;    ~HashTable()&#123; &#10;        delete[] ht;&#10;        delete[] empty;&#10;    &#125;&#10;    bool Search(const K&#38; k, E&#38; e)const;&#10;    HashTable&#60;E, K&#62;&#38; Insert(const E&#38;e);&#10;    HashTable&#60;E, K&#62;&#38; Delete(const K&#38;k, E&#38; e);&#10;    void Output(std::ostream&#38;);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索操作的实现，对于私有成员<strong>hSearch</strong>会返回b号桶的三种情况有：1）<code>empty[b] == false &amp;&amp; ht[b] == k</code>；2）<code>empty[b] == true</code>，即表中没有关键字值为k的元素；3）<code>empty[b] == true &amp;&amp; ht[b] != k</code>,且表已满。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;int HashTable&#60;E, K&#62;::hSearch(const K&#38; k)const&#123;&#10;    // &#26597;&#25214;&#19968;&#20010;&#24320;&#22320;&#22336;&#34920;&#65292;&#22914;&#26524;&#23384;&#22312;&#65292;&#36820;&#22238;k&#30340;&#20301;&#32622;&#65292;&#21542;&#21017;&#36820;&#22238;&#25554;&#20837;&#28857;&#65288;&#22914;&#26524;&#26377;&#36275;&#22815;&#31354;&#38388;&#65289;&#10;    // &#36215;&#22987;&#26742;&#10;    int i = k % D;&#10;    // &#22312;&#36215;&#22987;&#26742;&#24320;&#22987;&#10;    int j = i;  &#10;    do&#123;&#10;        if (empty[j] || ht[j] == k)&#10;            return j;&#10;        // &#19979;&#19968;&#20010;&#26742;&#10;        j = (j + 1) % D;&#10;    &#125; while (j != i); // j== i &#34920;&#31034;&#22238;&#21040;&#36215;&#22987;&#26742;&#10;&#10;    // &#34920;&#24050;&#32463;&#28385;&#10;    return j;&#10;&#125;&#10;&#10;template&#60;class E, class K&#62;&#10;bool HashTable&#60;E, K&#62;::Search(const K&#38; k, E&#38; e)const&#123;&#10;    // &#25628;&#32034;&#19982;k&#30456;&#21305;&#37197;&#30340;&#20803;&#32032;&#24182;&#25918;&#20837;e&#65292;&#22914;&#26524;&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238;false;&#10;    int b = hSearch(k);&#10;    if (empty[b] || ht[b] != k)&#10;        return false;&#10;    e = ht[b];&#10;    return true;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入和删除操作如下，其中书中没有实现删除操作，而是作为课后练习题，所以删除操作是自己实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;HashTable&#60;E, K&#62;&#38; HashTable&#60;E, K&#62;::Insert(const E&#38; e)&#123;&#10;    // &#22312;&#25955;&#21015;&#34920;&#20013;&#25554;&#20837;&#19968;&#20010;&#20803;&#32032;&#10;    K k = e;&#10;    int b = hSearch(k);&#10;&#10;    // &#26816;&#26597;&#26159;&#21542;&#33021;&#23436;&#25104;&#25554;&#20837;&#10;    if (empty[b])&#123;&#10;        empty[b] = false;&#10;        ht[b] = e;&#10;        return *this;&#10;    &#125;&#10;&#10;    // &#19981;&#33021;&#25554;&#20837;&#65292;&#26816;&#26597;&#26159;&#21542;&#26377;&#37325;&#22797;&#20540;&#25110;&#32773;&#34920;&#28385;&#10;    if (ht[b] == k)&#123;&#10;        std::cerr &#60;&#60; &#34;The key &#34; &#60;&#60; k &#60;&#60; &#34; already in the HashTable\n&#34;;&#10;        return *this;&#10;    &#125;&#10;    else&#123;&#10;        std::cerr &#60;&#60; &#34;The  HashTable is full.\n&#34;;&#10;        return *this;&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class E, class K&#62;&#10;HashTable&#60;E, K&#62;&#38; HashTable&#60;E, K&#62;::Delete(const K&#38; k, E&#38; e)&#123;&#10;    // &#21024;&#38500;&#19982;k&#30456;&#21305;&#37197;&#30340;&#20803;&#32032;&#65292;&#24182;&#25918;&#20837;e&#10;    int b = hSearch(k);&#10;&#10;    // &#26816;&#26597;&#26159;&#21542;&#33021;&#36827;&#34892;&#21024;&#38500;&#25805;&#20316;&#10;    if (empty[b])&#123;&#10;        std::cerr &#60;&#60; &#34;The key &#34; &#60;&#60; k &#60;&#60; &#34; is not in the HashTable\n&#34;;&#10;        return *this;&#10;    &#125;&#10;&#10;    // &#21487;&#20197;&#21024;&#38500;&#10;    e = ht[b];&#10;    empty[b] = true;&#10;    ht[b] = 0;&#10;    int i = b;&#10;    int j = (b+1) % D;&#10;    // &#20174;&#19979;&#19968;&#20010;&#26742;&#24320;&#22987;&#25628;&#32034;&#26159;&#21542;&#23384;&#22312;&#21478;&#19968;&#20010;&#36215;&#22987;&#26742;&#19968;&#26679;&#30340;&#20803;&#32032;&#10;    do&#123;&#10;        if (!empty[j])&#123;&#10;            if (ht[j] % D == i)&#123;&#10;                empty[i] = false;&#10;                ht[i] = ht[j];&#10;                empty[j] = true;&#10;                ht[j] = 0;&#10;                i = j;&#10;            &#125;&#10;        &#125;&#10;        j = (j + 1) % D;&#10;    &#125; while (j != b || empty[j]);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>更详细的例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/HashTable.h" target="_blank" rel="external">字典–哈希表实现</a></p>
<p>设b是散列表中桶的个数，散列函数中D为除数，且b=D。初始化表的时间是$\theta(b)$。当表中有n个元素时，最坏情况下插入和搜索时间均为$\theta(n)$。而当所有n个关键字值都在同一个桶中时出现最坏的情况。通过比较散列在最坏情况下的复杂性与线性表在最坏情况下的复杂性，可以看到两者完全相同。</p>
<p>但散列的平均性能还是相当好的。用$S_n$和$U_n$来分别表示一次成功搜索和不成功搜索中平均搜索的桶的个数。对于线性开型寻址，有如下公式成立：<br>$$<br>U_n \sim \frac{1}{2} (1+\frac{1}{(1-\alpha)^2}) \<br>S_n \sim \frac{1}{2} (1+\frac{1}{1-\alpha})<br>$$<br>其中$\alpha = \frac{n}{b}$是负载因子。</p>
<p>所以若$\alpha =0.5$，则在不成功搜索时平均搜索的桶的个数为2.5个，而成功搜索时则是1.5个。当$\alpha =0.8$，则是50.5和5.5。所以当负载因子为0.5时，使用线性开型寻址散列表的平均性能要比线性表好。</p>
<p>另一个影响性能的参数是D。<strong>当D是素数或者D没有小于20的素数因子时，可以使性能达到最佳（D等于桶的个数b）</strong>。</p>
<p>而确定D的值，首先要了解影响成功搜索和不成功搜索性能的因素。通过$S_n$和$U_n$的公式，可以确定$\alpha$的值,然后再结合n的值，可以得到b的最小许可值，然后找到一个比b大的最小整数，这个整数要么是素数，要么没有小于20的素数因子，这个整数即可作为D和b的值。</p>
<p>另一种计算D的方法是首先根据散列表的最大空间来确定b的最大可能值，然后取D为不大于这个最大值的整数，该整数要么是素数，要么没有小于20的素数因子。例如，如果在表中最多可以分配530个桶，则D和b的最佳选择为23(因23*23=529)。</p>
<h4 id="u94FE_u8868_u6563_u5217"><a href="#u94FE_u8868_u6563_u5217" class="headerlink" title="链表散列"></a>链表散列</h4><p>  当散列发生溢出的时候，链表是一种好的解决方法。下图给出了散列表在发生溢出时采用链表来进行解决的方法。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%972.png" alt="此处输入图片的描述"></p>
<p>  在该散列表的组织中，每个桶仅含有一个节点指针，所有的元素都是存储在该指针所指向的链表中。</p>
<p>  下面给出代码实现，该类使用了类<strong>SortedChain</strong>的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;class ChainHashTable&#123;&#10;private:&#10;    // &#20301;&#32622;&#25968;&#10;    int D;&#10;    // &#38142;&#34920;&#25968;&#32452;&#10;    SortedChain&#60;E, K&#62;* ht;&#10;public:&#10;    ChainHashTable(int divisor = 11)&#123;&#10;        D = divisor;&#10;        ht = new SortedChain&#60;E, K&#62;[D];&#10;    &#125;&#10;    ~ChainHashTable()&#123;&#10;        delete[] ht;&#10;    &#125;&#10;    bool Search(const K&#38;k, E&#38; e)const&#123;&#10;        return ht[k%D].Search(k, e);&#10;    &#125;&#10;    ChainHashTable&#60;E, K&#62;&#38; Insert(const K&#38; k, E&#38; e)&#123;&#10;        ht[k%D].DistinctInsert(k, e);&#10;        return *this;&#10;    &#125;&#10;    ChainHashTable&#60;E, K&#62;&#38; Delete(const K&#38; k, E&#38; e)&#123;&#10;        ht[k%D].Delete(k, e);&#10;        return *this;&#10;    &#125;&#10;    void Output(std::ostream&#38;) const;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>一种改进方法是在每条链表中添加一个尾节点，尾节点中的关键字值最起码要比散列中所有元素的关键字值都大。</strong>如下图所示。在实际实现的过程中，所有的链表可以共用同一个尾节点。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%973.png" alt="此处输入图片的描述"></p>
<h4 id="u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u4E0E_u94FE_u8868_u6563_u5217_u7684_u6BD4_u8F83"><a href="#u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u4E0E_u94FE_u8868_u6563_u5217_u7684_u6BD4_u8F83" class="headerlink" title="线性开型寻址与链表散列的比较"></a>线性开型寻址与链表散列的比较</h4><p>  将线性开型寻址与没有尾节点的链表散列进行比较。令s为每个元素需占用的空间（以字节为单位），每个指针和每个整数类型的变量各占用2个字节空间。同时，设散列表中有b个桶和n个元素。首先注意到使用线性开型寻址时有$n \le b$,而使用链表散列则是n可能大于b。</p>
<p>  采用线性开型寻址所需要的空间为$b(s+2)$个字节，其中s为每个元素所占用的字节数。而使用链表所需要的空间为$2b+2n+ns$字节，当$n \lt \frac{bs}{s+2}$时，链表所用的空间要比开型寻址少。</p>
<p>  在最坏情况下，两种方法进行搜索，都需要搜索所有的n个元素。链表散列的平均搜索次数，其一次不成功搜索和一次成功搜索的平均搜索的桶数如下公式所示：<br>$$<br>U_n   \sim \frac{\alpha+1}{2},\alpha \ge 1 \<br>S_n   \sim 1+\frac{\alpha}{2}<br>$$</p>
<p>将线性开型寻址的公式与链表散列的公式相比较，可以看到使用链表时的平均性能要优于使用线性开型寻址。例如，当$\alpha = 0.9$时，链表散列的一次不成功搜索，平均需要检查0.95个元素，一次成功搜索需要检查1.45个元素。而对于线性开型寻址，则是分别为50.5个5.5个元素。</p>
<h4 id="u6563_u5217_u4E0E_u8DF3_u8868_u6BD4_u8F83"><a href="#u6563_u5217_u4E0E_u8DF3_u8868_u6BD4_u8F83" class="headerlink" title="散列与跳表比较"></a>散列与跳表比较</h4><p>  散列与跳表均使用了随机过程来提高字典操作的性能。<strong>使用跳表时，插入操作用随机过程来决定一个元素的级数。</strong>这种级数分配不需要考虑插入元素的值。<strong>在散列中，当对不同元素进行插入时，散列函数随机地位不同元素分配桶，但散列函数需要使用元素的值。</strong></p>
<p>  <strong>通过使用随机过程，跳表和散列操作的平均复杂性分别为对数时间和常数时间。</strong>跳表的最坏时间复杂性为$(n+ MaxLevel)$，而散列的最坏时间复杂性为$\theta(n)$ 。跳表中指针平均占用的空间约为$Maxlevel+\frac{n}{1-p}$，在最坏情况下可能相当大。链表散列的指针所占用的空间为$D+n$。</p>
<p>不过，跳表比散列更灵活。例如，只需简单地沿着0级链就可以在线性时间内按升序输出所有的元素。而采用链表散列时，需要$\theta(D+n)$时间去收集n个元素并且需要$O(nlogn)$时间进行排序，之后才能输出。对于其他的操作，如查找或删除最大或最小元素，散列可能要花费更多的时间（仅考虑平均复杂性）。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节介绍了字典的另一种实现方法–散列的实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节内容是介绍字典的另一种描述方法–散列。</p>
<h3 id="u6563_u5217_u8868_u63CF_u8FF0"><a href="#u6563_u5217_u8868_u63C]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳表&散列1-字典&跳表]]></title>
    <link href="http://ccc013.github.io/2016/07/27/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%971-%E5%AD%97%E5%85%B8-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/07/27/跳表-散列1-字典-跳表/</id>
    <published>2016-07-27T14:09:02.000Z</published>
    <updated>2016-07-27T14:09:50.820Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节会介绍字典和跳表。</p>
<p>对于一个有n个元素的有序数组，用折半搜索法进行搜索需要的时间是$O(logn)$,而对一个有序链表进行搜索所需要的时间是$O(n)$。我们可以通过对有序链表上的全部或部分节点增加额外的指针，来提供搜索性能。在搜索时，可以通过这些指针来跳过链表中若干个节点，因此没有必要从左到右搜索链表中的所有节点。</p>
<p><strong>增加了向前指针的链表叫做跳表。</strong>跳表采用随机技术决定链表中哪些节点应增加向前指针以及在节点中应增加多少个指针。采用这种随机技术，跳表中的搜索、插入和删除操作的时间均为$O(logn)$,然而，最坏情况下下时间复杂性却变成$\theta(n)$。而在一个有序数组或链表中进行插入/删除操作的时间为$O(n)$,最坏情况下为$\theta(n)$。</p>
<p><strong>散列法是用来搜索、插入和删除记录的另一种随机方法</strong>。与跳表相比，它的插入/删除操作时间提高到$\theta(1)$,最坏情况下仍为$\theta(n)$。尽管如此，在经常将所有元素按序输出或按序号搜索元素时，跳表的执行效率将优于散列。</p>
<h3 id="u5B57_u5178"><a href="#u5B57_u5178" class="headerlink" title="字典"></a>字典</h3><blockquote>
<p>字典(dictionary)是一些元素的集合。每个元素有一个称作key的域，不同元素的key各不相同。</p>
</blockquote>
<p>抽象数据类型如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411;Dictionary&#123;&#10;&#23454;&#20363;&#10;    &#20855;&#26377;&#19981;&#21516;&#20851;&#38190;&#23383;&#30340;&#20803;&#32032;&#38598;&#21512;&#10;&#25805;&#20316;&#10;    Create(): &#21019;&#24314;&#19968;&#20010;&#31354;&#23383;&#20856;&#10;    Search(k,x): &#25628;&#32034;&#20851;&#38190;&#23383;&#20026;k&#30340;&#20803;&#32032;&#65292;&#32467;&#26524;&#25918;&#20837;x;&#22914;&#26524;&#27809;&#25214;&#21040;&#65292;&#21017;&#36820;&#22238;false&#65292;&#21542;&#21017;&#36820;&#22238;true&#65307;&#10;    Insert(x): &#21521;&#23383;&#20856;&#20013;&#25554;&#20837;&#20803;&#32032;x&#10;    Delete(k,x): &#21024;&#38500;&#20851;&#38190;&#23383;&#20026;k&#30340;&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#25918;&#20837;x&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>若仅按照一个字典元素本身的关键字来访问该元素，则称为<strong>随机访问</strong>；而<strong>顺序访问</strong>是指按照关键字的递增顺序逐个访问字典中的元素。顺序访问需要借助于<strong>Begin(用来返回关键字最小的元素</strong>和<strong>Next（用来返回下一个元素）</strong>等操作来实现。</p>
<p>在有重复元素的字典与上述抽象数据类型定义的字典相似，只是它允许有相同的关键字。在有重复关键字的字典中，在搜索和删除时需要一个规则来消除歧义。也就是说，如果搜索或删除关键字为k的元素，那么在所有关键字为k的元素中应该返回或者删除哪一个。在有些字典应用中，可能需要，删除在某个时间以后插入的所有元素。</p>
<h3 id="u7EBF_u6027_u8868_u63CF_u8FF0"><a href="#u7EBF_u6027_u8868_u63CF_u8FF0" class="headerlink" title="线性表描述"></a>线性表描述</h3><p>  字典可以保存在线性序列($e_1,e_2,\cdots$)中，其中$e_i$是字典中的元素，其关键字从左到右依次增大。这里可以根据公式化描述或者链表描述自定义类SortedList和SortedChain。</p>
<p>  下面给出的是类SortedChain的定义。E表示链表元素的数据类型，K是链表中排序用到的关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SORTEDCHAIN_H_&#10;#define SORTEDCHAIN_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class E,class K&#62;&#10;class SortedChainNode&#123;&#10;    friend SortedChain&#60;E, K&#62;;&#10;private:&#10;    K key;&#10;    E data;&#10;    SortedChainNode&#60;E,K&#62; * link;&#10;&#125;;&#10;&#10;template&#60;class E, class K&#62;&#10;class SortedChain&#123;&#10;private:&#10;    SortedChainNode&#60;E, K&#62;* first;&#10;public:&#10;    SortedChain()&#123; first = 0; &#125;&#10;    ~SortedChain();&#10;    bool IsEmpty() const &#123; return first == 0; &#125;&#10;    int Length() const;&#10;    bool Search(const K&#38; k, E&#38; e)const;&#10;    SortedChain&#60;E, K&#62;&#38; Delete(const K&#38; k, E&#38;e);&#10;    SortedChain&#60;E, K&#62;&#38; Insert(const E&#38; e);&#10;    SortedChain&#60;E, K&#62;&#38; DistinctInsert(const K&#38; k, const E&#38; e);&#10;    void Output(std::ostream&#38;) const;&#10;&#125;;&#10;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索和删除操作的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;bool SortedChain&#60;E, K&#62;::Search(const K&#38; k, E&#38; e)const&#123;&#10;    // &#25628;&#32034;&#19982;k&#21305;&#37197;&#30340;&#20803;&#32032;&#65292;&#32467;&#26524;&#25918;&#20837;e&#65292;&#22914;&#26524;&#27809;&#26377;&#21305;&#37197;&#30340;&#20803;&#32032;&#65292;&#21017;&#36820;&#22238;false&#10;&#10;    SortedChainNode&#60;E, K&#62;* p = first;&#10;&#10;    // &#25628;&#32034;&#19982;K&#30456;&#21305;&#37197;&#30340;&#20803;&#32032;&#10;    for (; p&#38;&#38; p-&#62;key != k; p = p-&#62;link)&#123;&#10;    &#125;&#10;    if (p&#38;&#38;p-&#62;key == k)&#123;&#10;        e = p-&#62;data;&#10;        return true;&#10;    &#125;&#10;    else&#123;&#10;        std::cout &#60;&#60; &#34;There is no key--&#34; &#60;&#60; k &#60;&#60; &#34; in sortedChain\n&#34;;&#10;    &#125;&#10;    return false;&#10;&#125;&#10;&#10;template&#60;class E, class K&#62;&#10;SortedChain&#60;E, K&#62;&#38; SortedChain&#60;E, K&#62;::Delete(const K&#38; k, E&#38; e)&#123;&#10;    // &#21024;&#38500;&#19982;k&#30456;&#21305;&#37197;&#30340;&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#25918;&#20837;e&#10;&#10;    SortedChainNode&#60;E, K&#62;* p = first;&#10;    // &#36319;&#36394;p&#10;    SortedChainNode&#60;E, K&#62;* tp = 0;&#10;&#10;    for (; p &#38;&#38; p-&#62;key != k; tp = p, p = p-&#62;link)&#123;&#10;    &#125;&#10;&#10;    if (p &#38;&#38; p-&#62;key == k)&#123;&#10;        e = p-&#62;data;&#10;        // &#20174;&#38142;&#34920;&#20013;&#21024;&#38500;p&#25152;&#25351;&#21521;&#30340;&#20803;&#32032;&#10;        if (tp)&#10;            tp-&#62;link = p-&#62;link;&#10;        else&#10;            // p&#26159;&#38142;&#34920;&#39318;&#33410;&#28857;&#10;            first = p-&#62;link;&#10;        &#10;        delete p;   &#10;    &#125;else&#10;        std::cout &#60;&#60; &#34;There is no key--&#34; &#60;&#60; k &#60;&#60; &#34; in sortedChain\n&#34;;&#10;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入操作如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;SortedChain&#60;E, K&#62;&#38; SortedChain&#60;E, K&#62;::DistinctInsert(const K&#38; k,const E&#38; e)&#123;&#10;    // &#22914;&#26524;&#34920;&#20013;&#19981;&#23384;&#22312;&#20851;&#38190;&#20540;&#19982;e&#30456;&#21516;&#30340;&#20803;&#32032;&#65292;&#21017;&#25554;&#20837;e&#65292;&#21542;&#21017;&#24341;&#21457;&#24322;&#24120;BadInput&#10;&#10;    SortedChainNode&#60;E, K&#62;* p = first;&#10;    // &#36319;&#36394;p&#10;    SortedChainNode&#60;E, K&#62;* tp = 0;&#10;&#10;    // &#31227;&#21160;tp&#20197;&#20415;&#25226;e&#25554;&#20837;&#21040;tp&#20043;&#21518;&#10;    for (; p &#38;&#38; p-&#62;key != k; tp = p, p = p-&#62;link);&#10;&#10;    if (p &#38;&#38; p-&#62;key == k)&#123;&#10;        std::cout &#60;&#60; &#34;There is already key--&#34; &#60;&#60; k &#60;&#60; &#34; in sortedChain,please choose another key.\n&#34;;&#10;        return *this;&#10;    &#125;&#10;&#10;    // &#33509;&#27809;&#26377;&#20986;&#29616;&#37325;&#22797;&#20851;&#38190;&#20540;&#65292;&#21017;&#20135;&#29983;&#19968;&#20010;&#20851;&#38190;&#20540;&#20026;e&#30340;&#26032;&#33410;&#28857;&#10;    SortedChainNode&#60;E, K&#62;* q = new SortedChainNode&#60;E, K&#62;;&#10;    q-&#62;data = e;&#10;    q-&#62;key = k;&#10;    // &#23558;&#26032;&#33410;&#28857;&#25554;&#20837;&#21040;tp&#20043;&#21518;&#10;    q-&#62;link = p;&#10;    if (tp)&#10;        tp-&#62;link = q;&#10;    else&#10;        first = q;&#10;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>类SortedChain提供了两种插入操作，上述<code>DistinctInset</code>操作保证链中所有元素有不同的关键字，而<code>Insert</code>允许有相同的关键字。</p>
<p>更详细的内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/SortedChain.h" target="_blank" rel="external">字典–链表实现</a></p>
<h3 id="u8DF3_u8868_u63CF_u8FF0"><a href="#u8DF3_u8868_u63CF_u8FF0" class="headerlink" title="跳表描述"></a>跳表描述</h3><h4 id="u7406_u60F3_u60C5_u51B5"><a href="#u7406_u60F3_u60C5_u51B5" class="headerlink" title="理想情况"></a>理想情况</h4><p>  在一个有序链表描述的具有n个元素的字典中进行搜索，至多需要进行n次比较，而如果在链表中部节点加一个指针，则比较次数可以减少到$\frac{n}{2}+1$。搜索的时候，首先将欲搜索元素与中间元素进行比较，如果欲搜索的元素较小，则仅需搜索链表的左半部分，否则，只需搜索链表的右半部分。</p>
<p>  如下图a所示是一个有序链表的七个元素，它有一个头节点和一个尾节点。节点中的数是该节点的值。对该链表搜索可能需要进行7次比较。如果使用图b的方法，在中间增加一个指针，则最坏情况下比较次数减少到4次。</p>
<p>  还可以像图c中一样，再在左半部分和右半部分各增加一个指针，这样可以进一步减少最坏情况下的比较次数。在该图中有3条链，0级链就是图a中的初始链，1级链包括第二，四，六个元素，而2级链只包括第四个元素。</p>
<p>  一个例子是要查找元素77，首先会跟40相比，由于$70 \gt 40$,则在1级链中与75比较，然后$77 \gt 75$，因此在0级链中与80比较，此时可以知道77不在字典中。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E8%B7%B3%E8%A1%A81.png" alt="此处输入图片的描述"></p>
<p>  <strong>通常0级链包括n个元素，1级链包括$\frac{n}{2}$个元素，2级链包括$\frac{n}{4}$个元素，而每$2^i$个元素就有一个i级链指针。当且仅当一个元素在0~i级链上，但不在i+1级（若该链存在）链上时，我们就是说该元素是i级链元素</strong>。所以图c中，40是2级链上唯一的元素，75是1级链元素，20、30、60、80是0级链元素。</p>
<p>  图c所示的结构就是<strong>跳表（skip list）</strong>。在该结构中有一组有层次的链。0级链式包含所有元素的有序链表，1级链是0级链的一个子集。<strong>i级链是i-1级链的子集</strong>。</p>
<h4 id="u63D2_u5165_u548C_u5220_u9664"><a href="#u63D2_u5165_u548C_u5220_u9664" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>  在进行插入和删除时，要想保持上图c的跳表结构，必须耗时$O(n)$。注意到在这种结构中，有<strong>$\frac{n}{2^i}$个元素为i级链元素</strong>，所以在进行插入时应尽量逼近这种结构。在进行插入时，新元素属于i级链的概率为$\frac{1}{2^i}$。在确定新元素的级时，应考虑各种可能的情况。因此，把新元素作为i级链元素的可能性为$p^i$,图c中p=0.5。对于一般的p，链的级数为$\lfloor (log_{\frac{1}{p}}n) \rfloor + 1$,在这种情况下，每p个i-1级链就有一个在i级链中。</p>
<p>  上图d是插入元素77的示例，新元素插在75和80之间，如图d中的虚线所示。插入时，要为新元素分配一个级，分配过程由随机数产生器完成。</p>
<p>  若新元素为i级链元素，则仅影响由虚线断开的0~i级链指针。上图e给出新插入元素77作为1级链表时链表的结构。</p>
<p>  对于删除操作，我们无法控制其结构。</p>
<h4 id="u7EA7_u7684_u5206_u914D"><a href="#u7EA7_u7684_u5206_u914D" class="headerlink" title="级的分配"></a>级的分配</h4><p>  在级基本的分配过程中，可以观察到，在一般跳表结构中，i-1级链中的元素属于i级链的概率为p。假设有一随机数产生器所产生的数在0到RAND_MAX之间，则下一次所产生的随机数小于等于<code>CutOff = p * RAND_MAX</code>的概率为p。因此，若下一随机数小于等于<code>CutOff</code>,则新元素应在1级链上，然后继续确定新元素是否在2级链上，这将由下一个随机数来决定，如果新的随机数继续小于等于<code>CutOff</code>,重复这个过程，直到一个随机数大于<code>CutOff</code>为止。</p>
<p>  所以可以用下列代码为要插入的元素分配级:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int lev = 0;&#10;while(rand() &#60;= CutOff)&#10;    lev++;</span><br></pre></td></tr></table></figure></p>
<p>  这种方法潜在的缺点是可能为某些元素分配特别大的级，从而导致一些元素的级远远超过$log<em>{\frac{1}{p}}N$,其中N为字典中预期的最大数目。为避免这种情况，可以设定一个上限lev。在有N个元素的跳表中，级MaxLevel的最大值为$\lceil log</em>{\frac{1}{p}}N \rceil -1$,可以采用此值作为上限。</p>
<p>  另一个缺点是即使采用上面给出的上限，但还是可能存在下面的情况，如在插入一个元素前有3条链，但在插入之后就有了10条链，此时，新插入元素的是9级，尽管在前面插入中没有出现3到8级的元素，也就是在此插入前并没有插入3到8级的元素。既然这些空级没有直接的好处，那么可以直接把新元素的级调整为3。</p>
<h4 id="u7C7BSkipNode"><a href="#u7C7BSkipNode" class="headerlink" title="类SkipNode"></a>类SkipNode</h4><p>  跳表结构的头节点需要有足够的指针域，以满足可能构造最大级数的需要，而尾节点不需要指针域。每个存有元素的节点都有一个data域和（级数+1）个指针域。下面给出自定义类<strong>SkipNode</strong>，指针域由数组link表示，其中link[i]表示i级链指针。构造函数为指针数组分配空间，对于一个lev级链元素，其size值为lev+1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;class SkipList;&#10;&#10;template&#60;class E, class K&#62;&#10;class SkipNode&#123;&#10;    friend SkipList&#60;E, K&#62;;&#10;private:&#10;    SkipNode(int size)&#123;&#10;        link = new SkipNode&#60;E, K&#62;*[size];&#10;    &#125;&#10;    ~SkipNode() &#123; delete[] link; &#125;&#10;&#10;    E data;&#10;    // &#19968;&#32500;&#25351;&#38024;&#25968;&#32452;&#10;    SkipNode&#60;E, k&#62; **link;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="u7C7BSkipList"><a href="#u7C7BSkipList" class="headerlink" title="类SkipList"></a>类SkipList</h4><p>  下面给出类<strong>SkipList</strong>的定义。MaxE是字典的最大容量。虽然给出的代码中允许元素数目超过MaxE，但若元素数目不超过MaxE，平均性能会更好一些。一个元素既在i-1级链上又在i级链上的概率是p，Large是一个比字典中任意一个数均大的值。尾节点的值为Large。0级链上的值（不包括头节点，因其没有值）从左到右按升序排列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E,class K&#62;&#10;class SkipList&#123;&#10;private:&#10;    int Level();&#10;    SkipNode&#60;E, K&#62;* SaveSearch(const K&#38; k);&#10;    // &#25152;&#20801;&#35768;&#30340;&#26368;&#22823;&#32423;&#25968;&#10;    int MaxLevel;&#10;    // &#24403;&#21069;&#38750;&#31354;&#38142;&#30340;&#20010;&#25968;&#10;    int Levels;&#10;    // &#29992;&#20110;&#30830;&#23450;&#32423;&#21495;&#10;    int CutOff;&#10;    // &#19968;&#20010;&#24456;&#22823;&#30340;key&#20540;&#10;    K TailKey;&#10;    // &#22836;&#33410;&#28857;&#25351;&#38024;&#10;    SkipNode&#60;E, K&#62;* head;&#10;    // &#23614;&#33410;&#28857;&#25351;&#38024;&#10;    SkipNode&#60;E, K&#62;* tail;&#10;    // &#25351;&#38024;&#25968;&#32452;&#10;    SkipNode&#60;E, K&#62;** last;&#10;&#10;public:&#10;    SkipList(K Large, int MaxE = 10000, float p = 0.5);&#10;    ~SkipList();&#10;    bool Search(const K&#38;k, E&#38;e)const;&#10;    SkipList&#60;E, K&#62;&#38; Insert(const E&#38; e);&#10;    SkipList&#60;E, K&#62;&#38; Delete(const K&#38;k, E&#38;e);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造函数和析构函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;SkipList&#60;E, K&#62;::SkipList(K Large, int MaxE, float p)&#123;&#10;    CutOff = p * RAND_MAX;&#10;    MaxLevel = ceil(log(MaxE) / log(1 / p)) - 1;&#10;    TailKey = Large;&#10;    // &#21021;&#22987;&#21270;&#38543;&#26426;&#21457;&#29983;&#22120;&#10;    randomize();&#10;    // &#23545;&#32423;&#21495;&#36827;&#34892;&#21021;&#22987;&#21270;&#10;    Levels = 0;&#10;&#10;    // &#21019;&#24314;&#22836;&#33410;&#28857;&#12289;&#23614;&#33410;&#28857;&#20197;&#21450;&#25968;&#32452;last&#10;    head = new SkipNode&#60;E, K&#62;(MaxLevel + 1);&#10;    tail = new SkipNode&#60;E, K&#62;(0);&#10;    last = new SkipNode&#60;E, K&#62; *[MaxLevel + 1];&#10;    tail-&#62;data = Large;&#10;&#10;    // &#23558;&#25152;&#26377;&#32423;&#22343;&#32622;&#31354;&#65292;&#21363;&#23558;head&#25351;&#21521;tail&#10;    for (int i = 0; i &#60;= MaxLevel; i++)&#10;        head-&#62;link[i] = tail;&#10;&#125;&#10;&#10;template&#60;class E, class K&#62;&#10;SkipList&#60;E, K&#62;::~SkipList()&#123;&#10;    SkipNode&#60;E, K&#62;* next;&#10;&#10;    // &#36890;&#36807;&#21024;&#38500;0&#32423;&#38142;&#26469;&#21024;&#38500;&#25152;&#26377;&#33410;&#28857;&#10;    while (head != tail)&#123;&#10;        next = head-&#62;link[0];&#10;        delete head;&#10;        head = next;&#10;    &#125;&#10;&#10;    delete tail;&#10;&#10;    delete[] last;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>搜索、插入和删除函数均要求对E进行重载，以便在E的成员之间、E与K的成员之间进行比较。从K到E的赋值和转换也必须定义。当每个元素都有一个整数域data和一个长整数域key，且元素的值由key给出时，可使用下列程序定义的重载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class element&#123;&#10;    friend void main(void);&#10;public:&#10;    operator long() const&#123; return key; &#125;&#10;    element&#38; operator=(long y)&#123;&#10;        key = y;&#10;        return *this;&#10;    &#125;&#10;private:&#10;    int data;&#10;    long key;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>SkipList</strong>有两个搜索函数。当需要定位一个值为k的元素时，可使用共享成员函数<strong>Search</strong>。该函数从最高级链（Levels级，仅含一个元素）开始查找，一直到0级链。在每一级链中尽可能地逼近要查找的元素。当从for循环退出时，正好处在欲寻找元素的左边。与0级链中的下一个元素进行比较，即可确定要找的元素是否在跳表中。</p>
<p>第二个搜索函数是私有成员函数<strong>SaveSearch</strong>，由插入和删除操作来调用。<strong>SaveSearch</strong>不仅包含了<strong>Search</strong>的功能，而且可把每一级中遇到的最后一个节点存放在数组last之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;bool SkipList&#60;E, K&#62;::Search(const K&#38; k, E&#38; e)const&#123;&#10;    // &#25628;&#32034;&#19982;k&#30456;&#21305;&#37197;&#30340;&#20803;&#32032;&#65292;&#24182;&#23558;&#25214;&#21040;&#30340;&#20803;&#32032;&#25918;&#20837;e&#65292;&#22914;&#26524;&#19981;&#23384;&#22312;&#21017;&#36820;&#22238;false&#10;    if (k &#62;= TailKey)&#10;        return false;&#10;    // &#35843;&#25972;&#25351;&#38024;p&#65292;&#20351;&#20854;&#24688;&#22909;&#25351;&#21521;&#21487;&#33021;&#19982;k&#30456;&#21305;&#37197;&#30340;&#33410;&#28857;&#30340;&#21069;&#19968;&#20010;&#33410;&#28857;&#10;    SkipNode&#60;E, K&#62;*p = head;&#10;    for (int i = Levels; i &#62;= 0; i--)&#123;&#10;    // &#36880;&#32423;&#21521;&#19979;&#10;        while (p-&#62;link[i]-&#62;data &#60; k)&#10;            // &#22312;&#31532;i&#32423;&#38142;&#20013;&#25628;&#32034;&#10;            p = p-&#62;link[i];&#10;    &#125;&#10;        &#10;    // &#26816;&#26597;&#26159;&#21542;&#19979;&#19968;&#20010;&#33410;&#28857;&#25317;&#26377;&#20851;&#38190;&#20540;k&#10;    e = p-&#62;link[0]-&#62;data;&#10;    return (e == k);&#10;&#125;&#10;&#10;template&#60;class E, class K&#62;&#10;SkipNode&#60;E, K&#62;* SkipList&#60;E, K&#62;::SaveSearch(const K&#38; k)&#123;&#10;    // &#25628;&#32034;k&#24182;&#20445;&#23384;&#26368;&#32456;&#25152;&#24471;&#21040;&#30340;&#20301;&#32622;&#10;    SkipNode&#60;E, K&#62;*p = head;&#10;    for (int i = Levels; i &#62;= 0; i--)&#123;&#10;        // &#36880;&#32423;&#21521;&#19979;&#10;        while (p-&#62;link[i]-&#62;data &#60; k)&#10;            // &#22312;&#31532;i&#32423;&#38142;&#20013;&#25628;&#32034;&#10;            p = p-&#62;link[i];&#10;        last[i] = p;&#10;    &#125;&#10;    return (p-&#62;link[0]);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出插入和删除操作的实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class E, class K&#62;&#10;int SkipList&#60;E, K&#62;::Level()&#123;&#10;    // &#20135;&#29983;&#19968;&#20010;&#38543;&#26426;&#32423;&#21495;&#65292;&#35813;&#32423;&#21495;&#60;= MaxLevel&#10;    int lev = 0;&#10;    while (rand() &#60;= CutOff)&#10;        lev++;&#10;    return (lev &#60;= MaxLevel) ? lev : MaxLevel;&#10;&#125;&#10;&#10;template&#60;class E, class K&#62;&#10;SkipList&#60;E, K&#62;&#38; SkipList&#60;E, K&#62;::Insert(const E&#38; e)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#37325;&#22797;&#65292;&#21017;&#25554;&#20837;e&#10;    K k = e;&#10;    if (k &#62;= TailKey)&#123;&#10;        std::cerr &#60;&#60; &#34;The key is larger than &#34; &#60;&#60; TailKey &#60;&#60; &#34;\n&#34;;&#10;        return *this;&#10;    &#125;&#10;    // &#26816;&#26597;&#26159;&#21542;&#37325;&#22797;&#10;    SkipNode&#60;E, K&#62;*p = SaveSearch(k);&#10;    if (p-&#62;data == e)&#123;&#10;        std::cerr &#60;&#60; &#34;The key is already in SkipList\n&#34;;&#10;        return *this;&#10;    &#125;&#10;&#10;    // &#19981;&#37325;&#22797;&#65292;&#20026;&#26032;&#33410;&#28857;&#30830;&#23450;&#32423;&#21495;&#10;    int lev = Level();&#10;    if (lev &#62; Levels)&#123;&#10;        lev = ++Levels;&#10;        last[lev] = head;&#10;    &#125;&#10;&#10;    // &#20135;&#29983;&#26032;&#33410;&#28857;&#65292;&#24182;&#23558;&#26032;&#33410;&#28857;&#25554;&#20837;p&#20043;&#21518;&#10;    SkipNode&#60;E, K&#62;*y = new SkipNode&#60;E, K&#62;(lev + 1);&#10;    y-&#62;data = e;&#10;    for (int i = 0; i &#60;= lev; i++)&#123;&#10;        // &#25554;&#20837;&#21040;&#31532;i&#32423;&#38142;&#10;        y-&#62;link[i] = last[i]-&#62;link[i];&#10;        last[i]-&#62;link[i] = y;&#10;    &#125;&#10;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class E, class K&#62;&#10;SkipList&#60;E, K&#62;&#38; SkipList&#60;E, K&#62;::Delete(const K&#38;k, E&#38;e)&#123;&#10;    // &#21024;&#38500;&#19982;k&#30456;&#21305;&#37197;&#30340;&#20803;&#32032;&#65292;&#24182;&#23558;&#21024;&#38500;&#30340;&#20803;&#32032;&#25918;&#20837;e&#12290;&#10;    if (k &#62;= TailKey)&#123;&#10;        std::cerr &#60;&#60; &#34;The key is larger than &#34; &#60;&#60; TailKey &#60;&#60; &#34;\n&#34;;&#10;        return *this;&#10;    &#125;&#10;    // &#26816;&#26597;&#26159;&#21542;&#23384;&#22312;&#19982;k&#30456;&#21305;&#37197;&#30340;&#20803;&#32032;&#10;    SkipNode&#60;E, K&#62;*p = SaveSearch(k);&#10;    if (p-&#62;data &#65281;= e)&#123;&#10;        std::cerr &#60;&#60; &#34;The key is already in SkipList\n&#34;;&#10;        return *this;&#10;    &#125;&#10;    // &#20174;&#36339;&#34920;&#20013;&#21024;&#38500;&#33410;&#28857;&#10;    for (int i = 0; i &#60;= Levels &#38;&#38; last[i]-&#62;link[i] == p; i++)&#10;        last[i]-&#62;link[i] = p-&#62;link[i];&#10;&#10;    // &#20462;&#25913;&#32423;&#25968;&#10;    while (Levels &#62; 0 &#38;&#38; head-&#62;link[Levels] == tail)&#10;        Levels--;&#10;&#10;    e = p-&#62;data;&#10;    delete p;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>当跳表中有n个元素的时候，搜索、插入和删除操作的复杂性均为$O(n+MaxLevel)$。</p>
<p>更详细内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/SkipList.h" target="_blank" rel="external">跳表的实现</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节首先介绍了字典的定义以及使用链表描述来实现字典，然后介绍了跳表及其代码实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节会介绍字典和跳表。</p>
<p>对于一个有n个元素的有序数组，用折半搜索法进行搜索需要的时间是$O(logn)$,而对一个有序链表进行搜索所需要的时间是$O(n)$。我们可以通过对有序链表]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[队列-基本概念及实现方法]]></title>
    <link href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%97-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://ccc013.github.io/2016/07/23/队列-基本概念及实现方法/</id>
    <published>2016-07-23T09:43:35.000Z</published>
    <updated>2016-08-18T07:04:57.570Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第六章队列的内容。</p>
<blockquote>
<p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行，因此，队列是一个<strong>先进先出(first-in-first-out,FIFO)的线性表</strong>。</p>
</blockquote>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><blockquote>
<p>定义  队列(queue)是一个线性表，其插入和删除操作分别在表的不同端进行。添加新元素的那一端称为队尾(rear),而删除元素的那一端被称为队首(front)。</p>
</blockquote>
<p>其抽象数据类型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411;Queue&#123;&#10;&#23454;&#20363;&#10;    &#26377;&#24207;&#32447;&#24615;&#34920;&#65292;&#19968;&#31471;&#31216;&#20026;front&#65292;&#21478;&#19968;&#31471;&#31216;&#20026;rear&#65307;&#10;&#25805;&#20316;&#10;    Create(): &#21019;&#24314;&#19968;&#20010;&#31354;&#30340;&#38431;&#21015;&#65307;&#10;    IsEmpty(): &#22914;&#26524;&#38431;&#21015;&#20026;&#31354;&#65292;&#21017;&#36820;&#22238;true&#65292;&#21542;&#21017;&#36820;&#22238;false&#65307;&#10;    IsFull(): &#22914;&#26524;&#38431;&#21015;&#28385;&#65292;&#21017;&#36820;&#22238;true&#65292;&#21542;&#21017;&#36820;&#22238;false&#65307;&#10;    First(): &#36820;&#22238;&#38431;&#21015;&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;&#65307;&#10;    Last(): &#36820;&#22238;&#38431;&#21015;&#30340;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#65307;&#10;    Add(x): &#21521;&#38431;&#21015;&#20013;&#28155;&#21152;&#20803;&#32032;x&#65307;&#10;    Delete(x): &#21024;&#38500;&#38431;&#39318;&#20803;&#32032;&#65292;&#24182;&#36865;&#20837;x&#65307;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u516C_u5F0F_u63CF_u8FF0"><a href="#u516C_u5F0F_u63CF_u8FF0" class="headerlink" title="公式描述"></a>公式描述</h3><p>  使用公式$location(i)=i-1$来描述一个队列，那么所使用的数组是<code>queue[MaxSize]</code>,那么第一个元素是queue[0],第二个元素是queue<a href="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%971.png" target="_blank" rel="external">1</a>,$\cdots$。<strong>front总是为0，而rear始终是最后一个元素的位置，队列的长度为rear+1，对于一个空队列有rear=-1</strong>。</p>
<p>  按照上述公式描述队列，在添加一个元素的时候，需要将rear加1，并把新元素放入queue[rear]，其所需要的时间是$O(1)$。而删除一个元素，则需要将位置1到位置n的元素分别左移一个位置，即删除一个元素需要花费的时间是$\theta(n)$，n是删除完成后队列中的元素数目。因此，这个公式对于队列的删除操作会花费比较多时间，虽然其应用在堆栈的时候，堆栈的添加和删除操作所需时间只需要$\theta(1)$。</p>
<p>  这里考虑另一个公式$location(i)=location(1)+i-1$,它可以使得队列的删除操作所需要的时间减小至$\theta(1)$。因为在删除的时候，只需要简单的将location(1)加1即可。在用该公式的时候，<strong>front = location(1), rear=location(最后一个元素),一个空队列具有形状$rear \lt front$</strong>。</p>
<p>  如下图所示，每次操作将导致front右移一个位置。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%971.png" alt="此处输入图片的描述"></p>
<p>  当$rear \lt MaxSize-1$时才可以直接在队列的尾部添加新元素。若$rear = MaxSize-1且front \gt 0$时（表明队列未满），为了能够继续向队列添加新元素，必须将所有元素平移到队列的左端，如下图所示，以便在队列的右端留出空间。在使用新的公式情况下，最坏情况下的时间复杂性增加了$\theta(n)$，所以，新公式在提高删除操作执行效率的同时，却降低了添加操作的执行效率。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%972.png" alt="此处输入图片的描述"></p>
<p>  上述两个公式都各有缺点，所以这里就有了第三个公式，可以将队列的添加和删除操作在最坏情况下的时间复杂性均为$\theta(1)$,如下所示：<br>$$<br>location(i) = (location(1)+i-1)\% MaxSize<br>$$<br>这个时候用来描述队列的数组被视为一个环，如下所示，此时，<strong>front指向队列首元素的下一个位置（逆时针），而rear的含义不变</strong>。下图b是添加一个元素，而图c表示的是删除了一个元素。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%973.png" alt="此处输入图片的描述"></p>
<p>当且仅当front=rear时队列为空，但是由于队列满的条件也是front=rear，所以为了避免这种问题，可以不允许队列被填满，在添加元素前，先判断本次操作是否会导致队列被填满，如果是，则报错。因此，队列的最大容量实际上是MaxSize-1。</p>
<p>下面给出基于公式化描述的类Queue的代码实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef QUEUE_H_&#10;#define QUEUE_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class Queue&#123;&#10;private:&#10;    // &#19982;&#31532;&#19968;&#20010;&#20803;&#32032;&#22312;&#36870;&#26102;&#38024;&#26041;&#21521;&#19978;&#30456;&#24046;&#19968;&#20010;&#20301;&#32622;&#10;    int front;&#10;    // &#25351;&#21521;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#10;    int rear;&#10;    int MaxSize;&#10;    T* queue;&#10;public:&#10;    Queue(int MaxQueueSize = 10);&#10;    ~Queue()&#123; delete[] queue; &#125;&#10;    bool IsEmpty() const &#123; return front == rear; &#125;&#10;    bool IsFull() const &#123;&#10;        return (((rear + 1) % MaxSize == front) ? 1 : 0);&#10;    &#125;&#10;    T First() const;&#10;    T Last() const;&#10;    Queue&#60;T&#62;&#38; Add(const T&#38; x);&#10;    Queue&#60;T&#62;&#38; Delete(T&#38; x);&#10;    void Output(std::ostream&#38;);&#10;&#125;;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>下面给出其添加和删除操作函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Queue&#60;T&#62;&#38; Queue&#60;T&#62;::Add(const T&#38; x)&#123;&#10;    // &#23558;x&#28155;&#21152;&#21040;&#38431;&#21015;&#30340;&#23614;&#37096;&#10;    if (IsFull())&#10;        throw NoMem();&#10;    rear = (rear + 1) % MaxSize;&#10;    queue[rear] = x;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Queue&#60;T&#62;&#38; Queue&#60;T&#62;::Delete(T&#38; x)&#123;&#10;    // &#21024;&#38500;&#31532;&#19968;&#20010;&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#36865;&#20837;x&#10;    if (IsEmpty())&#10;        throw OutOfBounds();&#10;    front = (front + 1)%MaxSize;&#10;    x = queue[front];&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他成员函数实现可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Queue/Queue.h" target="_blank" rel="external">Queue-数组实现</a></strong>。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><p>  像堆栈一样，也可以使用链表来实现一个队列。此时需要两个变量<strong>front和rear</strong>分别跟踪队列的两端。这时有两种情形：从front开始链接到rear，如下图a所示，或者从rear开始链接到front，如下图b所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%974.png" alt="此处输入图片的描述"></p>
<p>  下面两张图分别展示了两种情形添加和删除操作，两种情形都适合于添加操作，而从front到rear的链接更便于删除操作的执行，因此，我们将采用从front到rear的链接模式。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%975.png" alt="此处输入图片的描述"> <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%976.png" alt="此处输入图片的描述"></p>
<p>  可以取处置<strong>front=rear=0，且当且仅当队列为空时front=0</strong>。下面程序给出自定义类<strong>LinkedQueue</strong>。除了析构函数外，链表队列所有成员函数的复杂性均为$\theta(1)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LINKEDQUEUE_H_&#10;#define LINKEDQUEUE_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class LinkedQueue;&#10;&#10;template&#60;class T&#62;&#10;class Node&#123;&#10;    friend LinkedQueue&#60;T&#62;;&#10;private:&#10;    T data;&#10;    Node&#60;T&#62;* link;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;class LinkedQueue&#123;&#10;private:&#10;    Node&#60;T&#62;* front;&#10;    Node&#60;T&#62;* rear;&#10;public:&#10;    LinkedQueue()&#123; front = rear = 0; &#125;&#10;    ~LinkedQueue();&#10;    bool IsEmpty() const&#123;&#10;        return ((front) ? false : true);&#10;    &#125;&#10;    bool IsFull() const;&#10;    T First() const;&#10;    T Last() const;&#10;    LinkedQueue&#60;T&#62;&#38; Add(const T&#38; x);&#10;    LinkedQueue&#60;T&#62;&#38; Delete(T&#38; x);&#10;    void Output(std::ostream&#38;);&#10;&#125;;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>然后同样是给出添加和删除操作的实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;LinkedQueue&#60;T&#62;&#38; LinkedQueue&#60;T&#62;::Add(const T&#38; x)&#123;&#10;    // &#28155;&#21152;&#20803;&#32032;x&#10;    Node&#60;T&#62;* p = new Node&#60;T&#62;;&#10;    p-&#62;data = x;&#10;    p-&#62;link = 0;&#10;    if (front)&#10;        // &#38431;&#21015;&#19981;&#20026;&#31354;&#10;        rear-&#62;link = p;&#10;    else&#10;        // &#38431;&#21015;&#20026;&#31354;&#10;        front = p;&#10;    rear = p;&#10;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;LinkedQueue&#60;T&#62;&#38; LinkedQueue&#60;T&#62;::Delete(T&#38; x)&#123;&#10;    // &#21024;&#38500;&#31532;&#19968;&#20010;&#20803;&#32032;&#65292;&#24182;&#25918;&#20837;x&#10;    if (IsEmpty())&#10;        throw OutOfBounds();&#10;    x = front-&#62;data;&#10;&#10;    // &#21024;&#38500;&#31532;&#19968;&#20010;&#33410;&#28857;&#10;    Node&#60;T&#62;* p = front;&#10;    front = front-&#62;link;&#10;    delete p;&#10;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Queue/LinkedQueue.h" target="_blank" rel="external">链表实现的队列</a></strong>。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节主要是简单介绍了队列的定义以及使用数组和链表来实现的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第六章队列的内容。</p>
<blockquote>
<p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行，因此，队列是一个<strong>先进先出(first-in-first-out,FIFO)的线]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆栈2-应用]]></title>
    <link href="http://ccc013.github.io/2016/07/21/%E5%A0%86%E6%A0%882-%E5%BA%94%E7%94%A81/"/>
    <id>http://ccc013.github.io/2016/07/21/堆栈2-应用1/</id>
    <published>2016-07-21T11:05:25.000Z</published>
    <updated>2016-07-22T11:57:24.038Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，继续第五章堆栈的内容，这节是最后关于应用方面的内容。这节会介绍括号的匹配，汉诺塔，火车车厢重排三个问题。</p>
<h3 id="u62EC_u53F7_u7684_u5339_u914D"><a href="#u62EC_u53F7_u7684_u5339_u914D" class="headerlink" title="括号的匹配"></a>括号的匹配</h3><p>  括号的匹配就是要匹配一个字符串中的左、右括号。目标是编写一个C++程序，其输入为一个字符串，输出为相互匹配的括号以及未能匹配的括号。注意，括号匹配问题可用来解决C++程序中的{和}的匹配问题。</p>
<p>  可以观察到，<strong>如果从左至右扫描一个字符串，那么最近每个右括号将于最近遇到的未匹配的左括号相匹配</strong>。因此，我们可以在从左至右的扫描过程中，把所遇到的左括号放到堆栈内，每当遇到一个右括号时，就将它与栈顶的左括号(如果存在)相匹配，同时从栈顶删除该左括号。</p>
<p>  下面给出括号匹配问题实现的代码，其时间复杂性是$\theta(n),其中n$是输入串的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#26368;&#22823;&#30340;&#23383;&#31526;&#20018;&#38271;&#24230;&#10;const int MaxLength = 100;&#10;// &#25324;&#21495;&#21305;&#37197;&#10;void PrintMatchedPairs(char* expr)&#123;&#10;    Stack&#60;int&#62; s(MaxLength);&#10;    int j, length = strlen(expr);&#10;    for (int i = 1; i &#60;= length; i++)&#123;&#10;        // &#20174;&#24038;&#21040;&#21491;&#25195;&#25551;&#23383;&#31526;&#20018;&#10;        if (expr[i - 1] == &#39;(&#39;)&#10;            // &#26632;&#20013;&#28155;&#21152;&#24038;&#25324;&#21495;&#30340;&#20301;&#32622;&#32034;&#24341;&#20540;&#10;            s.Add(i);&#10;        else if (expr[i - 1] == &#39;)&#39;)&#123;&#10;            try&#123;&#10;                s.Delete(j);&#10;                cout &#60;&#60; j &#60;&#60; &#34; &#34; &#60;&#60; i &#60;&#60; endl;&#10;            &#125;&#10;            catch (OutOfBounds)&#123;&#10;                cout &#60;&#60; &#34;No match for right parenthesis&#34; &#60;&#60; &#34; at &#34; &#60;&#60; i &#60;&#60; endl;&#10;            &#125;&#10;        &#125;   &#10;    &#125;&#10;    // &#22534;&#26632;&#20013;&#21097;&#19979;&#30340;( &#37117;&#26159;&#26410;&#21305;&#37197;&#30340;&#10;    while (!s.IsEmpty())&#123;&#10;        s.Delete(j);&#10;        cout &#60;&#60; &#34;No match for left parenthesis at &#34; &#60;&#60; j &#60;&#60; endl;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#34;xcept.h&#34;&#10;#include&#34;Stack.h&#34;&#10;&#10;using std::cout;&#10;using std::endl;&#10;using std::cin;&#10;&#10;void testMathedParis()&#123;&#10;    // &#27979;&#35797;&#25324;&#21495;&#21305;&#37197;&#10;    char expr[MaxLength];&#10;    cout &#60;&#60; &#34;Type an expression of length at most &#34; &#60;&#60; MaxLength &#60;&#60; endl;&#10;    cin.getline(expr, MaxLength);&#10;    cout &#60;&#60; &#34;The pairs of matching parentheses in &#34; &#60;&#60; endl;&#10;    puts(expr);&#10;    cout &#60;&#60; &#34;are&#34; &#60;&#60; endl;&#10;    PrintMatchedPairs(expr);&#10;&#125;&#10;&#10;int main()&#123;&#10;&#10;    testMathedParis();&#10;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%881.png" alt="此处输入图片的描述"></p>
<h3 id="u6C49_u8BFA_u5854"><a href="#u6C49_u8BFA_u5854" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><blockquote>
<p>在汉诺塔问题中，已知有n个碟子和3座塔。初始时所有的碟子按从大到小次序从塔1的底部堆放至顶部，我们需要把碟子都移动到塔2，每次移动一个碟子，而且任何时候都不能把大碟放在小碟子的上面。</p>
</blockquote>
<p>一个非常优雅的解决办法是使用<strong>递归</strong>。为了把最大的碟子移动到塔2，可以先将其余的n-1个碟子移动到塔3，然后把最大的碟子移动到塔2。接下来是把塔3上的n-1个碟子移动到塔2，因此要借用塔1和塔2，此时可以完全忽视塔2上已经有一个碟子的事实，因为这个碟子是所有碟子中最大的一个。</p>
<p>下面是按照递归方式实现的代码。初始调用的语句是<code>TowersOfHanoi(n,1,2,3)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#27721;&#35834;&#22612;&#38382;&#39064;,&#25226;n&#20010;&#30879;&#23376;&#20174;&#22612;x&#31227;&#21160;&#21040;&#22612;y&#65292;&#21487;&#20511;&#21161;&#20110;&#22612;z&#10;void TowersOfHanoi(int n, int x, int y, int z)&#123;&#10;    if (n &#62; 0)&#123;&#10;        TowersOfHanoi(n - 1, x, z, y);&#10;        cout &#60;&#60; &#34;Move top disk from tower &#34; &#60;&#60; x &#60;&#60; &#34; to top of tower &#34; &#60;&#60; y &#60;&#60; endl;&#10;        TowersOfHanoi(n - 1, z, y, x);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序所花费的时间正比于所输出的信息行数目，而信息行的数目等价于碟子移动的次数，其碟子移动次数<code>moves(n)</code>如下所示：<br>$$<br>moves(n)=<br>\begin{cases}<br>0 &amp; n=0 \\<br>2moves(n-1)+1 &amp; n&gt;0<br>\end{cases}<br>$$<br>也就是有$moves(n)=2^n-1$,所以上述函数的时间复杂性是$\theta(2^n)$。</p>
<p>上述函数只是输出把碟子从塔1移动到塔2所需要的碟子移动次序。假定希望给出每次移动之后三座塔的状态，即塔上的碟子及其次序，那么必须在内存中保留塔的状态，并在每次移动碟子之后，修改塔的状态。</p>
<p>由于从每个塔上移走碟子时是按照LIFO的方式进行，因此可以把每个塔表示成一个堆栈。三座塔在任何时候都总共拥有n个碟子，因此，如果使用链表形式的堆栈，只需申请n个元素所需要的空间。如果使用的是基于公式化描述的堆栈，则塔1和塔2的容量都必须是n，而塔3的容量必须为n-1，因而所需要的空间总数为3n-1。</p>
<p>前面的分析指出，汉诺塔问题的复杂性是以n为指数的函数，因此在可以接受的时间范围内，只能解决n值比较小(如$n\le 30$)的汉诺塔问题。而对于这些较小的n值，基于公式化描述和基于链表描述的堆栈在空间需求上的差别相当小，因此可以随意使用。</p>
<p>下面给出基于公式化描述的堆栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HANOI_H_&#10;#define HANOI_H_&#10;&#10;#include&#34;Stack.h&#34;&#10;#include&#60;iostream&#62;&#10;&#10;class Hanoi&#123;&#10;    friend void useTowersOfHanoi(int);&#10;public:&#10;    void TowersOfHanoi(int n, int x, int y, int z);&#10;private:&#10;    Stack&#60;int&#62; *S[4];&#10;&#125;;&#10;&#10;void Hanoi::TowersOfHanoi(int n, int x, int y, int z)&#123;&#10;    // &#25226;n&#20010;&#30879;&#23376;&#20174;&#22612;x&#31227;&#21160;&#21040;&#22612;y&#65292;&#21487;&#20511;&#21161;&#20110;&#22612;z&#10;    // &#30879;&#23376;&#32534;&#21495;&#10;    int d; &#10;    if (n &#62; 0)&#123;&#10;        TowersOfHanoi(n - 1, x, z, y);&#10;        // &#20174;x&#20013;&#31227;&#21160;&#36208;&#19968;&#20010;&#30879;&#23376;&#10;        S[x]-&#62;Delete(d);&#10;        // &#25918;&#21040;y&#19978;&#10;        S[y]-&#62;Add(d);&#10;        ShowState();&#10;        TowersOfHanoi(n - 1, z, y, x);&#10;    &#125;&#10;&#125;&#10;&#10;void useTowersOfHanoi(int n)&#123;&#10;    // &#39044;&#22788;&#29702;&#31243;&#24207;&#10;    Hanoi X;&#10;    X.S[1] = new Stack&#60;int&#62;(n);&#10;    X.S[2] = new Stack&#60;int&#62;(n);&#10;    X.S[3] = new Stack&#60;int&#62;(n);&#10;&#10;    for (int d = n; d &#62; 0; d--)&#10;        // &#23558;&#30879;&#23376;&#25918;&#21040;&#22612;1&#19978;&#10;        X.S[1]-&#62;Add(d);&#10;&#10;    X.TowersOfHanoi(n, 1, 2, 3);&#10;&#125;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>上述函数没有给出<code>ShowState()</code>方法的具体实现，这是由于该函数的实现取决于输出设备的性质（如计算机屏幕、打印机等）</p>
<h3 id="u706B_u8F66_u8F66_u53A2_u91CD_u6392"><a href="#u706B_u8F66_u8F66_u53A2_u91CD_u6392" class="headerlink" title="火车车厢重排"></a>火车车厢重排</h3><blockquote>
<p>一列货运列车共有n节车厢，每节车厢将停放在不同的车站。假定 n个车站的编号分别为1~n，货运列车按照第 n站至第1站的次序经过这些车站。车厢的编号与它们的目的地相同。为了便于从列车上卸掉相应的车厢，必须重新排列车厢，使各车厢从前至后按编号 1到n的次序排列。当所有的车厢都按照这种次序排列时，在每个车站只需卸掉最后一节车厢即可。</p>
</blockquote>
<p>这里可以在一个转轨站里完成车厢的重排工作，在转轨站中有一个入轨、一个出轨和k个缓冲铁轨（位于入轨和出轨之间），如下图所示，其中有k=3个缓冲铁轨H1，H2，和H3。下图a是一个初始的袋重排的车厢次序，而图b则是按照要求的次序重排后的结果。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%882.png" alt="此处输入图片的描述"></p>
<p>为了重排车厢，需从前至后依次检查入轨上的所有车厢。如果正在检查的车厢是下一个满足排列要求的车厢，可以直接把它放在出轨上。如果不是，则把它移动到缓冲铁轨上，直到按输出次序要求轮到它时才将它放到出轨上。缓冲铁轨是按照LIFO的方式使用的，因此车厢的进和出都是在缓存铁轨的顶部进行的。在重排车厢过程中，仅允许以下移动：</p>
<ul>
<li>车厢可以从入轨的前部（即右端）移动到一个缓冲铁轨的顶部或者出轨的左端</li>
<li>车厢可以从缓冲铁轨的顶部移动到出轨的左端</li>
</ul>
<p>考虑图a的情况，由于要求的次序是递增的方式，即1号是最先出轨，然后按顺序从2到9，因此在缓冲铁轨中也应该是从顶部到底部是递增的方式，即在顶部是编号小的，所以缓冲铁轨的中间状态如下所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%883.png" alt="此处输入图片的描述"></p>
<p>接下来剩下三个车厢，输出顺序就变得明了了。在这个分配过程中，主要是遵循这样一条规则：<strong>新的车厢u应送入这样的缓冲铁轨：其顶部的车厢编号v满足$v \gt u$，且v是所有满足这种条件的缓冲铁轨顶部车厢编号中最小的一个编号。</strong></p>
<p>对于图a的例子，进行车厢重排的时候，只需要3个缓冲铁轨就足够了，但是对于其他的初始次序，可能需要更多的缓冲铁轨。</p>
<p>因此，这里使用k个链表形式的堆栈来描述k个缓冲铁轨。下列函数<strong>Railroad</strong>用于确定重排n个车厢，它最多可使用k个缓冲铁轨并假定车厢的次序为p[1:n]。如果不能成功重排，函数将返回false，否则返回true。具体实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#28779;&#36710;&#36710;&#21410;&#37325;&#25490;&#10;bool Railroad(int p[], int n, int k)&#123;&#10;    // k&#20010;&#32531;&#20914;&#38081;&#36712;&#65292;&#36710;&#21410;&#21021;&#22987;&#25490;&#24207;&#20026;p[1:n], &#22914;&#26524;&#37325;&#25490;&#25104;&#21151;&#65292;&#36820;&#22238;true&#65292;&#21542;&#21017;&#36820;&#22238;false&#65292;&#22914;&#26524;&#20869;&#23384;&#19981;&#36275;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;NoMem&#10;    // &#21019;&#24314;&#20110;&#32531;&#20914;&#38081;&#36712;&#23545;&#24212;&#30340;&#22534;&#26632;&#10;    LinkedStack&#60;int&#62; *H = new LinkedStack&#60;int&#62;[k+1];&#10;    // &#19979;&#19968;&#27425;&#35201;&#36755;&#20986;&#30340;&#36710;&#21410;&#10;    int NowOut = 1;&#10;    // &#32531;&#20914;&#38081;&#36712;&#20013;&#32534;&#21495;&#26368;&#23567;&#30340;&#36710;&#21410;&#10;    int minH = n + 1;&#10;    // minH&#21495;&#36710;&#21410;&#23545;&#24212;&#30340;&#32531;&#20914;&#38081;&#36712;&#10;    int minS;&#10;    // &#36827;&#34892;&#36710;&#21410;&#37325;&#25490;&#10;    for (int i = 1; i &#60;= n; i++)&#123;&#10;        if (p[i] == NowOut)&#123;&#10;            // &#30452;&#25509;&#36755;&#20986;&#10;            cout &#60;&#60; &#34;More car &#34; &#60;&#60; p[i] &#60;&#60; &#34; from input to output&#34; &#60;&#60; endl;&#10;            NowOut++;&#10;            while (minH == NowOut)&#123;&#10;                Output(minH, minS, H, k, n);&#10;                NowOut++;&#10;            &#125;&#10;        &#125;&#10;        else&#123;&#10;            // &#23558;p[i]&#36865;&#20837;&#26576;&#20010;&#32531;&#20914;&#38081;&#36712;&#10;            if (!Hold(p[i], minH, minS, H, k, n))&#10;                return false;&#10;        &#125;&#10;    &#125;&#10;    return true;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面则给出函数<strong>Railroad</strong>中使用的函数<strong>Output和Hold</strong>的代码实现，前者主要是用于将一节车厢从缓冲铁轨中输出到出轨处，同时修改minH和minS，而后者则是根据分配规则将车厢c送入某个缓冲铁轨，并在必要的时候修改minH和minS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Output(int&#38; minH, int&#38; minS, LinkedStack&#60;int&#62; H[], int k, int n)&#123;&#10;    // &#25226;&#36710;&#21410;&#20174;&#32531;&#20914;&#38081;&#36712;&#36865;&#33267;&#20986;&#36712;&#22788;&#65292;&#21516;&#26102;&#20462;&#25913;minS&#21644;minH&#10;    // &#36710;&#21410;&#32034;&#24341;&#10;    int c;&#10;    // &#20174;&#22534;&#26632;minS&#20013;&#21024;&#38500;&#32534;&#21495;&#26368;&#23567;&#30340;&#36710;&#21410;minH&#10;    H[minS].Delete(c);&#10;    cout &#60;&#60; &#34;More car &#34; &#60;&#60; minH &#60;&#60; &#34; from holding track &#34; &#60;&#60; minS &#60;&#60; &#34; to output\n&#34;;&#10;    // &#36890;&#36807;&#26816;&#26597;&#25152;&#26377;&#30340;&#26632;&#39030;&#65292;&#25628;&#32034;&#26032;&#30340;minH&#21644;minS&#10;    minH = n + 2;&#10;    for (int i = 1; i &#60;= k; i++)&#123;&#10;        if (!H[i].IsEmpty() &#38;&#38; (c = H[i].Top()) &#60; minH)&#123;&#10;            minH = c;&#10;            minS = i;&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;&#10;bool Hold(int c, int&#38; minH, int&#38; minS, LinkedStack&#60;int&#62; H[], int k, int n)&#123;&#10;    // &#22312;&#19968;&#20010;&#32531;&#20914;&#38081;&#36712;&#20013;&#25918;&#20837;&#36710;&#21410;c,&#22914;&#26524;&#27809;&#26377;&#21487;&#29992;&#30340;&#32531;&#20914;&#38081;&#36712;&#65292;&#36820;&#22238;false&#65292;&#22914;&#26524;&#31354;&#38388;&#19981;&#36275;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;NoMem&#10;    // &#30446;&#21069;&#26368;&#20248;&#30340;&#38081;&#36712;&#10;    int BestTrack = 0;&#10;    // &#26368;&#20248;&#38081;&#36712;&#19978;&#30340;&#22836;&#36742;&#36710;&#21410;&#21495;&#10;    int BestTop = n + 1;&#10;    // &#36710;&#21410;&#32034;&#24341;&#10;    int x;&#10;    // &#25195;&#25551;&#32531;&#20914;&#38081;&#36712;&#10;    for (int i = 1; i &#60;= k; i++)&#123;&#10;        if (!H[i].IsEmpty())&#123;&#10;            x = H[i].Top();&#10;            if (c &#60; x &#38;&#38; x &#60; BestTop)&#123;&#10;                BestTop = c;&#10;                BestTrack = i;&#10;            &#125;&#10;        &#125;&#10;        else&#123;&#10;            // &#38081;&#36712;&#26159;&#31354;&#10;            if (!BestTrack)&#10;                BestTrack = i;&#10;        &#125;&#10;    &#125;&#10;    if (!BestTrack)&#10;        return false;&#10;    // &#25226;&#36710;&#21410;c&#36865;&#20837;&#32531;&#20914;&#38081;&#36712;&#10;    H[BestTrack].Add(c);&#10;    cout &#60;&#60; &#34;More car &#34; &#60;&#60; c &#60;&#60; &#34; from input to holding track &#34; &#60;&#60; BestTrack &#60;&#60; endl;&#10;    // &#24517;&#35201;&#26102;&#20462;&#25913;minH&#21644;minS&#10;    if (c &#60; minH)&#123;&#10;        minH = c;&#10;        minS = BestTrack;&#10;    &#125;&#10;    return true;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个函数Output和Hold的时间复杂性都是$\theta(k)$。而在函数Railroad中的while循环最多可以输出n-1节车厢，else语句也是最多有n-1节车厢被送入缓冲铁轨，因此，这两个函数所消耗的总时间是$O(kn)$。而Railroad函数中for循环部分的其余部分耗时$\theta(n)$,因此该函数的时间复杂性是$O(kn)$。</p>
<p>这里如果使用一个平衡折半搜索树来存储缓冲铁轨顶部的车厢编号（在第11章介绍），程序的复杂性可由将至$O(nlogk)$。</p>
<p>更详细的内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Stack/StackExamples.md" target="_blank" rel="external">我的Github</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节主要是介绍堆栈的三个应用，分别是括号的匹配，汉诺塔以及火车车厢重排问题，都是利用堆栈的LIFO性质。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，继续第五章堆栈的内容，这节是最后关于应用方面的内容。这节会介绍括号的匹配，汉诺塔，火车车厢重排三个问题。</p>
<h3 id="u62EC_u53F7_u7684_u5339_u914D"><a href="#u62EC]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆栈1--基本概念及实现方法]]></title>
    <link href="http://ccc013.github.io/2016/07/12/%E5%A0%86%E6%A0%881-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://ccc013.github.io/2016/07/12/堆栈1-基本概念及实现方法/</id>
    <published>2016-07-12T07:22:48.000Z</published>
    <updated>2016-07-12T07:23:34.127Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这次是新的一章内容，第五章堆栈。</p>
<blockquote>
<p>堆栈数据结构是通过对线性表的插入和删除操作进行限制而得到的，即插入和删除操作都必须在表的同一端完成，因此堆栈是一个<strong>后进先出(last-in-first-out,LIFO)</strong>的数据结构。</p>
</blockquote>
<p>由于堆栈是一种特殊的线性表，所以可以很自然地从相应的线性表类中派生出堆栈类，既可以从基于公式描述的类<strong>LinearList</strong>类派生，也可以从基于链表结构的类<strong>Chain</strong>派生出堆栈类。</p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>  这里给出堆栈的抽象数据类型描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411;Stack&#123;&#10;&#23454;&#20363;&#10;    &#20803;&#32032;&#32447;&#24615;&#34920;&#65292;&#26632;&#24213;&#65292;&#26632;&#39030;&#10;&#25805;&#20316;&#10;    Create(): &#21019;&#24314;&#19968;&#20010;&#31354;&#30340;&#22534;&#26632;&#10;    IsEmpty(): &#22914;&#26524;&#22534;&#26632;&#20026;&#31354;&#65292;&#21017;&#36820;&#22238;true&#65292;&#21542;&#21017;&#36820;&#22238;false&#10;    IsFull(): &#22914;&#26524;&#22534;&#26632;&#28385;&#65292;&#21017;&#36820;&#22238;true&#65292;&#21542;&#21017;&#36820;&#22238;false&#10;    Top(): &#36820;&#22238;&#26632;&#39030;&#20803;&#32032;&#10;    Add(x): &#21521;&#22534;&#26632;&#20013;&#28155;&#21152;&#20803;&#32032;x&#10;    Delete(x): &#21024;&#38500;&#26632;&#39030;&#20803;&#32032;&#65292;&#24182;&#23558;&#23427;&#20256;&#36882;&#32473;x&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u6D3E_u751F_u7C7B_u548C_u7EE7_u627F"><a href="#u6D3E_u751F_u7C7B_u548C_u7EE7_u627F" class="headerlink" title="派生类和继承"></a>派生类和继承</h3><p>  若类B是类A的限制版本，那么可以从类A派生出类B。<strong>我们称类A是基类，类B是派生类。</strong>从类A派生出的类B继承了基类A的所有成员——共享成员、保护成员和私有成员。类型为B的每个对象都与A所有的数据成员和函数相关联。<strong>类B可以采用如下三种基本方式之一来继承类A的成员————共享成员、保护成员和私有成员。</strong>比如，对于共享成员方式，可以采用如下语法形式：<code>class B:public A</code></p>
<p>  <strong>一个类可以从多个类派生而来</strong>。比如，类B从A和C派生而来，并且以共享成员方式继承A的属性，以私有成员方法继承C的属性，相应的语法形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class B:public A, private C</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在所有继承方式中，基类A的私有成员仍是A的私有成员，类B的成员不能够访问它们。不同的继承方式仅影响对基类的保护成员和共享成员的访问。</p>
<p>当B按照共享成员方式从A派生出来，A的保护成员成为B的保护成员，A的共享成员成为B的共享成员。</p>
<p>如果继承方式是保护成员，那么A的共享成员和保护成员均成为B的保护成员。</p>
<p>如果继承方式是私有成员，那么A的共享成员和保护成员均成为B的私有成员。</p>
</blockquote>
<h3 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h3><p>  由于堆栈是一个受限的线性表，因此可以参考<a href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据描述1-线性表</a>中的公式化描述，令栈顶元素存储在<code>element[length-1]</code>，栈底元素存储在<code>element[0]</code>中。下列程序定义的Stack类将使用私有成员方法继承<a href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据描述1-线性表</a>中定义的类LinearList。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef INHERITSTACK_H_&#10;#define INHERITSTACK_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class Stack : private LinearList&#60;T&#62;&#10;&#123;&#10;public:&#10;    Stack(int MaxStackSize = 10) : LinearList&#60;T&#62;(MaxStackSize)&#123;&#125;&#10;    bool IsEmpty() const&#123;&#10;        return LinearList&#60;T&#62;::isEmpty();&#10;    &#125;&#10;    bool IsFull() const&#123;&#10;        return (Length() == GetMaxSize());&#10;    &#125;&#10;    T Top() const;&#10;    Stack&#60;T&#62;&#38; Add(const T&#38; x);&#10;    Stack&#60;T&#62;&#38; Delete(T&#38; x);&#10;    void Output(std::ostream&#38; out)const;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;T Stack&#60;T&#62;::Top() const&#123;&#10;    if (IsEmpty())&#10;        throw OutOfBounds();&#10;    T x;&#10;    Find(Length(), x);&#10;    return x;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Stack&#60;T&#62;&#38; Stack&#60;T&#62;::Add(const T&#38; x)&#123;&#10;    Insert(Length(), x);&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Stack&#60;T&#62;&#38; Stack&#60;T&#62;::Delete(T&#38; x)&#123;&#10;    LinearList&#60;T&#62;::Delete(Length(), x);&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void Stack&#60;T&#62;::Output(std::ostream&#38; out)const&#123;&#10;    &#10;    for (int i = 0; i &#60; length; i++)&#10;        out &#60;&#60; element[i] &#60;&#60; &#34; &#34;;&#10;    out &#60;&#60; &#34;\n&#34;;&#10;&#125;&#10;&#10;// &#37325;&#36733; &#60;&#60;&#10;template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38;out, const Stack&#60;T&#62;&#38; x)&#123;&#10;    x.Output(out);&#10;    return out;&#10;&#125;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>这里，Stack的构造函数简单调用线性表的构造函数，提供的参数为堆栈的大小<strong>MaxStackSize</strong>。这里使用操作符<strong>::</strong>来区分基类和派生类的同名成员。</p>
<p>在实现函数<strong>IsFull</strong>时，由于Stack的成员不能直接访问基类的私有成员，因此可以在基类LinearList中增加一个保护成员的函数<strong>GetMaxSize</strong>，其实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected:&#10;    int GetMaxSize() const&#123;&#10;        return MaxSize;&#10;    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Stack_u7684_u6548_u7387"><a href="#Stack_u7684_u6548_u7387" class="headerlink" title="Stack的效率"></a>Stack的效率</h4><p>  当T是一个内部数据类型时，堆栈的构造函数和析构函数的复杂性均为$\theta(1)$,当T时用户自定义的类时，构造函数和析构函数的复杂性均为$O(MaxStackSize)$。其余每个堆栈操作的复杂性均为$\theta(1)$。</p>
<p>  这里通过从<code>LinearList</code>派生<code>Stack</code>，一方面大大减少了编码量，另一方面也使得程序的可靠性得到很大提高，因为<code>LinearList</code>经过测试被认为是正确的。</p>
<p>  当然，继承有利的一方面，也有弊端。代码编写的简化带来了运行效率的损失。比如，为了向堆栈中添加一个元素，首先要确定堆栈的长度<code>Length()</code>，然后调用函数<code>Insert()</code>。<code>Insert()</code>函数首先会判断插入操作是否会越界，然后需要付出一个for循环的开销来执行0个元素的移动。为了消除额外的开销，可以把<code>Stack</code>定义为一个基类，而不是一个派生类。</p>
<p>  另一个潜在问题是派生类<code>Stack</code>也会受到<code>LinearList</code>本身所受限制的影响。比如，必须为数据类型为T的成员定义操作符&lt;&lt;和==，因为前者用于对线性表操作&lt;&lt;的重载，后者用于对<code>LinearList::Search</code>的重载。</p>
<h4 id="u81EA_u5B9A_u4E49Stack"><a href="#u81EA_u5B9A_u4E49Stack" class="headerlink" title="自定义Stack"></a>自定义Stack</h4><p>  下面是自定义Stack的类定义实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef STACK_H_&#10;#define STACK_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class Stack&#123;&#10;private:&#10;    // &#26632;&#39030;&#10;    int top;&#10;    // &#26368;&#22823;&#30340;&#26632;&#39030;&#20540;&#10;    int MaxTop;&#10;    // &#22534;&#26632;&#20803;&#32032;&#25968;&#32452;&#10;    T* stack;&#10;public:&#10;    Stack(int MaxStackSize = 10);&#10;    ~Stack()&#123; delete[] stack; &#125;&#10;    bool IsEmpty() const&#123; return top == -1; &#125;&#10;    bool IsFull() const &#123; return top == MaxTop; &#125;&#10;    T Top() const;&#10;    Stack&#60;T&#62;&#38; Add(const T&#38; x);&#10;    Stack&#60;T&#62;&#38; Delete(T&#38; x);&#10;    template&#60;class T&#62;&#10;    friend std::ostream&#38; operator&#60;&#60;(std::ostream&#38;, const Stack&#60;T&#62;&#38;);&#10;&#125;;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>下面是类成员函数的定义实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Stack&#60;T&#62;::Stack(int MaxStackSize)&#123;&#10;    // &#26500;&#36896;&#20989;&#25968;&#10;    MaxTop = MaxStackSize - 1;&#10;    stack = new T[MaxStackSize];&#10;    top = -1;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;T Stack&#60;T&#62;::Top()const&#123;&#10;    // &#36820;&#22238;&#26632;&#39030;&#20803;&#32032;&#10;    if (IsEmpty())&#10;        throw OutOfBounds();&#10;    else&#10;        return stack[top];&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Stack&#60;T&#62;&#38; Stack&#60;T&#62;::Add(const T&#38; x)&#123;&#10;    // &#28155;&#21152;&#20803;&#32032;&#10;    if (IsFull())&#10;        throw NoMem();&#10;    stack[++top] = x;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Stack&#60;T&#62;&#38; Stack&#60;T&#62;::Delete(T&#38; x)&#123;&#10;    // &#21024;&#38500;&#26632;&#39030;&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#20256;&#36865;&#20837;x&#10;    if (IsEmpty())&#10;        throw OutOfBounds();&#10;    x = stack[top--];&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38; out, const Stack&#60;T&#62;&#38; x)&#123;&#10;    int pos = x.top;&#10;    if (x.IsEmpty())&#10;        std::cout &#60;&#60; &#34;There is no elements in stack&#34;;&#10;    while (pos != -1)&#123;&#10;        std::cout &#60;&#60; x.stack[pos] &#60;&#60; &#34; &#34;;&#10;        pos--;&#10;    &#125;&#10;    std::cout &#60;&#60; &#34;\n&#34;;&#10;    return out;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过测试，自定义Stack在添加和删除操作要比通过继承而得到的类Stack的相应操作要更快。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><p>  上一节给出用数组实现堆栈的方法即优雅又高效，但是若同时使用多个堆栈，这种方法将浪费大量的空间。</p>
<p>  这里可以使用链表描述，下面给出自定义链表类<code>LinkedStack</code>的类定义声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LINKEDSTACK_H_&#10;#define LINKEDSTACK_H_&#10;#include&#60;iostream&#62;&#10;using std::ostream;&#10;template&#60;class T&#62;&#10;class LinkedStack;&#10;&#10;template&#60;class T&#62;&#10;class Node&#123;&#10;    friend LinkedStack&#60;T&#62;;&#10;private:&#10;    T data;&#10;    Node&#60;T&#62;* link;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;class LinkedStack&#123;&#10;private:&#10;    Node&#60;T&#62;* top;&#10;public:&#10;    LinkedStack()&#123; top = 0; &#125;&#10;    ~LinkedStack();&#10;    bool IsEmpty() const&#123; return top == 0; &#125;&#10;    bool IsFull() const;&#10;    T Top()const;&#10;    LinkedStack&#60;T&#62;&#38; Add(const T&#38; x);&#10;    LinkedStack&#60;T&#62;&#38; Delete(T&#38; x);&#10;    void Output(ostream&#38;);&#10;&#125;;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>其类成员函数实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;// &#26512;&#26500;&#20989;&#25968;&#10;template&#60;class T&#62;&#10;LinkedStack&#60;T&#62;::~LinkedStack()&#123;&#10;    Node&#60;T&#62;* next;&#10;    while (top)&#123;&#10;        next = top-&#62;link;&#10;        delete top;&#10;        top = next;&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;bool LinkedStack&#60;T&#62;::IsFull()const&#123;&#10;    try&#123;&#10;        Node&#60;T&#62;* p = new Node&#60;T&#62;;&#10;        delete p;&#10;        return false;&#10;    &#125;&#10;    catch (NoMem)&#123;&#10;        return true;&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;T LinkedStack&#60;T&#62;::Top()const&#123;&#10;    if (IsEmpty())&#10;        throw OutOfBounds();&#10;    return top-&#62;data;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;LinkedStack&#60;T&#62;&#38; LinkedStack&#60;T&#62;::Add(const T&#38; x)&#123;&#10;    // &#28155;&#21152;&#20803;&#32032;x&#10;    Node&#60;T&#62;* p = new Node&#60;T&#62;;&#10;    p-&#62;data = x;&#10;    p-&#62;link = top;&#10;    top = p;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;LinkedStack&#60;T&#62;&#38; LinkedStack&#60;T&#62;::Delete(T&#38; x)&#123;&#10;    // &#21024;&#38500;&#20803;&#32032;&#65292;&#24182;&#20256;&#32473;x&#36820;&#22238;&#10;    if (IsEmpty())&#10;        throw OutOfBounds();&#10;    x = top-&#62;data;&#10;    Node&#60;T&#62;* p = top;&#10;    top = top-&#62;link;&#10;    delete p;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void LinkedStack&#60;T&#62;::Output(ostream&#38; out)&#123;&#10;    if (IsEmpty())&#10;        out &#60;&#60; &#34;There is no elements in LinkedStack&#34;;&#10;    Node&#60;T&#62;* p = top;&#10;    while (p)&#123;&#10;        out &#60;&#60; p-&#62;data &#60;&#60; &#34; &#34;;&#10;        p = p-&#62;link;&#10;    &#125;&#10;    out &#60;&#60; &#34;\n&#34;;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;ostream&#38; operator&#60;&#60;(ostream&#38; out,LinkedStack&#60;T&#62;&#38; x)&#123;&#10;    x.Output(out);&#10;    return out;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里仅给出自定义链栈<code>LinkedStack</code>，同样可以通过继承线性表的链表实现类来派生出链栈，但是<code>LinkedStack</code>在添加和删除操作上的效率要更加高点。</p>
<p>代码实现可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/Stack" target="_blank" rel="external">Github</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节主要是介绍了堆栈的基本实现方法，分为数组实现和链表实现，实现的代码也是比较简单的。下面一节会介绍堆栈的一些应用，包括括号匹配，汉诺塔等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这次是新的一章内容，第五章堆栈。</p>
<blockquote>
<p>堆栈数据结构是通过对线性表的插入和删除操作进行限制而得到的，即插入和删除操作都必须在表的同一端完成，因此堆栈是一个<strong>后进先出(last]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵4-稀疏矩阵]]></title>
    <link href="http://ccc013.github.io/2016/07/07/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B54-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/07/07/数组和矩阵4-稀疏矩阵/</id>
    <published>2016-07-07T07:57:30.000Z</published>
    <updated>2016-07-07T08:01:05.351Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍稀疏矩阵的内容。这也是本章节最后一节内容。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>如果一个$m\times n$矩阵中有”许多”元素为0，则称该矩阵为<strong>稀疏矩阵(sparse)</strong></p>
</blockquote>
<p>对应的非稀疏的矩阵称为<strong>稠密矩阵(dense)</strong>。而实际上，稀疏矩阵和稠密矩阵之间并没有一个精确的界限。</p>
<p>$n\times n$的对角矩阵和三对角矩阵都是稀疏矩阵，二者都有$O(n)$个非0元素和$O(n^2)$个0元素。而对于一个$n\times n$的三角矩阵，它至少有$\frac{n(n-1)}{2}$个0元素，最多有$\frac{n(n+1)}{2}$个非0元素。在本节中，我们规定一个矩阵是稀疏矩阵，则其非0元素的数目应小于$n^2/3$,有些情况下应小于$n^2/5$,因此可以将三角矩阵视为稠密矩阵。</p>
<p>诸如对角矩阵和三对角矩阵这样的稀疏矩阵，其非0区域的结构很有规律，因此可以设计一个很简单的存储结构，该存储结构的大小就等于矩阵非0区域的大小，本小节主要考察具有不规则非0区域的稀疏矩阵。</p>
<h3 id="u6570_u7EC4_u63CF_u8FF0"><a href="#u6570_u7EC4_u63CF_u8FF0" class="headerlink" title="数组描述"></a>数组描述</h3><p>  对于下图a中的$4\times 8$矩阵可以按行主次序把非0元素映射到一维数组中，可到到:2,1,6,7,3,9,8,4,5。</p>
<p>  为了重建矩阵结构，必须记录每个非0元素所在的行号和列号，所以在把稀疏矩阵的非0元素映射到数组中时必须提供三个域:<strong>row(矩阵元素所在的行号)、col(矩阵元素所在列号)和value(矩阵元素的值)</strong>。为此定义了下列所示的模板类<strong>Term</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class Term&#123;&#10;    int row, col;&#10;    T value;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果a是一个类型为Term的数组，那么下图a中的稀疏矩阵按行主次序存储到a中所得的结果就如图b所示。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B51.png" alt="此处输入图片的描述"></p>
<p>  除了存储数组a以外，还必须存储矩阵行数、矩阵列数和非0项的数目。所以存储上图a中的九个非0元素所需要的存储器字节数是<strong>21<em>sizeof(int)+9</em>sizeof(T)</strong>,这里每个非0元素都有两个int类型的行号和列号，然后加上总的矩阵行数，列数以及非0数目。</p>
<h4 id="u7C7BSparseMatrix"><a href="#u7C7BSparseMatrix" class="headerlink" title="类SparseMatrix"></a>类SparseMatrix</h4><p>  可以定义一个类SparseMatrix，如下所示，用来把稀疏矩阵按行主次序映射到一维数组中。在定义共享成员时，没有定义加法操作符+，因为它会创建一个临时结果，这个临时结果必须复制到所返回的环境才可以使用。由于SparseMatrix的复制构造函数将会复制每一个元素，因此操作符+中的复制代价太大，这里使用Add函数来避免这种情况的发生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class SparseMatrix&#123;&#10;private:&#10;    void Append(const Term&#60;T&#62;&#38; t);&#10;    int rows, cols;&#10;    // &#38750;0&#20803;&#32032;&#30340;&#25968;&#30446;&#10;    int terms;&#10;    // &#23384;&#20648;&#38750;0&#20803;&#32032;&#30340;&#25968;&#32452;&#10;    Term&#60;T&#62; *a;&#10;    // &#25968;&#32452;a&#30340;&#22823;&#23567;&#10;    int MaxTerms;&#10;public:&#10;    SparseMatrix(int maxTerms = 0);&#10;    ~SparseMatrix()&#123; delete[] a; &#125;&#10;    void Transpose(SparseMatrix&#60;T&#62;&#38; b)  const;&#10;    void Add(const SparseMatrix&#60;T&#62; &#38;b, SparseMatrix&#60;T&#62;&#38;c)const;&#10;    friend std::ostream&#38; operator&#60;&#60;(std::ostream&#38;, const SparseMatrix&#60;T&#62;&#38;);&#10;    friend std::istream&#38; operator&#62;&#62;(std::istream&#38;, SparseMatrix&#60;T&#62;&#38;);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出构造函数，以及输入操作符和输出操作符，两者的时间复杂性都是$\theta(terms)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;SparseMatrix&#60;T&#62;::SparseMatrix(int maxTerms)&#123;&#10;    if (maxTerms &#60; 1)&#10;        throw BadInitializers();&#10;    MaxTerms = maxTerms;&#10;    a = new Term&#60;T&#62;[maxTerms];&#10;    terms = rows = cols = 0;&#10;&#125;&#10;&#10;// &#37325;&#36733;&#60;&#60;&#10;template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38; out, const SparseMatrix&#60;T&#62;&#38; x)&#123;&#10;    // &#36755;&#20986;&#30697;&#38453;&#30340;&#29305;&#24449;&#10;    out &#60;&#60; &#34;rows = &#34; &#60;&#60; x.rows &#60;&#60; &#34; columns = &#34; &#60;&#60; x.rows &#60;&#60; std::endl;&#10;    out &#60;&#60; &#34;nonzeros terms = &#34; &#60;&#60; x.terms &#60;&#60; std::endl;&#10;    // &#36755;&#20986;&#38750;0&#20803;&#32032;&#65292;&#27599;&#34892;1&#20010;&#10;    for (int i = 0; i &#60; x.terms; i++)&#10;        out &#60;&#60; &#34;a(&#34; &#60;&#60; x.a[i].row &#60;&#60; &#34;, &#34; &#60;&#60; x.a[i].col &#60;&#60; &#34;) = &#34; &#60;&#60; x.a[i].value &#60;&#60; std::endl;&#10;    return out;&#10;&#125;&#10;&#10;// &#37325;&#36733;&#62;&#62;&#10;template&#60;class T&#62;&#10;std::istream&#38; operator&#62;&#62;(std::istream&#38; in, SparseMatrix&#60;T&#62;&#38; x)&#123;&#10;    // &#36755;&#20837;&#30697;&#38453;&#30340;&#29305;&#24449;&#10;    std::cout &#60;&#60; &#34;Enter number of rows, columns, and terms\n&#34;;&#10;    in &#62;&#62; x.rows &#62;&#62; x.cols &#62;&#62; x.terms;&#10;    if (x.terms &#62; x.MaxTerms)&#10;        throw NoMem();&#10;    // &#36755;&#20837;&#30697;&#38453;&#20803;&#32032;&#10;    for (int i = 0; i &#60; x.terms; i++)&#123;&#10;        cout &#60;&#60; &#34;Enter row, column, and value of term &#34; &#60;&#60; (i + 1) &#60;&#60; std::endl;&#10;        in &#62;&#62; x.a[i].row &#62;&#62; x.a[i].col &#62;&#62; x.a[i].value;&#10;    &#125;&#10;    return in;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在重载输入操作符&gt;&gt;的时候，如果输入的元素数目大于数组a的大小，则会引发一个异常。一种处理异常的方法是删除数组a，然后使用new重新分配一个更大的数组。</p>
<h4 id="u77E9_u9635_u8F6C_u7F6E"><a href="#u77E9_u9635_u8F6C_u7F6E" class="headerlink" title="矩阵转置"></a>矩阵转置</h4><p>  下面程序给出函数<strong>Tranpose</strong>的代码实现。转置后的矩阵被返回到b中。<br>  首先验证b中是否有足够的空间来存储被转置矩阵的非0元素。如果空间不足，要么重新分配一个更大的数组<strong>b.a</strong>,要么引发一个异常。在下面的程序中是选择引发异常。如果b中有足够的空间来容纳转置矩阵，则创建两个数组<strong>ColSize</strong>和<strong>RowNext</strong>。其中<code>ColSize[i]</code>是指矩阵第i列中的非0元素的数目，而<code>RowNext[i]</code>则是代表转置矩阵第i行的下一个非0元素在b中的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void SparseMatrix&#60;T&#62;::Transpose(SparseMatrix&#60;T&#62;&#38; b)const&#123;&#10;    // &#25226;*this&#30340;&#36716;&#32622;&#32467;&#26524;&#36865;&#20837;b&#20013;&#10;    // &#39564;&#35777;b&#26377;&#36275;&#22815;&#31354;&#38388;&#10;    if (terms &#62; b.MaxTerms)&#10;        throw NoMem();&#10;    // &#35774;&#32622;&#36716;&#32622;&#29305;&#24449;&#10;    b.cols = rows;&#10;    b.rows = cols;&#10;    b.terms = terms;&#10;    // &#21021;&#22987;&#21270;&#10;    int *ColSize, *RowNext;&#10;    ColSize = new int[cols + 1];&#10;    RowNext = new int[rows + 1];&#10;    for (int i = 1; i &#60;= cols; i++)&#10;        ColSize[i] = 0;&#10;    // &#35745;&#31639;*this&#27599;&#19968;&#21015;&#30340;&#38750;0&#20803;&#32032;&#25968;&#37327;&#10;    for (int i = 0; i &#60; terms; i++)&#10;        ColSize[a[i].col]++;&#10;    // &#32473;&#20986;b&#20013;&#27599;&#19968;&#34892;&#30340;&#36215;&#22987;&#28857;&#10;    RowNext[1] = 0;&#10;    for (int i = 2; i &#60;= cols; i++)&#10;        RowNext[i] = RowNext[i - 1] + ColSize[i - 1];&#10;&#10;    // &#25191;&#34892;&#36716;&#32622;&#25805;&#20316;&#10;    for (int i = 0; i &#60; terms; i++)&#123;&#10;        // &#22312;b&#20013;&#30340;&#20301;&#32622;&#10;        int j = RowNext[a[i].col]++;&#10;        b.a[j].row = a[i].col;&#10;        b.a[j].col = a[i].row;&#10;        b.a[j].value = a[i].value;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数Tranpose的时间复杂性是$O(cols+terms)$</p>
<h4 id="u77E9_u9635_u76F8_u52A0"><a href="#u77E9_u9635_u76F8_u52A0" class="headerlink" title="矩阵相加"></a>矩阵相加</h4><p>  在两个矩阵相加中使用了函数Append，它把一个非0项添加到一个稀疏矩阵的非0项数组的尾部，其时间复杂性是$\theta(1)$。实现代码如下，然后就是两个矩阵相加的实现函数Add，使用两个游标，分别是*this和矩阵b的游标，通过一个while循环来实现相加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void SparseMatrix&#60;T&#62;::Append(const Term&#60;T&#62;&#38; t)&#123;&#10;    // &#25226;&#19968;&#20010;&#38750;0&#20803;&#32032;t&#28155;&#21152;&#21040; *this&#20043;&#20013;&#10;    if (terms &#62;= MaxTerms)&#10;        throw NoMem();&#10;    a[terms] = t;&#10;    terms++;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void SparseMatrix&#60;T&#62;::Add(const SparseMatrix&#60;T&#62;&#38; b, SparseMatrix&#60;T&#62;&#38; c)const&#123;&#10;    // &#35745;&#31639; c = (*this) + b&#10;    // &#39564;&#35777;&#21487;&#34892;&#24615;&#10;    if (rows != b.rows || cols != b.cols)&#10;        throw SizeMismatch();&#10;    // &#35774;&#32622;&#32467;&#26524;&#30697;&#38453;c&#30340;&#29305;&#24449;&#10;    c.rows = rows;&#10;    c.cols = cols;&#10;    c.terms = 0;&#10;    // &#23450;&#20041;*this &#21644;b &#30340;&#28216;&#26631;&#10;    int ct = 0, cb = 0;&#10;    while (ct &#60; terms &#38;&#38; cb &#60; b.terms)&#123;&#10;        // &#27599;&#19968;&#20010;&#20803;&#32032;&#30340;&#34892;&#20027;&#32034;&#24341;&#10;        int indt = a[ct].row * cols + a[ct].col;&#10;        int indb = b.a[cb].row * cols + b.a[cb].col;&#10;        if (indt &#60; indb)&#123;&#10;            // b&#30340;&#20803;&#32032;&#22312;&#21518;&#38754;&#10;            c.Append(a[ct]);&#10;            ct++;&#10;        &#125;&#10;        else&#123;&#10;            if (indt == indb)&#123;&#10;                // &#20301;&#32622;&#30456;&#21516;&#10;                if (a[ct].value + b.a[cb].value)&#123;&#10;                    // &#20165;&#24403;&#21644;&#19981;&#20026;0&#26102;&#65292;&#25165;&#28155;&#21152;&#21040;c&#20013;&#10;                    Term&#60;T&#62; t;&#10;                    t.row = a[ct].row;&#10;                    t.col = a[ct].col;&#10;                    t.value = a[ct].value + b.a[cb].value;&#10;                    c.Append(t);&#10;                &#125;&#10;                ct++;&#10;                cb++;&#10;            &#125;&#10;            else&#123;&#10;                // b&#30340;&#20803;&#32032;&#22312;&#21069;&#38754;&#10;                c.Append(b.a[cb]);&#10;                cb++;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    // &#22797;&#21046;&#21097;&#20313;&#20803;&#32032;&#10;    for (; ct &#60; terms; ct++)&#10;        c.Append(a[ct]);&#10;    for (; cb &#60; b.terms; cb++)&#10;        c.Append(b.a[cb]);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数Add的时间复杂性是$O(terms+b.terms)$。而如果用二维数组来描述每个矩阵，则两个矩阵相加耗时$O(rows<em>cols)$，当<strong>terms+b.terms</strong>远小于**rows</em>cols**时，稀疏矩阵的加法执行效率将大大提高。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><p>  用一维数组来描述稀疏矩阵所存在的缺点是：<strong>当我们创建这个一维数组时，必须知道稀疏矩阵中的非0元素总数。</strong><br>  在我们自定义的类SparseMatrix中，当实际非0元素数目多于估计的初始化一维数组时设定的非0元素数目时，会引发一个异常。还有一种做法是可以分配一个更大的、新的数组，然后复制元素，并删除老的数组，但是这种做法会使得算法效率降低，并且也同样需要估计新数组需要多大的问题。</p>
<p>  因此，这里就如同线性表一样，除了使用数组描述，还有基于指针的描述，也就是<strong>链表描述</strong>。</p>
<h4 id="u63CF_u8FF0"><a href="#u63CF_u8FF0" class="headerlink" title="描述"></a>描述</h4><blockquote>
<p>链表描述的一种可行方案是把每行的非0元素串接在一起，构成一个链表，如下图所示。</p>
</blockquote>
<p>图中每个非阴影节点代表稀疏矩阵中的一个非0元素，它有三个域：col(非0元素所在列号)、value(非0元素的值)和link(指向下一个非阴影节点的指针)。仅当矩阵某行中至少包含一个非0元素才会为该行创建一个链表。在行链表中，每个节点按其col值得升序进行排序。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B52.png" alt="此处输入图片的描述"></p>
<p>  然后再用一个链表将所有的行链表，即图中阴影链表收集在一起。各个阴影节点按其row值得升序排列，每个阴影节点可以被视为一个行链表的头节点，因此阴影链表可以被视为头节点链表。</p>
<h4 id="u94FE_u8868_u8282_u70B9_u7C7B_u578B"><a href="#u94FE_u8868_u8282_u70B9_u7C7B_u578B" class="headerlink" title="链表节点类型"></a>链表节点类型</h4><p>  这里分别定义图中非阴影节点<strong>CNode</strong>和阴影节点<strong>HeadNode</strong>，其代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LINKMATRIX_H_&#10;#define LINKMATRIX_H_&#10;#include&#60;iostream&#62;&#10;#include&#34;ChainList.h&#34;&#10;&#10;template&#60;class T&#62;&#10;class CNode&#123;&#10;private:&#10;    int col;&#10;    T value;&#10;public:&#10;    int operator!=(const CNode&#60;T&#62;&#38; y)&#123;&#10;        return (value != y.value);&#10;    &#125;&#10;    void Output(std::ostream&#38; out)const&#123;&#10;        out &#60;&#60; &#34;column = &#34; &#60;&#60; col &#60;&#60; &#34;, value= &#34; &#60;&#60; value;&#10;    &#125;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38; out, const CNode&#60;T&#62;&#38; x)&#123;&#10;    x.Output(out);&#10;    out &#60;&#60; std::endl;&#10;    return out;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;class HeadNode&#123;&#10;private:&#10;    int row;&#10;    // &#34892;&#38142;&#34920;&#10;    Chain&#60;CNode&#60;T&#62;&#62; a;&#10;public:&#10;    int operator!=(const HeadNode&#60;T&#62;&#38; y)&#123;&#10;        return (row != y.row);&#10;    &#125;&#10;    void Output(std::ostream&#38; out)const&#123;&#10;        out &#60;&#60; &#34;row = &#34; &#60;&#60; row;&#10;    &#125;&#10;&#125;;&#10;template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38; out, const HeadNode&#60;T&#62;&#38; x)&#123;&#10;    x.Output(out);&#10;    out &#60;&#60; std::endl;&#10;    return out;&#10;&#125;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<h4 id="u7C7BLinkMatrix"><a href="#u7C7BLinkMatrix" class="headerlink" title="类LinkMatrix"></a>类LinkMatrix</h4><p>  接下来就是定义类LinkMatrix，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class LinkMatrix&#123;&#10;private:&#10;    int rows, cols;&#10;    // &#22836;&#33410;&#28857;&#38142;&#34920;&#10;    Chain&#60;HeadNode&#60;T&#62;&#62; a;&#10;public:&#10;    LinkMatrix()&#123;&#125;&#10;    ~LinkMatrix()&#123;&#125;&#10;    void Transpose(LinkMatrix&#60;T&#62;&#38; b)const;&#10;    void Add(const LinkMatrix&#60;T&#62;&#38; b, LinkMatrix&#60;T&#62;&#38; c)const;&#10;    template&#60;class T&#62;&#10;    friend std::ostream&#38; operator&#60;&#60;(std::ostream&#38;, const LinkMatrix&#60;T&#62;&#38;);&#10;    template&#60;class T&#62;&#10;    friend std::istream&#38; operator&#62;&#62;(std::istream&#38;, const LinkMatrix&#60;T&#62;&#38;);&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="u91CD_u8F7D_26gt_3B_26gt_3B"><a href="#u91CD_u8F7D_26gt_3B_26gt_3B" class="headerlink" title="重载&gt;&gt;"></a>重载&gt;&gt;</h4><p>  重载输入操作符&gt;&gt;。首先是要求输入矩阵的维数以及非0元素的个数。然后输入各个非0元素并把它们收集到各行链表中。用变量H代表当前行链表的头节点，如果下一个非0元素不属于当前行链表，则将当前行链表添加到矩阵x的头节点x.a之中；接下来，H被设置为指向一个新的行链表，同时将刚才那个非0元素添加到这个新的行链表之中。如果新的非0元素属于当前行链表，则只需要简单地把它添加到链表H.a中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;std::istream&#38; operator&#62;&#62;(std::istream&#38; in, const LinkMatrix&#60;T&#62;&#38; x)&#123;&#10;    // &#20174;&#36755;&#20837;&#27969;&#20013;&#36755;&#20837;&#30697;&#38453;x&#10;    // &#21024;&#38500;x&#20013;&#25152;&#26377;&#33410;&#28857;&#10;    x.a.Erase();&#10;    // &#33719;&#21462;&#30697;&#38453;&#29305;&#24449;&#10;    int terms;  // &#36755;&#20837;&#30340;&#20803;&#32032;&#25968;&#10;    cout &#60;&#60; &#34;Enter numbers of rows, columns, and terms\n&#34;;&#10;    in &#62;&#62; x.rows &#62;&#62; x.cols &#62;&#62; terms;&#10;    // &#34394;&#35774;&#31532;0&#34892;&#10;    HeadNode&#60;T&#62; H;  // &#24403;&#21069;&#34892;&#30340;&#22836;&#33410;&#28857;&#10;    H.row = 0;              // &#24403;&#21069;&#34892;&#21495;&#10;    // &#36755;&#20837;x&#30340;&#38750;0&#20803;&#32032;&#10;    for (int i = 1; i &#60;= terms; i++)&#123;&#10;        // &#36755;&#20837;&#19979;&#19968;&#20010;&#20803;&#32032;&#10;        cout &#60;&#60; &#34;Enter row, column, and value of term &#34; &#60;&#60; i &#60;&#60; std::endl;&#10;        int row, col;&#10;        T value;&#10;        in &#62;&#62; row &#62;&#62; col &#62;&#62; value;&#10;        // &#26816;&#26597;&#26032;&#20803;&#32032;&#26159;&#21542;&#23646;&#20110;&#24403;&#21069;&#34892;&#10;        if (row &#62; H.row)&#123;&#10;            // &#22914;&#26524;&#19981;&#26159;&#31532;0&#34892;&#65292;&#21017;&#25226;&#24403;&#21069;&#34892;&#30340;&#22836;&#33410;&#28857;H &#28155;&#21152;&#21040;&#22836;&#33410;&#28857;&#38142;&#34920;x.a&#20043;&#20013;&#10;            if (H.row)&#10;                x.a.Append(H);&#10;            // &#20026;&#26032;&#30340;&#19968;&#34892;&#20934;&#22791;H&#10;            H.row = row;&#10;            // &#32622;&#38142;&#34920;&#22836;&#25351;&#38024;first=0&#10;            H.a.Zero(); &#10;        &#125;&#10;        // &#28155;&#21152;&#26032;&#20803;&#32032;&#10;        CNode&#60;T&#62; *c = new CNode&#60;T&#62;;&#10;        c-&#62;col = col;&#10;        c-&#62;value = value;&#10;        H.a.Append(*c);&#10;    &#125;&#10;    // &#27880;&#24847;&#30697;&#38453;&#30340;&#26368;&#21518;&#19968;&#34892;&#10;    if (H.row)&#10;        x.a.Append(H);&#10;    H.a.Zero();&#10;    return in;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u91CD_u8F7D_26lt_3B_26lt_3B"><a href="#u91CD_u8F7D_26lt_3B_26lt_3B" class="headerlink" title="重载&lt;&lt;"></a>重载&lt;&lt;</h4><p>  这里为了输出链表表示的稀疏矩阵，使用了一个链表遍历器依次检查头节点链表中的每个节点。代码的时间复杂性与非0元素的数目呈正比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38; out, const LinkMatrix&#60;T&#62;&#38; x)&#123;&#10;    // &#25226;&#30697;&#38453;x&#36865;&#33267;&#36755;&#20986;&#27969;&#10;    ChainIterator&#60;HeadNode&#60;T&#62;&#62; p;   // &#22836;&#33410;&#28857;&#36941;&#21382;&#22120;&#10;    // &#36755;&#20986;&#30697;&#38453;&#30340;&#32500;&#25968;&#10;    out &#60;&#60; &#34;rows = &#34; &#60;&#60; x.rows &#60;&#60; &#34;,columns = &#34; &#60;&#60; x.cols &#60;&#60; std::endl;&#10;    // &#23558;h&#25351;&#21521;&#31532;&#19968;&#20010;&#22836;&#33410;&#28857;&#10;    HeadNode&#60;T&#62; *h = p.Initialize(x.a);&#10;    if (!h)&#123;&#10;        out &#60;&#60; &#34;No non-zero terms\n&#34;;&#10;        return out;&#10;    &#125;&#10;    // &#27599;&#27425;&#36755;&#20986;&#19968;&#34892;&#10;    while (h)&#123;&#10;        out &#60;&#60; &#34;row = &#34; &#60;&#60; h-&#62;row &#60;&#60; std::endl;&#10;        out &#60;&#60; h-&#62;a &#60;&#60; &#34;\n&#34;;        // &#36755;&#20986;&#34892;&#38142;&#34920;&#65307;&#10;        // &#19979;&#19968;&#20010;&#22836;&#33410;&#28857;&#10;        h = p.Next();&#10;    &#125;&#10;    return out;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u51FD_u6570Tranpose"><a href="#u51FD_u6570Tranpose" class="headerlink" title="函数Tranpose"></a>函数Tranpose</h4><p>  对于转置操作，可以采用箱子来从矩阵<em>this中收集位于同一行的非0元素。<em>*bin[i]</em></em>是结果矩阵b中第i行非0元素所对应的链表。其实现如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void LinkMatrix&#60;T&#62;::Transpose(LinkMatrix&#60;T&#62;&#38; b)const&#123;&#10;    // &#36716;&#32622; *this&#65292;&#24182;&#25226;&#32467;&#26524;&#25918;&#20837;b&#10;    b.a.Erase();&#10;    // &#21019;&#24314;&#29992;&#26469;&#25910;&#38598;b&#20013;&#21508;&#34892;&#20803;&#32032;&#30340;&#31665;&#23376;&#10;    Chain&#60;CNode&#60;T&#62;&#62; *bin;&#10;    bin = new Chain&#60;CNode&#60;T&#62;&#62;[cols + 1];&#10;    // &#22836;&#33410;&#28857;&#36941;&#21382;&#22120;&#10;    ChainIterator&#60;HeadNode&#60;T&#62;&#62; p;&#10;    // h &#25351;&#21521;*this&#30340;&#31532;&#19968;&#20010;&#22836;&#33410;&#28857;&#10;    HeadNode&#60;T&#62; *h = p.Initialize(a);&#10;    // &#25226;*this&#30340;&#20803;&#32032;&#22797;&#21046;&#21040;&#31665;&#23376;&#20013;&#10;    while (h)&#123;&#10;        int r = h-&#62;row;&#10;        // &#34892;&#38142;&#34920;&#36941;&#21382;&#22120;&#10;        ChainIterator&#60;CNode&#60;T&#62;&#62; q;&#10;        // &#23558;z&#25351;&#21521;&#34892;&#38142;&#34920;&#30340;&#31532;&#19968;&#20010;&#33410;&#28857;&#10;        CNode&#60;T&#62; *z = q.Initialize(h-&#62;a);&#10;        // &#20020;&#26102;&#33410;&#28857;&#10;        CNode&#60;T&#62; x;&#10;        // *this&#31532;r&#34892;&#20013;&#30340;&#20803;&#32032;&#21464;&#25104;b&#20013;&#31532;r&#21015;&#30340;&#20803;&#32032;&#10;        x.col = r;&#10;        // &#26816;&#26597;*this&#31532;r&#34892;&#30340;&#25152;&#26377;&#38750;0&#20803;&#32032;&#10;        while (z)&#123;&#10;            x.value = z-&#62;value;&#10;            bin[z-&#62;col].Append(x);&#10;            z = q.Next();&#10;        &#125;&#10;        h = p.Next();&#10;    &#125;&#10;    // &#35774;&#32622;b&#30340;&#32500;&#25968;&#10;    b.rows = cols;&#10;    b.cols = rows;&#10;    // &#35013;&#37197;b&#30340;&#22836;&#33410;&#28857;&#38142;&#34920;&#10;    HeadNode&#60;T&#62; H;&#10;    // &#25628;&#32034;&#31665;&#23376;&#10;    for (int i = 1; i &#60;= cols; i++)&#123;&#10;        if (!bin[i].isEmpty())&#123;&#10;            // &#36716;&#32622;&#30697;&#38453;&#30340;&#31532;i&#34892;&#10;            H.row = i;&#10;            H.a = bin[i];&#10;            b.a.Append(H);&#10;            bin[i].Zero();&#10;        &#125;&#10;    &#125;&#10;    H.a.Zero();&#10;    delete[] bin;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中while循环所需要的时间与非0元素的数目呈线性关系，for循环所需要的时间则与输入矩阵的列数呈线性关系，因此总的时间与这两个量的和呈线性关系。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  到这里，第四章数组和矩阵的内容就结束了。本小节主要介绍稀疏矩阵的内容，暂时来说，对于数组描述的掌握是要更好于链表描述的，还需要好好琢磨琢磨，研究一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍稀疏矩阵的内容。这也是本章节最后一节内容。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" cla]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵3-特殊矩阵]]></title>
    <link href="http://ccc013.github.io/2016/07/05/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B53-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/07/05/数组和矩阵3-特殊矩阵/</id>
    <published>2016-07-05T12:06:20.000Z</published>
    <updated>2016-07-05T12:07:03.764Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍几种特殊矩阵的内容。</p>
<h3 id="u5B9A_u4E49_u548C_u5E94_u7528"><a href="#u5B9A_u4E49_u548C_u5E94_u7528" class="headerlink" title="定义和应用"></a>定义和应用</h3><blockquote>
<p>方阵是指具有相同行数和列数的矩阵。</p>
</blockquote>
<p>一些常用的特殊方阵如下：</p>
<blockquote>
<ul>
<li><strong>对角矩阵</strong> $M$是一个对角矩阵，当前仅当$i \neq j$时，有$M(i,j)=0$。如下图a所示</li>
<li><strong>三对角矩阵</strong> $M$是一个三对角矩阵，当前仅当$|i-j| \gt 1$时有$M(i,j)=0$。如下图b所示</li>
<li><strong>下三角矩阵</strong> $M$是一个下三角矩阵，当前仅当$i\lt j$时有$M(i,j)=0$。如下图c所示</li>
<li><strong>上三角矩阵</strong> $M$是一个上三角矩阵，当前仅当$i\gt j$时有$M(i,j)=0$。如下图d所示</li>
<li><strong>对称矩阵</strong> $M$是一个对称矩阵，当前仅当对于所有的$i 和 j$有$M(i,j)=M(j,i)$。如下图e所示</li>
</ul>
</blockquote>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%9F%A9%E9%98%B52.png" alt="此处输入图片的描述"></p>
<h3 id="u5BF9_u89D2_u77E9_u9635"><a href="#u5BF9_u89D2_u77E9_u9635" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>  可以采用<code>T d[n][n]</code>这样的二维数组来描述一个元素类型为T的$n \times n$对角矩阵D。<br>  使用数组元素<code>d[i-1][j-1]</code>来表示矩阵元素<strong>D(i,j)</strong>，这种描述形式所需要的存储空间为$n^2 * sizeof(T)$。</p>
<p>  由于一个对角矩阵最大包含n个非0元素，所以可以采用<code>T d[n]</code>一维数组来描述对角矩阵。其中使用<code>d[i-1]</code>表示矩阵元素<strong>D(i,i)</strong>，而根据对角矩阵的定义，所有未在一维数组中出现的矩阵元素均为0.</p>
<p>  这里使用如下自定义类<strong>DiagonalMatrix</strong>来实现这种描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DIAGONALMATRIX_H_&#10;#define DIAGONALMATRIX_H_&#10;&#10;template&#60;class T&#62;&#10;class DiagonalMatrix&#123;&#10;private:&#10;    // &#30697;&#38453;&#32500;&#25968;&#10;    int n;&#10;    // &#23384;&#20648;&#23545;&#35282;&#20803;&#32032;&#30340;&#19968;&#32500;&#25968;&#32452;&#10;    T *d;       &#10;public:&#10;    DiagonalMatrix(int size = 10): n(size)&#123;&#10;        d = new T[n];&#10;    &#125;&#10;    ~DiagonalMatrix()&#123; delete[] d; &#125;&#10;    DiagonalMatrix&#60;T&#62;&#38; Store(const T&#38; x, int i, int j);&#10;    T Retrieve(int i, int j)const;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;DiagonalMatrix&#60;T&#62;&#38; DiagonalMatrix&#60;T&#62;::Store(const T&#38;x, int i, int j)&#123;&#10;    // &#23558;x&#23384;&#20026;D(i,j)&#10;    if (i&#60;1 || j&#60;1 || i&#62;n || j&#62;n)&#10;        throw OutOfBounds();&#10;    if (i != j &#38;&#38; x != 0)&#10;        // &#24517;&#39035;&#28385;&#36275;&#23545;&#35282;&#30697;&#38453;&#30340;&#26465;&#20214;&#65306;i != j &#26102;&#65292;x&#24517;&#39035;&#20026;0&#10;        throw MustBeZero();&#10;    if (i == j)&#10;        d[i - 1] = x;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;T DiagonalMatrix&#60;T&#62;::Retrieve(int i, int j)const&#123;&#10;    if (i&#60;1 || j&#60;1 || i&#62;n || j&#62;n)&#10;        throw OutOfBounds();&#10;    if (i == j)&#10;        return d[i - 1];&#10;    return 0;&#10;&#125;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>对于存储和搜索操作，提供了两个不同的函数，而不是使用重载操作符()来完成。此外在存储一个值时，必须保证不会在非对角线位置放置一个非0值；而搜索一个值时，没有必要检查对角线以外的值，因此有必要对这两种情形区别对待。两个函数的复杂性均为$\theta(1)$。</p>
<h3 id="u4E09_u5BF9_u89D2_u77E9_u9635"><a href="#u4E09_u5BF9_u89D2_u77E9_u9635" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h3><p>  在一个$n \times n$三对角矩阵T中，非0元素排列在如下的三条对角线上：</p>
<ol>
<li>主对角线——<strong>i=j</strong></li>
<li>主对角线之下的对角线(称低对角线)——<strong>i=j+1</strong></li>
<li>主对角线之上的对角线(称高对角线)——<strong>i=j-1</strong></li>
</ol>
<p>这三条对角线上的元素总数为<strong>3n-2</strong>，故可以使用一个拥有3n-2个位置的一维数组来描述T。考察上述图b中所示的$4\times 4$三对角矩阵，三条对角线上总共10个元素。如果将其逐行映射到一维数组t中，则有<code>t[0:9]=[2,1,3,1,3,5,2,7,9,0]</code>;如果逐列映射到t中，则有<code>t=[2,3,1,1,5,3,2,9,7,0]</code>;如果按照对角线的次序，从最下面的对角线开始进行映射，则有<code>t=[3,5,9,2,1,2,0,1,3,7]</code>。所以这里有三种不同的方式来进行T到t的映射。<br>下面的程序定义了类<strong>TridiagonalMatrix</strong>,其中采用了对角线映射方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class TridiagonalMatrix&#123;&#10;private:&#10;    int n;&#10;    T *t;&#10;public:&#10;    TridiagonalMatrix(int size = 10) : n(size)&#123;&#10;        t = new T[3 * n - 2];&#10;    &#125;&#10;    ~TridiagonalMatrix()&#123;delete[] t;&#125;&#10;    TridiagonalMatrix&#60;T&#62;&#38; Store(const T&#38; x, int i, int j);&#10;    T Retrieve(int i, int j)const;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;TridiagonalMatrix&#60;T&#62;&#38; TridiagonalMatrix&#60;T&#62;::Store(const T&#38; x, int i, int j)&#123;&#10;    // &#25226;x&#23384;&#20026;T(i,j)&#10;    if (i&#60;1 || j&#60;1 || i&#62;n || j&#62;n)&#10;        throw OutOfBounds();&#10;    switch (i-j)&#123;&#10;        case 1:&#10;            // &#20302;&#23545;&#35282;&#32447;&#10;            t[i - 2] = x;&#10;            break;&#10;        case 0:&#10;            // &#20027;&#23545;&#35282;&#32447;&#10;            t[n - 2 + i] = x;&#10;            break;&#10;        case -1:&#10;            // &#39640;&#23545;&#35282;&#32447;&#10;            t[2 * n - 2 + i] = x;&#10;            break;&#10;        default:&#10;            if (x != 0)&#10;                throw MustBeZero();&#10;    &#125;&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;T TridiagonalMatrix&#60;T&#62;::Retrieve(int i, int j)const&#123;&#10;    if (i&#60;1 || j&#60;1 || i&#62;n || j&#62;n)&#10;        throw OutOfBounds();&#10;    switch (i - j)&#123;&#10;    case 1:&#10;        // &#20302;&#23545;&#35282;&#32447;&#10;        return t[i - 2];&#10;    case 0:&#10;        // &#20027;&#23545;&#35282;&#32447;&#10;        return t[n - 2 + i];&#10;    case -1:&#10;        // &#39640;&#23545;&#35282;&#32447;&#10;        return t[2 * n - 2 + i];&#10;    default:&#10;        return 0;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先是从最下面的对角线开始，也就是低对角线，那么T(i,j)对应的一维数组是t[i-2]，接着轮到主对角线的时候，只需要用i加上低对角线的元素总数，即n-2个，也就是对应数组t[n-2+i]，因为i是依次从1，按行逐渐增加；最后对于高对角线，也是同样的计算方法。</p>
<h3 id="u4E09_u89D2_u77E9_u9635"><a href="#u4E09_u89D2_u77E9_u9635" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>  在三角矩阵中，无论是上三角还是下三角矩阵，非0元素总数均为$\frac{n(n+1)}{2}$。</p>
<p>  两种三角矩阵都可以用一个大小为$\frac{n(n+1)}{2}$的一维数组进行描述。考虑把一个下三角矩阵映射到一个一维数组$l$，可以采用按行和按列两种不同的方式进行映射。如果按行映射，上图c中$4\times 4$下三角矩阵可以得到$l[0:9] = (2,5,1,0,3,1,4,2,7,0)$;若按列的方式，得到$l[0:9] =(2,5,0,4,1,3,2,1,7,0)$。</p>
<p>  所以对于下三角矩阵中的一个元素$L(i,j)$，如果$i\lt j$,则$L(i,j)=0$;如果$i\le j$，则$L(i,j)$位于非0元素区域，且其对应的一维数组是<strong>t[$\frac{i(i-1)}{2}+j-1$]</strong>，其映射规则是先统计前i-1行的非0元素数量然后加上当前元素所在第i行的所在列数j-1。下面给出自定义类<strong>LowerMatrix</strong>实现下三角矩阵,并且是按行来映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class LowerMatrix&#123;&#10;private:&#10;    // &#30697;&#38453;&#32500;&#25968;&#10;    int n;&#10;    // &#23384;&#20648;&#23545;&#35282;&#20803;&#32032;&#30340;&#19968;&#32500;&#25968;&#32452;&#10;    T *t;&#10;public:&#10;    LowerMatrix(int size = 10) : n(size)&#123;&#10;        t = new T[n*(n+1)/2];&#10;    &#125;&#10;    ~LowerMatrix()&#123; delete[] t; &#125;&#10;    LowerMatrix&#60;T&#62;&#38; Store(const T&#38; x, int i, int j);&#10;    T Retrieve(int i, int j)const;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;LowerMatrix&#60;T&#62;&#38; LowerMatrix&#60;T&#62;::Store(const T&#38;x, int i, int j)&#123;&#10;    // &#23558;x&#23384;&#20026;D(i,j)&#10;    if (i&#60;1 || j&#60;1 || i&#62;n || j&#62;n)&#10;        throw OutOfBounds();&#10;    // &#24403;&#21069;&#20165;&#24403; i &#62;= j&#26102;&#65292;(i,j)&#20301;&#20110;&#19979;&#19977;&#35282;&#10;    if (i &#62;= j)&#10;        t[i*(i - 1) / 2 + j - 1] = x;&#10;    else if (x != 0)&#10;        throw MustBeZero();&#10;    return *this;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;T LowerMatrix&#60;T&#62;::Retrieve(int i, int j)const&#123;&#10;    if (i&#60;1 || j&#60;1 || i&#62;n || j&#62;n)&#10;        throw OutOfBounds();&#10;    if (i &#62;= j)&#10;        return t[i*(i - 1) / 2 + j - 1];&#10;    else&#10;        return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上三角矩阵的实现方式也是相同的，只需要改变判断条件，将$i \ge j$变成$i \le j$即可。</p>
<h3 id="u5BF9_u79F0_u77E9_u9635"><a href="#u5BF9_u79F0_u77E9_u9635" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>  一个$n\times n$的对称矩阵可以用一个大小为$\frac{n(n+1)}{2}$的一维数组来描述，可参考三角矩阵的存储模式来存储矩阵的上三角或下三角，即可以根据已经存储的元素来推算出未存储的元素。即如果存储下三角的元素，当需要给出在上三角的元素，只需要将行和列对调，再来搜索即可得到需要的元素值，这样做可以更节省空间。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节主要是介绍几种特殊矩阵，都是属于方阵，分别是三角矩阵，三对角矩阵，上三角和下三角矩阵以及对称矩阵，并且都自定义类来实现这几种特殊的矩阵。</p>
<p>  更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍几种特殊矩阵的内容。</p>
<h3 id="u5B9A_u4E49_u548C_u5E94_u7528"><a href="#u5B9A_u4E49_u548C_u5E94_u7528" cl]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵2-矩阵]]></title>
    <link href="http://ccc013.github.io/2016/06/30/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B52-%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/06/30/数组和矩阵2-矩阵/</id>
    <published>2016-06-30T11:29:36.000Z</published>
    <updated>2016-06-30T11:30:32.300Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍矩阵的基本概念以及自定义一个类Matrix实现基本的矩阵操作。</p>
<h3 id="u77E9_u9635"><a href="#u77E9_u9635" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="u5B9A_u4E49_u548C_u64CD_u4F5C"><a href="#u5B9A_u4E49_u548C_u64CD_u4F5C" class="headerlink" title="定义和操作"></a>定义和操作</h4><p>  一个$m\times n$的矩阵(matrix)是一个m行、n列的表，如下图所示，其中m和n是矩阵的维数。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%9F%A9%E9%98%B51.png" alt="此处输入图片的描述"></p>
<p>对于矩阵来说，最常见的操作就是矩阵转置、矩阵加和矩阵乘。</p>
<p>一个$m\times n$矩阵的转置矩阵是一个$n\times m$的矩阵$M^T$,它与$M$之间存在以下关系：<br>$$<br>M^T(i,j) = M(j,i)\quad 1\le i\le n,\; 1\le j\le m<br>$$</p>
<p>仅当两个矩阵的维数相同时，即具有相同的行数和列数，才可以对两个矩阵求和。两个$m\times n$矩阵$A和B$相加所得到的$m\times n$矩阵$C$如下：<br>$$<br>C(i,j) =A(i,j)+B(i,j)\quad 1\le i\le n,\; 1\le j\le m<br>$$</p>
<p>仅当一个$m\times n$矩阵$A$的列数与另一个$q\times p$矩阵$B$的行数相同，即<strong>n=q</strong>,才可以执行矩阵乘法$A<em>B$。其得到的$m\times p$矩阵$C$满足以下关系：<br>$$<br>C(i,j) = \sum_{k=1}^nA(i,k)\ </em>\ B(k,j)\quad 1\le i\le m,\; 1\le j\le p<br>$$</p>
<p>矩阵加的代码实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Add( T **a, T **b, T **c, int rows, int cols)&#10;&#123;&#10;    // &#30697;&#38453; a &#21644; b &#30456;&#21152;&#24471;&#21040;&#30697;&#38453; c .&#10;    for (int i = 0; i &#60; rows; i++)&#10;        for (int j = 0; j &#60; cols; j++)&#10;             c[i][j] = a[i][j] + b[i][j];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵转置代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Transpose(T **a, int rows)&#10;&#123;&#10;    // &#23545;&#30697;&#38453; a[0:rows-1][0:rows-1] &#36827;&#34892;&#36716;&#32622;&#10;    for (int i = 0; i &#60; rows; i++)&#10;        for (int j = i+1; j &#60; rows; j++)&#10;            Swap(a[i][j], a[j][i]);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵乘法的代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Mult(T **a, T **b, T **c, int m, int n, int p)&#10;&#123;&#10;    // m x n &#30697;&#38453; a &#19982; n x p &#30697;&#38453; b&#30456;&#20056;&#24471;&#21040;c&#10;    for (int i = 0; i &#60; m; i++)&#10;        for (int j = 0; j &#60; p; j++) &#123;&#10;            T sum = 0;&#10;            for (int k = 0; k &#60; n; k++)&#10;                sum += a[i][k] * b[k][j];&#10;            c[i][j] = sum;&#10;        &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u7C7BMatrix"><a href="#u7C7BMatrix" class="headerlink" title="类Matrix"></a>类Matrix</h4><p>  这里自定义一个类Matrix来实现矩阵的功能，在该类中，使用<strong>()</strong>来指定每个元素，并且各行和各列的索引值都是从1开始的。<br>  其类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MATRIX_H_&#10;#define MATRIX_H_&#10;#include&#60;iostream&#62;&#10;using std::ostream;&#10;template&#60;class T&#62;&#10;class Matrix&#123;&#10;private:&#10;    int rows, cols;&#10;    // &#20803;&#32032;&#25968;&#32452;&#10;    T *element; &#10;public:&#10;    Matrix(int r = 0, int c = 0);&#10;    // &#22797;&#21046;&#26500;&#36896;&#20989;&#25968;&#10;    Matrix(const Matrix&#60;T&#62;&#38; m);&#10;    ~Matrix()&#123; delete[] element; &#125;&#10;    int Rows() const&#123; return rows; &#125;&#10;    int Columns() const&#123; return cols; &#125;&#10;    T&#38; operator()(int i, int j)const;&#10;    Matrix&#60;T&#62;&#38; operator=(const Matrix&#60;T&#62;&#38; m);&#10;    Matrix&#60;T&#62; operator+() const;&#10;    Matrix&#60;T&#62; operator+(const Matrix&#60;T&#62;&#38; m)const;&#10;    Matrix&#60;T&#62; operator-() const;&#10;    Matrix&#60;T&#62; operator-(const Matrix&#60;T&#62;&#38; m)const;&#10;    Matrix&#60;T&#62; operator*(const Matrix&#60;T&#62;&#38; m)const;&#10;    Matrix&#60;T&#62;&#38; operator+=(const T&#38; m);&#10;    void Output(ostream&#38; out) const;&#10;&#125;;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>构造函数，复制构造函数以及赋值运算符的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Matrix&#60;T&#62;::Matrix(int r, int c)&#123;&#10;    if (r &#60; 0 || c &#60; 0)&#10;        throw BadInitializers();&#10;    if ((!r || !c) &#38;&#38; (r || c))&#10;        throw BadInitializers();&#10;    rows = r;&#10;    cols = c;&#10;    element = new T[r*c];&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Matrix&#60;T&#62;::Matrix(const Matrix&#60;T&#62;&#38; m)&#123;&#10;    // &#22797;&#21046;&#26500;&#36896;&#20989;&#25968;&#10;    rows = m.rows;&#10;    cols = m.cols;&#10;    element = new T[rows*cols];&#10;    int size = rows * cols;&#10;    for (int i = 0; i &#60; size; i++)&#10;        element[i] = m.element[i];&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Matrix&#60;T&#62;&#38; Matrix&#60;T&#62;::operator=(const Matrix&#60;T&#62;&#38; m)&#123;&#10;    // &#37325;&#36733;&#36171;&#20540;&#36816;&#31639;&#31526;=&#10;    if (*this != &#38;m)&#123;&#10;        rows = m.rows;&#10;        cols = m.cols;&#10;        delete[] element;&#10;        element = new T[rows*cols];&#10;        int size = rows * cols;&#10;        for (int i = 0; i &#60; size; i++)&#10;            element[i] = m.element[i];&#10;    &#125;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了重载矩阵下标操作法(),使用了C++的函数操作符()，与数组的下标操作法[]不同的是，该操作符可以带任意数量的参数。对于一个矩阵来说，需要两个整数参数。如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;T&#38; Matrix&#60;T&#62;::operator()(int i, int j)const&#123;&#10;    // &#36820;&#22238;&#19968;&#20010;&#25351;&#21521;&#20803;&#32032;(i,j)&#30340;&#24341;&#29992;&#10;    if (i&#60;1 || i&#62;rows || j&#60;1 || j&#62;cols)&#10;        throw OutOfBounds();&#10;    return element[(i - 1)*cols + j - 1];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>二元减法的代码如下，矩阵加法操作符，一元减法操作符，增值操作符和输出操作符的代码都比较类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Matrix&#60;T&#62; Matrix&#60;T&#62;::operator-(const Matrix&#60;T&#62;&#38; m)const&#123;&#10;    if (rows != m.rows || cols != m.cols)&#10;        throw SizeMismatch();&#10;    Matrix&#60;T&#62; w(rows, cols);&#10;    for (int i = 0; i &#60; rows * cols; i++)&#123;&#10;        w.element[i] = element[i] - m.element[i];&#10;    &#125;&#10;    return w;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵乘法实现如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Matrix&#60;T&#62; Matrix&#60;T&#62;::operator*(const Matrix&#60;T&#62;&#38; m)const&#123;&#10;    // &#30697;&#38453;&#20056;&#27861; &#36820;&#22238;w = (*this) * m&#10;    if (cols != m.rows)&#10;        throw SizeMismatch();&#10;    Matrix&#60;T&#62; w(rows, m.cols);&#10;    int ct = 0, cm = 0, cw = 0;&#10;    for (int i = 1; i &#60;= rows; i++)&#123;&#10;        // &#35745;&#31639;&#20986;&#32467;&#26524;&#30340;&#31532;i&#34892;&#10;        for (int j = 1; j &#60;= m.cols; j++)&#123;&#10;            // &#35745;&#31639;w(i,j)&#30340;&#31532;&#19968;&#39033;&#10;            T sum = element[ct] * m.element[cm];&#10;            // &#32047;&#21152;&#20854;&#20313;&#39033;&#10;            for (int k = 2; k &#60;= cols; k++)&#123;&#10;                // &#25351;&#21521;*this&#31532;i&#34892;&#30340;&#19979;&#19968;&#20010;&#20803;&#32032;&#10;                ct++;&#10;                // &#25351;&#21521;m&#30340;&#31532;j&#21015;&#30340;&#19979;&#19968;&#39033;&#10;                cm += m.cols;&#10;                sum += element[ct] * m.element[cm];&#10;            &#125;&#10;            // &#20445;&#23384;w(i,j)&#10;            w.element[cw++] = sum;&#10;            // &#37325;&#26032;&#35843;&#25972;&#33267;&#34892;&#39318;&#21644;&#19979;&#19968;&#21015;&#10;            ct -= cols - 1;&#10;            cm = j;&#10;        &#125;&#10;        // &#37325;&#26032;&#35843;&#25972;&#33267;&#19979;&#19968;&#34892;&#30340;&#34892;&#39318;&#21644;&#31532;&#19968;&#21015;&#10;        ct += cols;&#10;        cm = 0;&#10;    &#125;&#10;    return w;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a></p>
<h5 id="u590D_u6742_u6027"><a href="#u590D_u6742_u6027" class="headerlink" title="复杂性"></a>复杂性</h5><p>  当T是一个内部数据类型时，矩阵构造函数复杂性是$O(1)$，当T是一个用户自定义类时，构造函数的复杂性是$O(rows<em>cols)$，下标操作符的复杂性是$\theta(1)$,乘法操作符的复杂性是$O(rows</em>cols*m.cols)$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍矩阵的基本概念以及自定义一个类Matrix实现基本的矩阵操作。</p>
<h3 id="u77E9_u9635"><a href="#u77E9_u9635" class="headerlink]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵1--数组]]></title>
    <link href="http://ccc013.github.io/2016/06/28/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B51-%E6%95%B0%E7%BB%84/"/>
    <id>http://ccc013.github.io/2016/06/28/数组和矩阵1-数组/</id>
    <published>2016-06-28T06:55:14.000Z</published>
    <updated>2016-06-28T06:58:54.524Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍数组的内容。</p>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><h4 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><blockquote>
<p>数据对象<strong>array</strong>的每个实例都是形如<strong>(index, value)</strong>的数据对集合，其中任意两对数据的<strong>index</strong>值都各不相同。</p>
</blockquote>
<p>数组的抽象数据类型描述如下所示：</p>
<blockquote>
<p>抽象数据类型 Array{<br>实例<br>    形如 (index , value)的数据对集合，其中任意两对数据的 index 值都各不相同<br>操作<br>   $\color{red}{Create()}$：创建一个空的数组<br>   $\color{red}{Store(index, value)}$：添加数据(index, value)，同时删除具有相同index值的数据对（如果存在）<br>   $\color{red}{Retrieve(index)}$：返回索引值为 index的数据对<br>}</p>
</blockquote>
<h4 id="C++_u6570_u7EC4"><a href="#C++_u6570_u7EC4" class="headerlink" title="C++数组"></a>C++数组</h4><p>  在C++中数组是一个标准的数据结构，但C++数组的索引(也称为下标)必须采用如下形式：$[i_1][i_2][i_3]\ldots [i_k]$.<br>  $i_j$是一个非负整数，如果k为1，则数组是一个一维数组，如果k是2，则是二维数组。$i_1$是索引的第一个坐标，$i_2$是第二个，$i_k$是第k个。在C++中，值为整数类型的k维数组<code>score</code>可用如下语句来创建：<br>$$<br>int\; \; score[u_1][u_2][u_2]\ldots [u_k]<br>$$<br>该数组最大可用容纳$n = u_1u_2u_2\ldots u_k$个值。由于数组是存储int类型的整数，所以每个元素需要<code>sizeof(int)</code>个字节，因此，整个数组所需要的存储空间为<strong>sizeof(score) = n * sizeof(int)</strong>个字节。C++编译器将为数组预留这么多空间。加入预留空间的起始地址为<code>start</code>，则该空间将延伸至<code>start+sizeof(score)-1</code>。</p>
<h4 id="u884C_u4E3B_u6620_u5C04_u548C_u5217_u4E3B_u6620_u5C04"><a href="#u884C_u4E3B_u6620_u5C04_u548C_u5217_u4E3B_u6620_u5C04" class="headerlink" title="行主映射和列主映射"></a>行主映射和列主映射</h4><p>  为了实现与数组相关的函数<code>Store</code>和<code>Retrieve</code>，必须确定<strong>索引值</strong>在<strong>[start,start+sizeof(score)-1]</strong>中的相应位置。实际上就是把数组索引$[i_1][i_2][i_3]\ldots [i_k]$映射到<code>[0,n-1]</code>中的某个数$map(i_1,i_2,i_3,\ldots ,i_k)$,使得该索引所对应的元素值存储在以下位置$start+map(i_1,i_2,i_3,\ldots ,i_k)*sizeof(int)$。</p>
<p>  当数组维数是1时，即k=1，使用以下函数：$map(i_1) = i_1$</p>
<p>  当数组维数是2时，各索引可按下图所示的表格形式进行排列。第一个坐标相同的位于同一行，第二个坐标相同的索引位于同一列。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%841.png" alt="此处输入图片的描述"><br>  对上图从第一行开始，依次对每一行中的每个索引从左至右进行连续编号，即可得到下图a所示的映射结果。<strong>这种把二维数组中的位置映射为[0,n-1]中某个数的方式被称为行主映射</strong>。C++中即采用了这种行主映射模式。而下图b则给出了另一种模式，称为列主映射。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%842.png" alt="此处输入图片的描述"></p>
<p>  行主映射中所对应的映射函数为：$map(i_1,i_2) = i_1 * u_2 + i_2$</p>
<p>  其中$u_2$是数组的列数。这里的$i_1,i_2$都是从0开始。</p>
<p>  根据上述的行主映射模式可以得到二维以上的映射函数。比如对于三维数组，其行主映射函数为$map(i_1,i_2,i_3) = i_1u_2u_3+i_2u_3+i_3$</p>
<p>  对于k维数组，其行主映射函数为$map(i_1,i_2,i_3,\ldots ,i_k) = i_1u_2u_3\ldots u_k + i_2u_3\ldots u<em>k+\dots+i</em>{k-1}u_k+i_k$</p>
<h4 id="u7C7BArray1D"><a href="#u7C7BArray1D" class="headerlink" title="类Array1D"></a>类Array1D</h4><p>  C++中虽然支持一维数组，但是这种支持还不够，比如不能使用超出正常范围之外的索引值，如索引值必须都是正整数，不能使用负数。</p>
<p>  为了克服这些不足，定义了类Array1D,代码如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef ARRAY1D_H_&#10;#define ARRAY1D_H_&#10;&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class Array1D&#123;&#10;private:&#10;    int size;&#10;    T *element;     // &#19968;&#32500;&#25968;&#32452;&#10;public:&#10;    Array1D(int size = 0);&#10;    // &#22797;&#21046;&#26500;&#36896;&#20989;&#25968;&#10;    Array1D(const Array1D&#60;T&#62;&#38; x);   &#10;    ~Array1D()&#123; delete[] element; &#125;&#10;    T&#38; operator[](int i)const;&#10;    int Size()&#123; return size; &#125;&#10;    Array1D&#60;T&#62;&#38; operator=(const Array1D&#60;T&#62;&#38; v);&#10;    // &#19968;&#20803;&#21152;&#27861;&#25805;&#20316;&#31526;&#10;    Array1D&#60;T&#62; operator+()const;&#10;    Array1D&#60;T&#62; operator+(const Array1D&#60;T&#62;&#38; v)const;&#10;    // &#19968;&#20803;&#20943;&#27861;&#25805;&#20316;&#27861;&#10;    Array1D&#60;T&#62; operator-() const;&#10;    Array1D&#60;T&#62; operator-(const Array1D&#60;T&#62;&#38; v)const;&#10;    Array1D&#60;T&#62; operator*(const Array1D&#60;T&#62;&#38; v)const;&#10;    Array1D&#60;T&#62;&#38; operator+=(const T&#38; x);&#10;&#125;;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>该类每个实例X都是一个一维数组。X的元素都存储在数组<code>X.element</code>中，第i个元素为于<code>X.element[i]</code>，$0 \le i \lt size$。</p>
<p>这个类的共享成员包括: 构造函数，复制构造函数，析构函数，下标操作法[]，返回数组大小的函数Size，算术操作符+、-、*和+=。下面首先是给出构造函数和复制构造函数的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Array1D&#60;T&#62;::Array1D(int sz)&#123;&#10;    if (sz &#60;= 0)&#10;        throw BadInitializers();&#10;    size = sz;&#10;    element = new T[size];&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;Array1D&#60;T&#62;::Array1D(const Array1D&#60;T&#62;&#38; v)&#123;&#10;    // &#22797;&#21046;&#26500;&#36896;&#20989;&#25968;&#10;    size = v.size;&#10;    element = new T[size];&#10;    for (int i = 0; i &#60; size; i++)&#10;        element[i] = v.element[i];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出重载操作符[]的代码，该操作符用来返回指向第i个元素的引用，可以使存储和查询操作很自然干的方式进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;T&#38; Array1D&#60;T&#62;::operator[](int i)const&#123;&#10;    // &#36820;&#22238;&#31532;i&#20010;&#20803;&#32032;&#30340;&#24341;&#29992;&#10;    if (i &#60; 0 || i &#62;= size)&#10;        throw OutOfBounds();&#10;    return element[i];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来给出赋值操作符的代码。首先需要避免进行自我赋值，然后需要先释放目标数组<code>*this</code>所占用的空间，然后再分配一个新的空间，并进行赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Array1D&#60;T&#62;&#38; Array1D&#60;T&#62;::operator=(const Array1D&#60;T&#62;&#38;&#65366;)&#123;&#10;    // &#37325;&#36733;&#36171;&#20540;&#36816;&#31639;&#31526;&#10;    if (this != &#38;v)&#123;&#10;        // &#19981;&#26159;&#33258;&#25105;&#36171;&#20540;&#10;        size = v.size;&#10;        delete[] element;&#10;        element = new T[size];&#10;        // &#22797;&#21046;&#20803;&#32032;&#10;        for (int i = 0; i &#60; size; i++)&#10;            element[i] = v.element[i];&#10;    &#125;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>当T是一个内部C++数据类型(如int，float和char)时，构造函数和析构函数的复杂性是$\theta(1)$,而当T是一个用户自定义的类时，构造函数和析构函数的复杂性是$O(size)$。存在这种差异的原因是：<strong>当T是一个用户自定义类时，在用new(delete)创建(删除)数组element的过程中，对于element的每个元素都要调用一次T的构造函数(析构函数)。</strong>下标操作法[]的复杂性是$\theta(1)$,其他操作符的复杂性均为$O(size)$（注意复杂性不会是$\theta(size)$，因为所有操作符的代码都可以引发一个异常并提前终止）。</p>
<p>下面给出测试的代码及结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void testArray1D()&#123;&#10;    Array1D&#60;int&#62; a(10);&#10;    Array1D&#60;int&#62; b(10);&#10;&#10;    for (int i = 0; i &#60; 10; i++)&#10;        a[i] = i * 2;&#10;    &#10;    cout &#60;&#60; &#34;a is \n&#34;;&#10;    for (int i = 0; i &#60; 10; i++)&#10;        cout &#60;&#60; a[i] &#60;&#60;&#34; &#34;;&#10;    cout &#60;&#60; endl;&#10;&#10;    b = a;&#10;    cout &#60;&#60; &#34;b=a, so b is \n&#34;;&#10;    for (int i = 0; i &#60; 10; i++)&#10;        cout &#60;&#60; b[i] &#60;&#60; &#34; &#34;;&#10;    cout &#60;&#60; endl;&#10;&#10;    cout &#60;&#60; &#34;c= a+b,so c :\n&#34;;&#10;    Array1D&#60;int&#62; c(10);&#10;    c = a + b;&#10;    for (int i = 0; i &#60; 10; i++)&#10;        cout &#60;&#60; c[i] &#60;&#60; &#34; &#34;;&#10;    cout &#60;&#60; endl;&#10;&#10;    Array1D&#60;int&#62; d(10) ;&#10;    cout &#60;&#60; &#34;a*c = \n&#34;;&#10;    d = a*c;&#10;    for (int i = 0; i &#60; 10; i++)&#10;        cout &#60;&#60; d[i] &#60;&#60; &#34; &#34;;&#10;    cout &#60;&#60; endl;&#10;&#10;    Array1D&#60;int&#62; e(10);&#10;    cout &#60;&#60; &#34;c-b = \n&#34;;&#10;    e = c - b;&#10;    for (int i = 0; i &#60; 10; i++)&#10;        cout &#60;&#60; e[i] &#60;&#60; &#34; &#34;;&#10;    cout &#60;&#60; endl;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%843.png" alt="此处输入图片的描述"></p>
<p>完整例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a>.</p>
<h4 id="u7C7BArray2D"><a href="#u7C7BArray2D" class="headerlink" title="类Array2D"></a>类Array2D</h4><p>  对于二维数组，可以定义一个类Array2D。程序如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef ARRAY2D_H_&#10;#define ARRAY2D_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class Array2D&#123;&#10;private:&#10;    int rows, cols; // &#25968;&#32452;&#32500;&#25968;&#10;    Array1D&#60;T&#62; *row;        // &#19968;&#32500;&#25968;&#32452;&#30340;&#25968;&#32452;&#10;public:&#10;    Array2D(int r = 0, int c = 0);&#10;    Array2D(const Array2D&#60;T&#62;&#38; m);&#10;    ~Array2D() &#123; delete[] row; &#125;&#10;    int Rows() const&#123; return rows; &#125;&#10;    int Columns() const&#123; return cols; &#125;&#10;    Array1D&#60;T&#62; &#38; operator[](int i)const;&#10;    Array2D&#60;T&#62;&#38; operator=(const Array2D&#60;T&#62;&#38; v);&#10;    // &#19968;&#20803;&#21152;&#27861;&#25805;&#20316;&#31526;&#10;    Array2D&#60;T&#62; operator+()const;&#10;    Array2D&#60;T&#62; operator+(const Array2D&#60;T&#62;&#38; v)const;&#10;    // &#19968;&#20803;&#20943;&#27861;&#25805;&#20316;&#27861;&#10;    Array2D&#60;T&#62; operator-() const;&#10;    Array2D&#60;T&#62; operator-(const Array2D&#60;T&#62;&#38; v)const;&#10;    Array2D&#60;T&#62; operator*(const Array2D&#60;T&#62;&#38; v)const;&#10;    Array2D&#60;T&#62;&#38; operator+=(const T&#38; x);&#10;&#125;;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>在定义中使用一维数组<code>row</code>来存储每个行数组。</p>
<p>下面给出构造函数实现的代码，其中的方法<code>Resize</code>是<code>Array1D</code>新增加的一个成员函数，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Array1D&#60;T&#62;&#38; Array1D&#60;T&#62;::Resize(int sz)&#123;&#10;    delete[] element;&#10;    size = sz;&#10;    element = new T[sz];&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Array2D&#60;T&#62;::Array2D(int r, int c)&#123;&#10;    if (r &#60; 0 || c &#60; 0)&#10;        throw BadInitializers();&#10;    if ((!r || !c) &#38;&#38; (r || c))&#10;        throw BadInitializers();&#10;    rows = r;&#10;    cols = c;&#10;    row = new Array1D&#60;T&#62;[r];&#10;    for (int i = 0; i &#60; r; i++)&#10;        row[i].Resize(c);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面则是给出复制构造函数的实现，复制构造函数首先会创建一个具有给定位置数的数组<code>row</code>，然后利用一维数组的赋值操作符复制二维数组中的每一行数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Array2D&#60;T&#62;::Array2D(const Array2D&#60;T&#62;&#38; m)&#123;&#10;    rows = m.rows;&#10;    cols = m.cols;&#10;    // &#20998;&#37197;&#25351;&#21521;&#19968;&#32500;&#25968;&#32452;&#30340;&#25968;&#32452;&#10;    row = new Array1D&#60;T&#62;[rows];&#10;    // &#22797;&#21046;&#27599;&#19968;&#34892;&#10;    for (int i = 0; i &#60; rows; i++)&#10;        row[i] = m.row[i];&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>乘法操作符的实现类似于矩阵乘，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#30697;&#38453;&#20056;&#10;template&#60;class T&#62;&#10;Array2D&#60;T&#62; Array2D&#60;T&#62;::operator*(const Array2D&#60;T&#62;&#38; m)const&#123;&#10;    if (cols != m.cols)&#10;        throw SizeMismatch();&#10;    Array2D&#60;T&#62; w(rows, m.cols);&#10;    for (int i = 0; i &#60; rows; i++)&#123;&#10;            for (int j = 0; j &#60; m.cols; j++)&#123;&#10;                T sum = (*this)[i][0] * m[0][j];&#10;                for (int k = 1; k &#60; cols; k++)&#10;                    sum += (*this)[i][k] * m[k][j];&#10;                w[i][j] = sum;&#10;            &#125;&#10;    &#125;&#10;    return w;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节介绍了数组，并自定义了一个一维数组类<code>Array1D</code>以及二维数组类<code>Array2D</code>。</p>
<p>  虽然是增加了不少方法，但是感觉用起来是没有C++的数组那么方便。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍数组的内容。</p>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据描述3-间接寻址&模拟指针]]></title>
    <link href="http://ccc013.github.io/2016/06/16/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B03-%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%88/"/>
    <id>http://ccc013.github.io/2016/06/16/数据描述3-间接寻址-模拟指针/</id>
    <published>2016-06-16T12:15:33.000Z</published>
    <updated>2016-06-16T12:19:18.447Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节讲述间接寻址和模拟指针的内容。</p>
<h3 id="u95F4_u63A5_u5BFB_u5740"><a href="#u95F4_u63A5_u5BFB_u5740" class="headerlink" title="间接寻址"></a>间接寻址</h3><h4 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>间接寻址(indirect addressing)是公式化描述和链表描述的组合。</p>
</blockquote>
<p>采用这种描述方法，可以保留公式化描述的优点–<strong>可以根据索引在$\theta(1)$的时间内访问每个元素，可采用二叉搜索方法在对数时间内对一个有序表进行搜索等等</strong>。同时，也可以获得链表描述方法的重要特色–<strong>在诸如插入和删除操作期间不必对元素进行实际的移动</strong>，因此大多数间接寻址链表操作的时间复杂性都与元素的总数无关。<br>  间接寻址中，使用一个指针表来跟踪每个元素。元素本身可能存储在动态分配的节点或者节点数组之中。下图给出一个采用间接寻址表table描述的5元素线性表。其中table[i]是一个指针，它指向表中的第i+1个元素，length是表的长度。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%801.png" alt="此处输入图片的描述"></p>
<p>间接寻址方法和链表描述方法都使用了指针域。在链表方式中，指针位于每个节点中，而在间接寻址方式中，指针完全放在数组table中。<br>下面给出了类定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef INDRECTLIST_H_&#10;#define INDRECTLIST_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class IndrectList&#123;&#10;private:&#10;    T **table;      // &#19968;&#32500;T&#31867;&#22411;&#25351;&#38024;&#25968;&#32452;&#10;    int length, MaxSize;&#10;public:&#10;    IndrectList(int MaxListSize = 10);&#10;    ~IndrectList();&#10;    bool isEmpty() const&#123; return length == 0; &#125;&#10;    int Length() const &#123; return length; &#125;&#10;    bool Find(int k, T&#38;x)const;&#10;    int Search(const T&#38; x)const;&#10;    IndrectList&#60;T&#62;&#38; Delete(int k, T&#38; x);&#10;    IndrectList&#60;T&#62;&#38; Insert(int k, const T&#38; x);&#10;    void Output(std::ostream&#38; out)const;&#10;&#125;;&#10;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  下面给出构造函数和析构函数的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;IndrectList&#60;T&#62;::IndrectList(int MaxListSize)&#123;&#10;    MaxSize = MaxListSize;&#10;    table = new T *[MaxSize];&#10;    length = 0;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;IndrectList&#60;T&#62;::~IndrectList()&#123;&#10;    // &#21024;&#38500;&#34920;&#10;    for (int i = 0; i &#60; length; i++)&#10;        delete table[i];&#10;    delete[] table;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>Length</code>和<code>IsEmpty</code>都已经被定义为内联函数。假设$1\le k \le length$,第k个元素可以由<code>table[k-1]</code>之后的下一个指针指出，对x进行搜索可以通过依次检查指针table[0]、table[1]、…所指向的元素。下面给出<code>Find和Search</code>函数的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;bool IndrectList&#60;T&#62;::Find(int k, T&#38; x)const&#123;&#10;    if (k&#60;1 || k&#62;length)&#10;        return false;&#10;    x = *table[k - 1];&#10;    return true;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;int IndrectList&#60;T&#62;::Search(const T&#38; x)const&#123;&#10;    // &#36820;&#22238;x&#25152;&#22788;&#20301;&#32622;&#65292;&#22914;&#26524;&#27809;&#26377;&#21017;&#36820;&#22238;0&#65307;&#10;    for (int i = 0; i &#60; length; i++)&#123;&#10;        if (*table[i] == x)&#10;            return ++i;&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除操作需要移动要删除的元素后面的指针，相对于公式化操作中需要移动的是表中的元素。删除操作实现如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;IndrectList&#60;T&#62;&#38; IndrectList&#60;T&#62;::Delete(int k, T&#38;x)&#123;&#10;    if (Find(k, x))&#123;&#10;        // &#21521;&#21069;&#31227;&#21160;&#25351;&#38024;&#10;        for (int i = k; i &#60; length; i++)&#10;            table[i - 1] = table[i];&#10;        length--;&#10;        return *this;&#10;    &#125;&#10;else &#10;    throw OutOfBounds();&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述实现中，首先是借助<code>Find</code>函数寻找到需要删除的第k个元素，然后将第k个元素开始的所有指针都往前移动一位。</p>
<p>插入操作和删除操作相反，需要将指针往后移动，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;IndrectList&#60;T&#62;&#38; IndrectList&#60;T&#62;::Insert(int k, const T&#38; x)&#123;&#10;    if (k&#60;0 || k&#62;length)&#10;        throw OutOfBounds();&#10;    if (length == MaxSize)&#10;        throw NoMem();&#10;    // &#21521;&#21518;&#31227;&#21160;&#19968;&#20301;&#10;    for (int i = length - 1; i &#62;= k; i--)&#10;        table[i + 1] = table[i];&#10;    table[k] = new T;&#10;    *table[k] = x;&#10;    length++;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入操作在最坏情况下的时间复杂性是$O(length)$,而对于公式化操作，其最坏情况下的时间复杂性是$O(s*length)$,其中<strong>s</strong>是一个T类型的元素的大小。</p>
<p>更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/IndirectList.h" target="_blank" rel="external">github</a></p>
<h3 id="u6A21_u62DF_u6307_u9488"><a href="#u6A21_u62DF_u6307_u9488" class="headerlink" title="模拟指针"></a>模拟指针</h3><p>  在大多数应用中，可以利用动态分配及C++指针来实现链表和间接寻址表。不过有时候，可以采用一个节点数组以及对该数组进行索引的模拟指针，可以使设计更方便、更高效。</p>
<p>  假设采用一个数组node，该数组的每个元素都包含两个域：<strong>data和link</strong>。数组中的节点分别是<code>node[0]、node[1]、...、node[NumberOfNodes - 1]</code>。下面用<strong>节点i</strong>来代表<strong>node[i]</strong>。如果一个单向链表<strong>c</strong>由节点10，5和24按顺序构成，那么将得到<strong>c=10</strong>（指向链表<strong>c</strong>的第一个节点的指针是整数类型)，<code>node[10].link = 5</code>（指向第二个节点的指针），<code>node[5].link = 24，node[24].link=-1(表示节点24是链表中的最后一个节点)</code>。该链表如下图所示：<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%881.png" alt="此处输入图片的描述"></p>
<p>  为了实现指针的模拟，需要设计一个过程来分配和释放一个节点。当前未被使用的节点将被放入一个存储池之中。开始时，存储池中包含了所有节点<code>node[0:NumberOfNodes-1]</code>。<strong>Allocate</strong>从存储池中取出节点，每次取出一个。而<strong>Deallocate</strong>则将节点放入存储池中，每次放入一个。因此<strong>Allocate和Deallocate</strong>分别对存储池执行插入和删除操作，等价于C++函数的new和delete。如果存储池是一个节点链表，如下所示，这两个函数就可以高效地执行。用作存储池的链表被称之为<strong>可用空间表</strong>，其中包含了当前未使用的所有节点。<strong>first</strong>是一个类型为int的变量，它指向可用空间表的第一个节点，添加和删除操作都是在可用空间表的前部进行的。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%882.png" alt="此处输入图片的描述"></p>
<p>  代码实现如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SIMPOINTER_H_&#10;#define SIMPOINTER_H_&#10;&#10;template&#60;class T&#62;&#10;class SimNode&#123;&#10;    T data;&#10;    int link;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;class SimSpace&#123;&#10;private:&#10;    int NumberOfNodes, first;&#10;    SimNode&#60;T&#62;*node;    // &#33410;&#28857;&#25968;&#32452;&#10;public:&#10;    SimSpace(int MaxSpaceSize = 100);&#10;    ~SimSpace()&#123; delete[] node; &#125;&#10;    // &#20998;&#37197;&#19968;&#20010;&#33410;&#28857;&#10;    int Allocate();&#10;    // &#37322;&#25918;&#33410;&#28857;i&#10;    void Deallocate(int&#38; i);&#10;&#125;;&#10;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<p>  上述就是节点数组以及可用空间表的代码实现。</p>
<h4 id="SimSpace_u7684_u64CD_u4F5C"><a href="#SimSpace_u7684_u64CD_u4F5C" class="headerlink" title="SimSpace的操作"></a>SimSpace的操作</h4><p>  由于所有节点初始时都是自由的，因此在刚被创建的时候，可用空间表中包含<code>NumberOfNodes</code>个节点。代码实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;SimSpace&#60;T&#62;::SimSpace(int MaxSpaceSize)&#123;&#10;    NumberOfNodes = MaxSpaceSize;&#10;    node = new SimNode&#60;T&#62;[NumberOfNodes];&#10;    // &#21021;&#22987;&#21270;&#21487;&#29992;&#31354;&#38388;&#34920;&#65292;&#21019;&#24314;&#19968;&#20010;&#33410;&#28857;&#38142;&#34920;&#10;    for (int i = 0; i &#60; NumberOfNodes-1; i++)&#10;        node[i].link = i + 1;&#10;    // &#38142;&#34920;&#30340;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#10;    node[NumberOfNodes - 1].link = -1;&#10;    // &#38142;&#34920;&#30340;&#31532;&#19968;&#20010;&#33410;&#28857;&#10;    first = 0;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;int SimSpace&#60;T&#62;::Allocate()&#123;&#10;    // &#20998;&#37197;&#19968;&#20010;&#33258;&#30001;&#33410;&#28857;&#10;    if (first == -1)&#10;        throw NoMem();&#10;    int i = first;&#10;    first = node[i].link;    // first &#25351;&#21521;&#19979;&#19968;&#20010;&#33258;&#30001;&#33410;&#28857;&#10;    return i;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void SimSpace&#60;T&#62;::Deallocate(int &#38; i)&#123;&#10;    // &#37322;&#25918;&#33410;&#28857;&#10;    // &#20351;i&#25104;&#20026;&#21487;&#29992;&#31354;&#38388;&#34920;&#30340;&#31532;&#19968;&#20010;&#33410;&#28857;&#10;    node[i].link = first;&#10;    first = i;&#10;    i = -1;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面三个函数的时间复杂性分别是$\theta(NumberOfNodes),\theta(1),\theta(1)$。</p>
<p>通过使用两个可用空间表，可用减少构造函数的运行时间，其中第一个表包含所有尚未被使用的自由节点，第二个表包含所有已被至少使用过一次的自由节点。每当一个节点被释放时，就被放入第二个表中。当需要一个新节点时，如果第二个表非空，则从该表中取出一个节点，否则从第一个表中取出一个节点。令<strong>first1</strong>和<strong>first2</strong>分别指向第一个表和第二个表的首节点。<br>基于上述分配节点的方式，第一个表中的元素是<code>node[i]</code>，其中$first1 \le i \lt NumberOfNodes$。释放节点的代码与上述代码中<code>Deallocate</code>方法的唯一区别是所有<strong>first</strong>变量均替换成<strong>first2</strong>。新的构造函数和分配函数如下所示。为了使新函数能正常工作，需要把整型变量<strong>first1</strong>和<strong>first2</strong>设置为<strong>SimSpace</strong>的私有成员变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;SimSpace&#60;T&#62;::SimSpace(int MaxSpaceSize)&#10;&#123; &#10;    // &#20351;&#29992;&#20004;&#20010;&#21487;&#29992;&#31354;&#38388;&#34920;&#30340;&#26500;&#36896;&#20989;&#25968;&#10;    NumberOfNodes = MaxSpaceSize;&#10;    node = new SimNode&#60;T&#62; [NumberOfNodes];&#10;    // &#21021;&#22987;&#21270;&#21487;&#29992;&#31354;&#38388;&#34920;&#10;    firstl = 0;&#10;    first2 = -1;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;int SimSpace&#60;T&#62;::Allocate()&#10;&#123; &#10;    // &#20998;&#37197;&#19968;&#20010;&#33258;&#30001;&#33410;&#28857;&#10;    if (first2 == -1) &#123;// &#31532;2&#20010;&#34920;&#20026;&#31354;&#10;    if (firstl == NumberOfNodes) throw NoMem();&#10;    return firstl++;&#125;&#10;    // &#20998;&#37197;&#38142;&#34920;&#20013;&#30340;&#31532;&#19968;&#20010;&#33410;&#28857;&#10;    int i = first2;&#10;    first2 = node[i].link;&#10;    return i;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83"><a href="#u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83" class="headerlink" title="描述方法的比较"></a>描述方法的比较</h3><p>  下图给出了本章四种数据描述方法执行各种链表操作所需要的时间复杂性。表中，<strong>s</strong>和<strong>n</strong>分别表示<strong>sizeof(T)</strong>和链表长度。由于采用C++指针和采用模拟指针完成这些操作所需要的时间复杂性完全相同，因此表中把这两种情形的时间复杂性合并在一行中进行描述。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%883.png" alt="此处输入图片的描述"></p>
<p>  有上述表格以及前面所学的知识可以得到以下结论：</p>
<ol>
<li>使用间接寻址与使用链表描述所需要的空间大致相同，二者都比使用公式化描述所需要的空间更多。</li>
<li>链表描述和间接寻址，在执行链表的插入和删除操作所需要的时间复杂性都与链表元素本身的大小无关；相反，使用公式化描述时，插入和删除操作的复杂性与元素的本身大小呈<strong>线性关系</strong>。</li>
<li>公式化描述和间接寻址，在确定表的长度以及访问表中第k个元素所需要的时间复杂性均为$\theta(1)$;而使用链表描述，这两种操作的时间复杂性分别是$\theta(length)$和$O(k)$。</li>
<li>间接寻址比较适合这样的应用：表元素本身很大，较频繁地进行插入、删除操作以及确定表的长度、访问第k个元素。</li>
<li>如果线性表本身已经按序排列，那么使用公式化描述或间接寻址进行搜索所需要时间均为$O(logn)$,而使用链表描述时，所需要的时间是$O(n)$.</li>
</ol>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节介绍了间接寻址和模拟指针两种实现线性表的方法。间接寻址还是可以理解的，实际上就是综合了公式化描述和链表描述的特点，指向数据元素的指针使用一个数组(实现代码中是命名为<strong>table</strong>)来存放，数据元素放在动态分配的节点数组中。这样数组的顺序也就是每个元素存放的顺序，这样有利于快速访问第k个元素，同时在插入和删除操作方面需要移动的是指针在数组的位置，而不是元素本身，速度也是相对更快。</p>
<p>  对于模拟指针，由于还是首次接触，所以还是不太熟悉，有不少地方是还没怎么弄懂的，要好好再看看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节讲述间接寻址和模拟指针的内容。</p>
<h3 id="u95F4_u63A5_u5BFB_u5740"><a href="#u95F4_u63A5_u5BFB_u5740" class="header]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据描述2--单向链表]]></title>
    <link href="http://ccc013.github.io/2016/06/09/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B02-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/06/09/数据描述2-单向链表/</id>
    <published>2016-06-09T10:07:41.000Z</published>
    <updated>2016-06-14T01:03:57.695Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节主要介绍链表，以及单向链表和单向循环链表，双向链表的介绍。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><h4 id="u7C7BChainNode_u548CNode"><a href="#u7C7BChainNode_u548CNode" class="headerlink" title="类ChainNode和Node"></a>类ChainNode和Node</h4><blockquote>
<p>链表描述中，数据对象实例的每个元素都放在单元或节点中进行描述，不过每个节点不必是一个数组元素，但都包含了与该节点相关的其他节点的位置信息，这种关于其他节点的位置信息被称为链(link)或指针(pointer)。</p>
</blockquote>
<p>令$L=(e_1,e_2,\ldots,e_n)$是一个线性表，其链表描述如下图所示，每个节点都包含一个链接域，用以指向表中的下一个元素。所以节点$e_i$的指针将指向$e_{i+1}$，其中$1\le i \lt n$。节点$e_n$没有下一个节点，所以它的链接域是<strong>NULL(或0)</strong>。指针变量<code>first</code>指向描述中的第一个节点。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A81.png" alt="此处输入图片的描述"></p>
<p>上图中每个节点都正好有一个链接域，所以该图的链表结构被称之为<strong>单向链表</strong>，此外，这种结构由于是每个节点的指针都指向下一个节点，然后最后一个节点的链接域是NULL，故也称为<strong>链(chain)</strong>。<strong>这里定义的<code>Chain&lt;T&gt;</code>是<code>ChainNode&lt;T&gt;</code>的一个友类，即<code>Chain&lt;T&gt;</code>可以访问<code>ChainNode&lt;T&gt;</code>的所有成员(尤其是私有成员)。</strong>其类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;&#10;// &#24517;&#39035;&#20808;&#22768;&#26126;&#65292;&#21542;&#21017;&#21451;&#20803;&#27169;&#26495;&#31867;&#20043;&#38388;&#26080;&#27861;&#30452;&#25509;&#35775;&#38382;&#65292;&#20250;&#20986;&#29616;&#26410;&#23450;&#20041;&#30340;&#38169;&#35823;&#12290;&#10;template&#60;class T&#62;&#10;class Chain;&#10;&#10;&#10;template&#60;class T&#62;&#10;class ChainNode&#123;&#10;    friend Chain&#60;T&#62;;&#10;private:&#10;    T data;&#10;    ChainNode&#60;T&#62; * link;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;class Chain&#123;&#10;private:&#10;    // &#25351;&#21521;&#31532;&#19968;&#20010;&#33410;&#28857;&#30340;&#25351;&#38024;&#10;    ChainNode&#60;T&#62; *first;&#10;public:&#10;    Chain()&#123; first = 0; &#125;&#10;    ~Chain();&#10;    bool isEmpty() const&#123; return first == 0; &#125;&#10;    int Length() const;&#10;    bool Find(int k, T&#38; x)const;&#10;    int Search(const T&#38; x)const;&#10;    Chain&#60;T&#62;&#38; Delete(int k, T&#38; x);&#10;    Chain&#60;T&#62;&#38; Insert(int k, const T&#38;x);&#10;    void Output(std::ostream&#38; out)const;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  下面给出析构函数，<code>Length,Find,Search,Output</code>函数的代码实现，其中析构函数的复杂性是$\theta(n)$,n是链表的长度，而<code>Length</code>的复杂性是$\theta(n)$,<code>Find</code>的复杂性$O(k)$,函数<code>Search</code>的复杂性是$O(n)$,<code>Output</code>的复杂性是$\theta(n)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Chain&#60;T&#62;::~Chain()&#123;&#10;    // &#21024;&#38500;&#38142;&#34920;&#20013;&#30340;&#25152;&#26377;&#33410;&#28857;&#10;    ChainNode&#60;T&#62; *next;&#10;    while (first)&#123;&#10;        next = first-&#62;link;&#10;        delete first;&#10;        first = next;&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;int Chain&#60;T&#62;::Length() const&#123;&#10;    // &#36820;&#22238;&#38142;&#34920;&#20013;&#30340;&#20803;&#32032;&#24635;&#25968;&#10;    ChainNode&#60;T&#62; *current = first;&#10;    int len = 0;&#10;    while (current)&#123;&#10;        len++;&#10;        current = current-&#62;link;&#10;    &#125;&#10;    return len;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;bool Chain&#60;T&#62;::Find(int k, T&#38;x)const&#123;&#10;    // &#23547;&#25214;&#38142;&#34920;&#20013;&#30340;&#31532;k&#20010;&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#20256;&#36865;&#32773;x&#10;    if (k &#60; 1)&#10;        return false;&#10;    ChainNode&#60;T&#62; *current = first;&#10;    // current&#30340;&#32034;&#24341;&#10;    int index = 1;  &#10;    while (index &#60; k &#38;&#38; current)&#123;&#10;        current = current-&#62;link;&#10;        index++;&#10;    &#125;&#10;    if (current)&#123;&#10;        x = current-&#62;data;&#10;        return true;&#10;    &#125;&#10;    // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;    return false;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;int Chain&#60;T&#62;::Search(const T&#38; x)const&#123;&#10;    // &#23547;&#25214;x&#65292;&#22914;&#26524;&#21457;&#29616;x&#65292;&#21017;&#36820;&#22238;x&#30340;&#20301;&#32622;&#10;    ChainNode&#60;T&#62; *current = first;&#10;    // current&#30340;&#32034;&#24341;&#10;    int index = 1;&#10;    while (current &#38;&#38; current-&#62;data != x)&#123;&#10;        index++;&#10;        current = current-&#62;link;&#10;    &#125;&#10;    if (current)&#10;        return index;&#10;    return 0;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void Chain&#60;T&#62;::Output(std::ostream&#38; out)const&#123;&#10;    //  &#23558;&#38142;&#34920;&#20803;&#32032;&#36865;&#33267;&#36755;&#20986;&#27969;&#10;    ChainNode&#60;T&#62; *current;&#10;    for (current = first; current; current = current-&#62;link)&#123;&#10;        out &#60;&#60; current-&#62;data &#60;&#60; &#34; &#34;;&#10;    &#125;&#10;&#125;&#10;// &#37325;&#36733; &#60;&#60;&#10;template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38; out, const Chain&#60;T&#62;&#38; x)&#123;&#10;    x.Output(out);&#10;    return out;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="u5220_u9664_u64CD_u4F5C"><a href="#u5220_u9664_u64CD_u4F5C" class="headerlink" title="删除操作"></a>删除操作</h5><p>  假如要从下图中删除第四个元素，需要进行如下操作：</p>
<ol>
<li>找到第三和第四个节点；</li>
<li>使第三个节点指向第五个节点；</li>
<li>释放第四个节点所占空间，以便于重用。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A82.png" alt="此处输入图片的描述"><br>代码实现如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Chain&#60;T&#62;&#38; Chain&#60;T&#62;::Delete(int k, T&#38;x)&#123;&#10;    // &#25226;&#31532;k&#20010;&#20803;&#32032;&#21462;&#33267;x&#65292;&#28982;&#21518;&#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#10;    if (k &#60; 1 || !first)&#10;        // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;        throw OutOfBounds();&#10;    // p&#26368;&#32456;&#25351;&#21521;&#31532;k&#20010;&#33410;&#28857;&#10;    ChainNode&#60;T&#62; *p = first;&#10;    if (k == 1)&#10;        // p&#24050;&#32463;&#25351;&#21521;&#31532;k&#20010;&#20803;&#32032;&#10;        first = first-&#62;link;&#10;    else&#123;&#10;        // q&#29992;&#20110;&#31227;&#21160;&#21040;&#31532;k-1&#20010;&#33410;&#28857;&#10;        ChainNode&#60;T&#62;*q = first;&#10;        for (int index = 1; index &#60; k - 1 &#38;&#38; q; index++)&#10;            q = q-&#62;link;&#10;        if (!q || !q-&#62;link)&#10;            // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;            throw OutOfBounds();&#10;        // &#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;        p = q-&#62;link;&#10;        // &#35753;&#19978;&#19968;&#20010;&#33410;&#28857;&#25351;&#21521;&#24453;&#21024;&#38500;&#33410;&#28857;&#21518;&#38754;&#30340;&#33410;&#28857;&#10;        q-&#62;link = p-&#62;link;&#10;    &#125;&#10;    // &#20445;&#23384;&#31532;k&#20010;&#20803;&#32032;&#30340;&#20540;&#65292;&#28982;&#21518;&#37322;&#25918;&#33410;&#28857;&#10;    x = p-&#62;data;&#10;    delete p;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里有三种情形要考虑，分别如下：</p>
<ul>
<li>k小于1或链表为空；</li>
<li>第一个元素将被删除且链表不为空；</li>
<li>从一个非空的链表中删除非首元素的元素。</li>
</ul>
<p>程序中首先就处理第一种情形，即引发<code>OutOfBounds</code>异常。然后声明一个指针变量<code>p</code>用于最终指向第k个元素，对于第二种情形，语句<code>first = first-&gt;link;</code>就可以用来删除第一个元素；对于第三种情形，首先是定义了新的指针变量<code>q</code>，然后通过一个for循环让q定位到第k-1个元素，此时如果链表的节点数少于k-1，则q为0，也是引发<code>OutOfBounds</code>异常，否则就让p指向第k个元素，并保存其值，然后释放该节点。</p>
<h5 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h5><p>  插入操作和删除操作很相似，要在链表第k个元素之后插入一个新的元素，需要首先找到第k个元素，然后在该节点后面插入新的节点。程序实现如下所示，其时间复杂性是$O(k)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Chain&#60;T&#62;&#38; Chain&#60;T&#62;::Insert(int k, const T&#38; x)&#123;&#10;    // &#22312;&#31532;k&#20010;&#20803;&#32032;&#21518;&#38754;&#25554;&#20837;x&#10;    if (k &#60; 0)&#10;        throw OutOfBounds();&#10;    ChainNode&#60;T&#62; *p = first;&#10;    for (int index = 1; index &#60; k &#38;&#38; p; index++)&#10;        p = p-&#62;link;&#10;    if (k&#62;0 &#38;&#38; !p)&#10;        // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;        throw OutOfBounds();&#10;    ChainNode&#60;T&#62; *newNode = new ChainNode&#60;T&#62;;&#10;    newNode-&#62;data = x;&#10;    if (k)&#123;&#10;        newNode-&#62;link = p-&#62;link;&#10;        p-&#62;link = newNode;&#10;    &#125;&#10;    else&#123;&#10;        // k=0,&#21363;&#20316;&#20026;&#31532;&#19968;&#20010;&#20803;&#32032;&#25554;&#20837;&#10;        newNode-&#62;link = first;&#10;        first = newNode;&#10;    &#125;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样在插入操作中需要注意的是$k=0$和$k \neq 0$两种情形下的插入操作，前者是作为第一个元素插入，需要使用到指向第一个节点的指针<code>first</code>。</p>
<h4 id="u6269_u5145_u7C7BChain"><a href="#u6269_u5145_u7C7BChain" class="headerlink" title="扩充类Chain"></a>扩充类Chain</h4><p>  这里会在之前的抽象数据类型<code>LinearList</code>中的操作上增加一些新的方法，比如<code>Erase</code>（删除链表中的所有节点)、<code>Zero</code>(将first指针置为0，但并不删除任何节点)、<code>Append</code>(在链表的尾部添加一个元素)。<br>  对于函数<code>Erase</code>，其等价于类的析构函数，实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21024;&#38500;&#38142;&#34920;&#20013;&#30340;&#25152;&#26377;&#33410;&#28857;&#10;template&#60;class T&#62;&#10;void Chain&#60;T&#62;::Erase()&#123;&#10;    ChainNode&#60;T&#62; *next;&#10;    while (first)&#123;&#10;        next = first-&#62;link;&#10;        delete first;&#10;        first = next;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而函数<code>Zero</code>则可以定义为如下的内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Zero() &#123; first = 0; &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于函数<code>Append</code>，为了在$\theta(1)$的时间内添加一个元素，需要在类中添加一个新的类型是<code>ChainNode&lt;T&gt; *</code>的私有成员<code>last</code>来跟踪链表的最后一个元素。同时需要在插入和删除操作中各自添加一条语句，即在<code>Delete</code>函数中的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;p = q-&#62;link;</span><br></pre></td></tr></table></figure></p>
<p>后面增加下列语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22914;&#26524;&#21018;&#22909;&#26159;&#31532;k&#20010;&#33410;&#28857;&#26159;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#10;if (p == last)&#10;    last = q;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Insert</code>操作中的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return *this;</span><br></pre></td></tr></table></figure></p>
<p>前面添加下面的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22914;&#26524;&#26032;&#25554;&#20837;&#30340;&#33410;&#28857;&#26159;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#10;if (!newNode-&#62;link)&#10;    last = y;</span><br></pre></td></tr></table></figure></p>
<p>最后，<code>Append</code>函数的代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22312;&#38142;&#34920;&#26411;&#23614;&#21491;&#31471;&#28155;&#21152;&#19968;&#20010;&#20803;&#32032;&#10;template&#60;class T&#62;&#10;Chain&#60;T&#62;&#38; Chain&#60;T&#62;::Append(const T&#38;x)&#123;&#10;    ChainNode&#60;T&#62; *newNode;&#10;    newNode = new ChainNode&#60;T&#62;;&#10;    newNode-&#62;data = x;&#10;    newNode-&#62;link = 0;&#10;    if (first)&#123;&#10;        // &#38142;&#34920;&#38750;&#31354;&#10;        last-&#62;link = newNode;&#10;        last = newNode;&#10;    &#125;&#10;    else&#123;&#10;        first = last = newNode;&#10;    &#125;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要判断链表是否为空的问题，如果是空，则令<code>first = last = newNode</code>;</p>
<h4 id="u94FE_u8868_u904D_u5386_u5668_u7C7B"><a href="#u94FE_u8868_u904D_u5386_u5668_u7C7B" class="headerlink" title="链表遍历器类"></a>链表遍历器类</h4><p>  这里使用一个链表遍历器，遍历器的功能是记录当前位置并每次向前移动一个位置。在如下实现的遍历器程序中，有两个共享成员<strong>Initialize</strong>和<strong>Next</strong>。<br>  <strong>Initialize</strong>返回一个指针，其指向第一个链表节点中包含的数据，同时把私有变量<strong>location</strong>设置为指向链表的第一个节点，该变量用来跟踪我们在链表中所处的位置。而成员<strong>Next</strong>用来调整<strong>location</strong>，使其指向链表中的下一个节点，并返回指向该节点数据域的指针。由于遍历器类访问了<strong>Chain</strong>类的私有成员，所以应把它定义为<strong>Chain</strong>的友类(实际上应该还需要定义为<strong>ChainNode</strong>的友类，因为也是访问了其私有成员<strong>data</strong>)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#38142;&#34920;&#36941;&#21382;&#22120;&#31867;&#10;template&#60;class T&#62;&#10;class ChainIterator&#123;&#10;private:&#10;    ChainNode&#60;T&#62; *location;&#10;public:&#10;    T* Initialize(const Chain&#60;T&#62;&#38; c)&#123;&#10;        location = c.first;&#10;        if (location)&#10;            return &#38;location-&#62;data;&#10;        return 0;&#10;    &#125;&#10;    T* Next()&#123;&#10;        if (!location)&#10;            // &#38142;&#34920;&#20026;&#31354;&#10;            return 0;&#10;        location = location-&#62;link;&#10;        if (location)&#10;            return &#38;location-&#62;data;&#10;        return 0;&#10;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其使用例子如下,此时<strong>Output</strong>函数不是<strong>Chain</strong>类的成员函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Output(const Chain&#60;T&#62;&#38; X)&#123;&#10;    int *x;&#10;    ChainIterator&#60;T&#62; c;&#10;    x = c.Initialize(X);&#10;    while (x)&#123;&#10;        cout &#60;&#60; *x &#60;&#60; &#39; &#39;;&#10;        x = c.Next();&#10;    &#125;&#10;    cout &#60;&#60; endl;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用遍历器可以实现在线性时间内输出链表，如上述程序所示。</p>
<p>更完整的例子可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/ChainList.h" target="_blank" rel="external">ChainList</a></strong>。</p>
<h4 id="u5FAA_u73AF_u94FE_u8868"><a href="#u5FAA_u73AF_u94FE_u8868" class="headerlink" title="循环链表"></a>循环链表</h4><p>  我们可以采纳下面一条或两条措施使得链表的应用代码可以更加简洁和高效：</p>
<ol>
<li>把线性表描述成一个<strong>单向循环链表</strong>，或简称<strong>循环链表</strong>；</li>
<li>在链表的前部增加一个附加的节点，称之为<strong>头节点</strong>。</li>
</ol>
<p>通过把单向链表最后一个节点的链接指针改为指向第一个节点，就可以把一个单向链表改造成循环链表，如下图(a)所示，而图(b)给出了一个带有头指针的非空的循环链表，图(c)给出了一个带有头指针的空的循环链表。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A83.png" alt="此处输入图片的描述"><br><code>CircularList</code>类的定义与<code>Chain</code>类定义相似。尽管链表搜索的复杂性仍然保持为$O(n)$，但代码本身要稍微简单一些，如下所示，程序在for循环的每次循环中执行的比较次数较少，因此会比<code>Chain</code>类中的搜索运行得更快一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;int CircularList&#60;T&#62;::Search(const T&#38; x)const&#123;&#10;    // &#22312;&#24102;&#26377;&#22836;&#33410;&#28857;&#30340;&#24490;&#29615;&#38142;&#34920;&#20013;&#26597;&#25214;x&#10;    ChainNode&#60;T&#62;* current = first-&#62;link;&#10;    int index = 1;&#10;    first-&#62;data = x;    // &#25226;x&#25918;&#20837;&#22836;&#33410;&#28857;&#10;    while (current-&#62;data != x)&#123;&#10;        current = current-&#62;link;&#10;        index++;&#10;    &#125;&#10;    // &#21028;&#26029;&#26159;&#21542;&#26159;&#38142;&#34920;&#22836;&#33410;&#28857;&#10;    return ((current == first) ? 0 : index);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>更完整的<code>CircularList</code>可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/LinearList" target="_blank" rel="external">github</a></p>
<h4 id="u4E0E_u516C_u5F0F_u5316_u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83"><a href="#u4E0E_u516C_u5F0F_u5316_u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83" class="headerlink" title="与公式化描述方法的比较"></a>与公式化描述方法的比较</h4><p>  使用公式化描述方法的线性表仅需要能够保持所有元素的空间以及保存表长的空间，而链表和循环链表描述还需要额外的空间，用来保存链接指针。<strong>采用链表描述所实现的插入和删除操作要比公式化描述时执行得更快，当每个元素都很长时(字节数多)，尤其如此。</strong></p>
<p>  还可以使用链接模式来描述很多表，这样做不会降低空间利用率，也不会降低执行效率；而对于公式化描述，为了提高空间利用率，不得不把所有的表都放在一个数组中，并使用了另外两个数组来对这个数组进行索引，更有甚者，与一个表对应一个数组的情形相比，插入和删除操作变得更加复杂，而且存在一个很显著的最坏运行时间。<br>  采用公式化描述，可以在$\theta(1)$的时间内访问第k个元素，而这种操作在链表中是需要$O(k)$。</p>
<h4 id="u53CC_u5411_u94FE_u8868"><a href="#u53CC_u5411_u94FE_u8868" class="headerlink" title="双向链表"></a>双向链表</h4><blockquote>
<p>双向链表就是每个链表元素既有指向下一个元素的指针，又有指向前一个元素的指针。</p>
</blockquote>
<p>下图是一个双向链表表示。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A84.png" alt="此处输入图片的描述"></p>
<p>双向链表的类定义如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class DoubleNode&#123;&#10;    T data;&#10;    DoubleNode&#60;T&#62;*left, *right;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;class DoubleChainList&#123;&#10;private:&#10;    DoubleNode&#60;T&#62;* LeftEnd, *RightEnd;&#10;public:&#10;    DoubleChainList()&#123; LeftEnd = RightEnd = 0 &#125;;&#10;    ~DoubleChainList();&#10;    int Length() const;&#10;    bool Find(int k, T&#38; x)const;&#10;    int Search(const T&#38; x)const;&#10;    DoubleChainList&#60;T&#62;&#38; Delete(int k, T&#38; x);&#10;    DoubleChainList&#60;T&#62;&#38; Insert(int k, const T&#38; x);&#10;    void Output(std::ostream &#38; out)const;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此外在双向链表的左部和/或右部添加头节点，并且把链表变成循环的链表，可以提高双向链表的性能。在一个非空的双向链表中，<code>LeftEnd-&gt;left</code>是一个指向最右边结点的指针(即<code>RightEnd</code>),<code>RightEnd-&gt;right</code>是一个指向最左边节点的指针，这样可以省去<code>RightEnd</code>，只需要简单地使用变量<code>LeftEnd</code>来跟踪链表。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节主要介绍链表，以及单向链表和单向循环链表，双向链表的介绍。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0"]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据描述1--线性表]]></title>
    <link href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/06/08/数据描述1-线性表/</id>
    <published>2016-06-08T04:49:32.000Z</published>
    <updated>2016-06-08T04:53:11.929Z</updated>
    <content type="html"><![CDATA[<p>《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。</p>
<p>本章的重点是介绍线性表，但一个主要目标是让大家明白–<strong>数据可以用不同的形式进行描述或存储在计算机存储器中。</strong>最常见的数据买欧式方法有：<strong>公式化描述、链接描述、间接寻址和模拟指针。</strong></p>
<p><strong>公式化描述</strong></p>
<blockquote>
<p>公式化描述借助数学公式来确定元素表中的每个元素分别存储在何处(如存储器地址)。最简单的情形就是把所有元素依次连续存储在一片连续的存储空间中，这就是通常 所说的连续线性表。</p>
</blockquote>
<p><strong>链接描述</strong></p>
<blockquote>
<p>链接描述中，元素表中的每个元素可以存储在存储器的不同区域汇总，每个元素都包含指向下一个元素的指针。</p>
</blockquote>
<p><strong>间接寻址</strong></p>
<blockquote>
<p>间接寻址中，元素表的每个元素也是可以存储在存储器的不同区域中，但与链接描述不同的是，此时必须保存一张表，该表的第i项指向元素表中的第i个元素，所以这张表是一个用来保存元素地址的表。</p>
</blockquote>
<p><strong>模拟指针</strong></p>
<blockquote>
<p>模拟指针非常类似于链接描述，区别在于它用整数代替了C++指针，整数所扮演的角色与指针所扮演的角色完全相同。</p>
</blockquote>
<p><strong>数据对象</strong>是一组实例或值，比如布尔值，整数，浮点数，字符串等。数据结构包括数据对象和实例以及构成实例的每个元素之间所存在的各种关系，这些关系可由相关的函数来实现。</p>
<h3 id="u7EBF_u6027_u8868_u7B80_u4ECB"><a href="#u7EBF_u6027_u8868_u7B80_u4ECB" class="headerlink" title="线性表简介"></a>线性表简介</h3><blockquote>
<p>定义：线性表示这样的数据对象，其实例形式为：$(e_1,e_2,\ldots,e_n)$,其中n是有穷自然数。</p>
</blockquote>
<p>当n=0时，表为空；当$n\gt 0$,$e_1$是第一个元素，$e_n$是最后一个元素，可以认为$e_1$优先于$e_2$,$e_2$优先于$e_3$,如此等等。除了这种优先关系外，在线性表中不再有其他的结构。我们可用<strong>s</strong>来表示每个元素$e_i$所需要的字节数，即<strong>s</strong>是一个元素的大小。</p>
<p>以下是一些线性表的例子：</p>
<ul>
<li>一个班级学生姓名按字母顺序排列的列表；</li>
<li>按递增次序排列的考试分数表；</li>
<li>按字母依次排列的会议列表。</li>
</ul>
<p>根据这些例子可以知道对于线性表有必要执行下列操作：</p>
<ul>
<li>创建一个线性表；</li>
<li>确定线性表是否为空；</li>
<li>确定线性表的长度；</li>
<li>查找第k个元素；</li>
<li>查找指定的元素；</li>
<li>删除第k个元素；</li>
<li>在第k个元素之后插入一个新的元素。</li>
</ul>
<p>下面用一个抽象数据类型(abstract data type, ADT)来说明线性表，它给出了实例以及相关操作的描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411;LinearList &#123;&#10;&#23454;&#20363;&#10;0&#25110;&#22810;&#20010;&#20803;&#32032;&#30340;&#26377;&#24207;&#38598;&#21512;&#10;&#25805;&#20316;&#10;Create(): &#21019;&#24314;&#19968;&#20010;&#31354;&#32447;&#24615;&#34920;&#10;Destroy(): &#21024;&#38500;&#34920;&#10;IsEmpty(): &#22914;&#26524;&#34920;&#20026;&#31354;&#21017;&#36820;&#22238;true&#65292;&#21542;&#21017;&#36820;&#22238;false&#10;Length(): &#36820;&#22238;&#34920;&#30340;&#22823;&#23567; (&#21363;&#34920;&#20013;&#20803;&#32032;&#20010;&#25968;)&#10;Find(k,x): &#23547;&#25214;&#34920;&#20013;&#31532;k &#20010;&#20803;&#32032;&#65292;&#24182;&#25226;&#23427;&#20445;&#23384;&#21040; x &#20013;&#65307;&#22914;&#26524;&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238;false&#10;Search(x): &#36820;&#22238;&#20803;&#32032;x&#22312;&#34920;&#20013;&#30340;&#20301;&#32622;&#65307;&#22914;&#26524;x &#19981;&#22312;&#34920;&#20013;&#65292;&#21017;&#36820;&#22238;0&#10;Delete(k,x): &#21024;&#38500;&#34920;&#20013;&#31532;k&#20010;&#20803;&#32032;&#65292;&#24182;&#25226;&#23427;&#20445;&#23384;&#21040; x &#20013;&#65307;&#20989;&#25968;&#36820;&#22238;&#20462;&#25913;&#21518;&#30340;&#32447;&#24615;&#34920;&#10;Insert(k,x): &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#65307;&#20989;&#25968;&#36820;&#22238;&#20462;&#25913;&#21518;&#30340;&#32447;&#24615;&#34920;&#10;Output(out): &#25226;&#32447;&#24615;&#34920;&#25918;&#20837;&#36755;&#20986;&#27969; out &#20043;&#20013;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h3><h4 id="u57FA_u672C_u63CF_u8FF0"><a href="#u57FA_u672C_u63CF_u8FF0" class="headerlink" title="基本描述"></a>基本描述</h4><blockquote>
<p>公式化描述采用<strong>数组</strong>来表示一个对象的实例，数组中的每个位置被称之为单元(cell)或节点(node)，每个数组单元应该足够大，以便能够容纳数据对象实例中的任意一个元素。</p>
</blockquote>
<p>实例中每个元素在数组中的位置可以用一个数学公式来指明，一个简单的映射公式如下：</p>
<pre><code>location(i) = i - 1
</code></pre><p>上述公式指明表中第i个元素(如果存在)位于数组中i-1位置处。</p>
<p>下面的程序给出了相应的C++类定义。由于表元素的数据类型随着应用的变化而变化，所以定义了一个模板类，在该模板类中，用户指定元素的数据类型是T。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LINEARLIST_H_&#10;#define LINEARLIST_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class LinearList&#10;&#123;&#10;private:&#10;    int MaxSize;&#10;    T *element;&#10;    int length;     // &#24403;&#21069;&#32447;&#24615;&#34920;&#30340;&#38271;&#24230;&#10;public:&#10;    LinearList(int MaxListSize = 10);&#10;    ~LinearList()&#123; delete[] element; &#125;&#10;    bool isEmpty() const&#123; return length == 0; &#125;&#10;    int Length() const &#123; return length; &#125;&#10;    // &#36820;&#22238;&#31532;k&#20010;&#20803;&#32032;&#33267;x&#20013;&#10;    bool Find(int k, T&#38;x)const;&#10;    // &#36820;&#22238;x&#25152;&#22312;&#30340;&#20301;&#32622;&#10;    int Search(const T&#38; x) const;&#10;    // &#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#24182;&#23558;&#23427;&#36820;&#22238;&#33267;x&#20013;&#10;    LinearList&#60;T&#62;&#38; Delete(int k, T&#38;x);&#10;    // &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#10;    LinearList&#60;T&#62;&#38; Insert(int k, const T&#38; x);&#10;    void Output(std::ostream &#38;out) const;&#10;&#125;;&#10;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<h4 id="u5F02_u5E38_u7C7BNoMem"><a href="#u5F02_u5E38_u7C7BNoMem" class="headerlink" title="异常类NoMem"></a>异常类NoMem</h4><p>  如果分配内存失败，那么我们希望可以引发一个异常，有时，异常可能由<code>new</code>引起，有时则需要我们自己来引发。而我们希望在所有情形下都能引发同一个异常，因此，定义了一个异常类NoMem,如下面程序所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;&#10;// &#20869;&#23384;&#19981;&#36275;&#10;class NoMem&#123;&#10;public:&#10;    NoMem()&#123;&#125;&#10;&#125;;&#10;&#10;// &#20351;new&#24341;&#21457;NoMem&#24322;&#24120;&#32780;&#19981;&#26159;xalloc&#24322;&#24120;&#10;void my_new_handler()&#123;&#10;    throw NoMem();&#10;&#125;&#10;&#10;new_handler Old_Handler_ = std::set_new_handler(my_new_handler);</span><br></pre></td></tr></table></figure></p>
<p>在上述程序中，函数<code>my_new_handler</code>简单地引发了一个类型为<code>NoMem</code>的异常，然后在程序最后一行调用了C++函数<code>set_new_handler</code>，每当分配内存失败时，该函数就让操作符<code>new</code>调用函数<code>my_new_handler</code>，所以<code>new</code>引发的异常是<code>NoMem</code>而不是<code>xalloc</code>。每当分配内存失败时，<code>set_new_handler</code>将返回一个指针，指向由<code>new</code>此前所调用的那个函数，该指针保存在变量<code>Old_Handler_</code>中。为了恢复<code>new</code>的元素行为，可以如此调用:<code>set_new_handler(Old_Handler_)</code>;</p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  在抽象数据类型中的操作<code>Create</code>和<code>Destroy</code>分别被作为类的构造函数和析构函数加以实现。基本操作实现的程序如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#34;LinearList.h&#34;&#10;&#10;template&#60;class T&#62;&#10;LinearList&#60;T&#62;::LinearList(int MaxListSize)&#123;&#10;    MaxSize = MaxListSize;&#10;    element = new T[MaxSize];&#10;    length = 0;&#10;&#125;&#10;&#10;// &#36820;&#22238;&#31532;k&#20010;&#20803;&#32032;&#33267;x&#20013;&#10;template&#60;class T&#62;&#10;bool LinearList&#60;T&#62;::Find(int k, T&#38;x)const&#123;&#10;    if (k &#60;1 || k&#62;length)&#10;        return false;&#10;    x = element[k - 1];&#10;    return true;&#10;&#125;&#10;&#10;// &#36820;&#22238;x&#25152;&#22312;&#30340;&#20301;&#32622;&#10;template&#60;class T&#62;&#10;int LinearList&#60;T&#62;::Search(const T&#38; x)const&#123;&#10;    for (int i = 0; i &#60; length; i++)&#123;&#10;        if (element[i] == x)&#10;            return ++i;&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上述程序可知，函数<code>IsEmpty,Length,Find</code>三个函数的复杂性是$\theta(1)$,而<code>Search</code>的复杂性是$O(length)$。</p>
<h5 id="u5220_u9664_u5143_u7D20"><a href="#u5220_u9664_u5143_u7D20" class="headerlink" title="删除元素"></a>删除元素</h5><p>程序如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#24182;&#23558;&#23427;&#36820;&#22238;&#33267;x&#20013;&#10;template&#60;class T&#62;&#10;LinearList&#60;T&#62;&#38; LinearList&#60;T&#62;::Delete(int k, T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (Find(k, x))&#123;&#10;        // &#23558;&#31532;k&#20010;&#20803;&#32032;&#21518;&#30340;&#20803;&#32032;&#21521;&#21069;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;        for (int i = k; i &#60; length; i++)&#10;            element[i - 1] = element[i];&#10;        length--;&#10;        return *this;&#10;    &#125;&#10;    else&#10;        throw OutOfBounds();&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数首先要判断表中是否存在第k个元素，然后再删除元素。如果不存在，则出现一个异常，这里是引发一个类型为<code>OutOfBounds</code>的异常。每当正在执行的函数中任一参数超出所期望的范围时，就引发这种类型的异常。<br>如果存在第k个元素，则可以将元素$k+1，k+2，…,length$依次向前移动一个位置，并将length减一，从而删除第k个元素。<br><code>Delete</code>函数在不存在第k个元素时，所需要的时间是$\theta(1)$;如果存在，则需要移动<code>length-k</code>个元素，需要耗时$\theta((length-k)s)$,其中<strong>s</strong>是每个元素的大小。此外，被删除的元素被移动至x，因此，总的时间复杂性是$O((length-k)s)$。</p>
<h5 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h5><p> 程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> // &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#10;template&#60;class T&#62;&#10;LinearList&#60;T&#62;&#38; LinearList&#60;T&#62;::Insert(int k, const T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (k&#60;0 || k&#62;lenth)&#10;        throw OutOfBounds();&#10;    // &#22914;&#26524;&#34920;&#24050;&#28385;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;NoMem&#10;    if (length == MaxSize)&#10;        throw NoMem();&#10;    // &#21521;&#21518;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;    for (int i = length - 1; i &#62;= k; i--)&#10;        element[i + 1] = element[i];&#10;    element[k] = x;&#10;    length++;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了在第k个元素之后插入一个元素，首先需要把第k+1至length元素向后移动一个位置，然后将新元素插入到k+1位置处。</p>
<p><code>Insert</code>函数的时间复杂性是$$O((length-k)s)$。</p>
<h5 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h5><p>  下面程序是用来测试类<code>LinearList</code>的例子，其中头文件<code>llist.h</code>包含了类声明以及定义，<code>xcept.h</code>则是异常类的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#34;llist.h&#34;&#10;#include&#34;xcept.h&#34;&#10;&#10;&#10;int main()&#123;&#10;    using std::cout;&#10;    using std::endl;&#10;    using std::cin;&#10;&#10;    try&#123;&#10;        LinearList&#60;int&#62; L(5);&#10;        cout &#60;&#60; &#34;Length = &#34; &#60;&#60; L.Length() &#60;&#60; endl;&#10;        cout &#60;&#60; &#34;IsEmpty = &#34; &#60;&#60; L.isEmpty() &#60;&#60; endl;&#10;        L.Insert(0, 2).Insert(1, 6);&#10;        cout &#60;&#60; &#34;List is &#34; &#60;&#60; L &#60;&#60; endl;&#10;        int z;&#10;        L.Find(1, z);&#10;        cout &#60;&#60; &#34;First element is &#34; &#60;&#60; z &#60;&#60; endl;&#10;        cout &#60;&#60; &#34;Length = &#34; &#60;&#60; L.Length() &#60;&#60; endl;&#10;        L.Delete(1, z);&#10;        cout &#60;&#60; &#34;Deleted element is &#34; &#60;&#60; z &#60;&#60; endl;&#10;        cout &#60;&#60; &#34;List is &#34; &#60;&#60; L &#60;&#60; endl;&#10;    &#125;&#10;    catch (...)&#123;&#10;        std::cerr &#60;&#60; &#34;An exception has occured&#34; &#60;&#60; endl;&#10;    &#125;&#10;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B5%8B%E8%AF%951.png" alt="此处输入图片的描述"></p>
<p>完整的例子放在了我的Github中–<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/LinearList" target="_blank" rel="external">LinearList</a></p>
<h4 id="u8BC4_u4EF7"><a href="#u8BC4_u4EF7" class="headerlink" title="评价"></a>评价</h4><p>  对这种公式化描述方法，首先是分析这种方法的优缺点，首先这种方法的确是可以用非常简单的C++函数来实现各种操作，执行查找、删除和插入的函数都有一个最差的、与表大小呈线性关系的时间复杂性。<br>  但一个缺点是空间的低效利用。</p>
<p>  因此其实可以对原来的类<code>LinearList</code>做出一点修改，增加一个可以调整数组大小的函数<code>Resize</code>，在初始创建线性表时，置<code>MaxSize =1</code>;然后，执行插入操作期间，当线性表的元素个数等于<code>MaxSize</code>,就调用<code>Resize</code>函数，增加两倍的容量；在删除操作期间，当元素个数减少到容量的<strong>1/4</strong>时，就调用<code>Resize</code>函数，将容量减少到当前的<strong>1/2</strong>。<br>具体实现的操作如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;bool ResizeLinearList&#60;T&#62;::Resize(int resizeCount)&#123;&#10;    // &#26032;&#25968;&#32452;&#30340;&#22823;&#23567;&#24517;&#39035;&#22823;&#20110;&#29616;&#26377;&#30340;&#25968;&#32452;&#20803;&#32032;&#20010;&#25968;&#10;    if (resizeCount &#60;= length)&#123;&#10;        std::cerr &#60;&#60; &#34;should give a larger numbers than current array numbers\n&#34;;&#10;        return false;&#10;    &#125;&#10;    // &#26356;&#26032;&#25968;&#32452;&#30340;&#23481;&#37327;&#10;    MaxSize = resizeCount;&#10;    T * newElement = new T[resizeCount];&#10;    for (int i = 0; i &#60; length; i++)&#10;        newElement[i] = element[i];&#10;    delete[] element;&#10;    element = newElement;&#10;    return true;&#10;&#125;&#10;// &#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#24182;&#23558;&#23427;&#36820;&#22238;&#33267;x&#20013;&#10;template&#60;class T&#62;&#10;ResizeLinearList&#60;T&#62;&#38; ResizeLinearList&#60;T&#62;::Delete(int k, T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (Find(k, x))&#123;&#10;        // &#23558;&#31532;k&#20010;&#20803;&#32032;&#21518;&#30340;&#20803;&#32032;&#21521;&#21069;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;        for (int i = k; i &#60; length; i++)&#10;            element[i - 1] = element[i];&#10;        length--;&#10;        // &#22914;&#26524;&#24403;&#21069;&#20803;&#32032;&#25968;&#37327;&#31561;&#20110;1/4&#30340;&#23481;&#37327;&#65292;&#21017;&#23558;&#26368;&#22823;&#23481;&#37327;&#32553;&#23567;&#19968;&#21322;&#10;        if (length == (int)MaxSize * 0.25)&#10;            Resize((int)0.5 * MaxSize);&#10;        return *this;&#10;    &#125;&#10;    else&#10;        throw OutOfBounds();&#10;&#125;&#10;&#10;// &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#10;template&#60;class T&#62;&#10;ResizeLinearList&#60;T&#62;&#38; ResizeLinearList&#60;T&#62;::Insert(int k, const T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (k&#60;0 || k&#62;length)&#10;        throw OutOfBounds();&#10;    // &#22914;&#26524;&#34920;&#24050;&#28385;&#65292;&#21017;&#22686;&#21152;2&#20493;&#23481;&#37327;&#10;    if (length == MaxSize)&#10;        Resize(2*MaxSize);&#10;    // &#21521;&#21518;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;    for (int i = length - 1; i &#62;= k; i--)&#10;        element[i + 1] = element[i];&#10;    element[k] = x;&#10;    length++;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的例子在<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/ResizeLinearList.h" target="_blank" rel="external">ResizeLinearList</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。</p>
<p>本章的重点是介绍线性表，但一个主要目标是让大家明白–<strong>数据可以用不同的形式进行描述或存储在计算机存储器中。</strong>最常见的数据买欧式方法有：<strong>公式化描述、链接描]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序性能3--渐进符号]]></title>
    <link href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/"/>
    <id>http://ccc013.github.io/2016/06/07/程序性能3-渐进符号/</id>
    <published>2016-06-07T01:25:59.000Z</published>
    <updated>2016-06-07T01:42:52.018Z</updated>
    <content type="html"><![CDATA[<p>继续上一节的笔记。前2节的笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能1–空间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能2–时间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/">程序性能3–渐进符号</a></li>
</ol>
<h3 id="u6E10_u8FDB_u7B26_u53F7_28O_2C_24_5Ctheta_2Co_2C_5COmega_24_29"><a href="#u6E10_u8FDB_u7B26_u53F7_28O_2C_24_5Ctheta_2Co_2C_5COmega_24_29" class="headerlink" title="渐进符号(O,$\theta,o,\Omega$)"></a>渐进符号(O,$\theta,o,\Omega$)</h3><p>  确定程序的操作计数和执行步数的两个重要原因如下：</p>
<ol>
<li>为了比较两个完成同一功能的程序的时间复杂性；</li>
<li><p>为了预测随着实例特征的变化，程序运行时间的变化量。</p>
<p>但上述两个方法都各有其缺点，使用操作计数会集中在某些”关键”的操作，而忽略了所有其他操作。使用执行步数则试图通过关注所有的操作以便克服操作技术方法的不足，但是，”执行步”的概念本身就不精确，如指令<code>x = y</code>和<code>x = y+z+(x/y)</code>都可以被称为一步。因此由于执行步数的不精确性，所以不便用来进行比较。</p>
<p>因此，这里引入新的符号(或记号)，利用新符号可以写出关于程序时间和空间复杂性的具体公式(尽管不够精确)。这种符号称为<strong>渐进符号</strong>，它可以描述大型实例特征下时间或空间复杂性的具体表现。</p>
<p>在接下来的讨论中，$f(n)$表示一个程序的时间或空间复杂性，它是实例特征n的函数，由于一个程序的时间和空间需求是一个非负值，所以可以假定对于n的所有取值，函数$f$的值非负。由于n表示一个实例特征，所以可以进一步假定$n\ge 0$。即将讨论的渐进符号允许我们对于足够大的n值，给出$f$的上限值和/或下限值。</p>
</li>
</ol>
<h4 id="u5927_u5199O_u7B26_u53F7"><a href="#u5927_u5199O_u7B26_u53F7" class="headerlink" title="大写O符号"></a>大写O符号</h4><p>  大写O符号给出了函数$f$的一个上限。</p>
<blockquote>
<p>$f(n) = O(g(n))$ 当且仅当存在正的常数$c$和$n_0$，使得对于所有的$n\ge n_0$,有$f(n)\le cg(n)$。</p>
</blockquote>
<p>上述定义表明，函数f多是函数g的c倍，除非n小于$n_0$。因此对于足够大的n(如$n\ge n_0$)，g是f的一个上限。在为函数f提供一个上限函数g时，通常使用比较简单的函数形式，比较典型的形式是含有n的单个项(带一个常数系数)。下图列出了一些常用的g函数及其名称。下图中的对数函数$log n$，没有给出对数基，原因是对于任何大于1的常数a和b都有$log_a n = {log_b n / log_b a}$,所以$log_an$和$log_bn$都有一个相对的乘法系数$1 / log_b a$,其中a是一个常量。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B8%90%E8%BF%9B%E5%87%BD%E6%95%B0.png" alt="此处输入图片的描述"></p>
<h5 id="u4E3E_u4F8B_u8BF4_u660E"><a href="#u4E3E_u4F8B_u8BF4_u660E" class="headerlink" title="举例说明"></a>举例说明</h5><blockquote>
<p>[线性函数]考察函数$f(n) = 3n + 2$</p>
</blockquote>
<p>  当$n\ge 2$时，有$3n+2\ge 3n+n=4n$，所以有$f(n) = O(n)$,$f(n)$是一个线性变换的函数。当采用其他方式也可以得到同样的结论，例如,对于$n\gt 0$,有$3n+2\le 10n$,可以通过选择c=10以及$n_0\gt 0$来满足大O定义。</p>
<p>  对于其他线性的函数，如3n+3,100n+6，都满足n的大O定义。</p>
<blockquote>
<p>[平方函数]考察函数$f(n) = 10n^2 + 4n + 2$</p>
</blockquote>
<p>  对于$n\ge 2$,有$f(n)\le 10n^2+5n$,而又当$n\ge 5$,有$5n\le n^2$,因此对于$n\ge n_0 = 5,f(n) \le 10n^2+n^2 = 11n^2,所以f(n) = O(n^2)$。</p>
<blockquote>
<p>[指数函数] 考察函数$f(n) = 6*2^n+n^2$</p>
</blockquote>
<p>  对于$n\ge 4,有n^2 \le 2^n，所以对于n \ge 4,有f(n) \le 6<em>2^n + 2^n = 7</em>2^n,因此6*2^n + n^2 = O(2^n)$。</p>
<h5 id="u677E_u6563_u754C_u9650"><a href="#u677E_u6563_u754C_u9650" class="headerlink" title="松散界限"></a>松散界限</h5><p>  在上述例子中，如$n\ge 2,有3n+3\le 3n^2,所以3n+3=O(n^2),虽然n^2是3n+3$的一个上限，但不是最小上限，因为可以找到一个更小的函数来满足大O定义。</p>
<p>  同样地，对于其他例子也是可以有找到其他g(n)函数来满足大O定义，但是我们需要寻找的是<strong>最小上限</strong>，这也是为了让语句$f(n) = O(g(n))$有实际意义。</p>
<p>  对于一些错误界限，如$3n+2 \neq O(1)$,可以使用反证法来证明。</p>
<p>下面一个定理给出了一个非常有用的结论，利用该结论可以获取f(n)的序(即$f(n) = O(g(n))$中的g(n))，这里，f(n)是一个关于n的多项式。</p>
<blockquote>
<p>如果$f(n) = a_m n^m + … + a_1n+a_0,且a_m\gt 0,则f(n) = O(n^m)。$</p>
<p>证明： 对于所有的$n\ge 1$,有：<br>$$<br>f(n)  \le \sum_{i=0}^m | a_i| n^i \<br>     \hspace{45pt} \le n^m\sum_0^m |a_i| n^{i-m}\<br>     \hspace{30pt} \le n^m\sum_0^m |a_i|<br>$$</p>
</blockquote>
<p>这里可以使用该定理来应用到前面的例子中，可以得到同样的结果。</p>
<blockquote>
<p>[大O比率定理]对于函数$f(n)和g(n),若\lim<em>{n\to \infty}f(n)/g(n)存在$，则$f(n)=O(g(n))$当且仅当存在确定的常数c，有 $\lim</em>{n\to \infty}f(n)/g(n)\le c$。</p>
</blockquote>
<h4 id="24_5COmega_24_u7B26_u53F7"><a href="#24_5COmega_24_u7B26_u53F7" class="headerlink" title="$\Omega$符号"></a>$\Omega$符号</h4><p>  $\Omega$符号与大O符号类型，它用来估算函数f的下限。</p>
<blockquote>
<p>$f(n) = \Omega (g(n))$当且仅当存在正的常数$c和n_0$,使得对于所有的$n\ge n_0,有f(n) \ge cg(n)$。</p>
</blockquote>
<p>上述定义表明了在$n\ge n_0$的前提下，函数f至少是函数g的c倍。与大O定义的应用一样，<strong>通常仅使用单项形式的g函数。</strong>同时，它也具有以下定理来求g函数。</p>
<blockquote>
<p>如果$f(n) = a_m n^m + … + a_1n+a_0,且a_m\gt 0,则f(n) = \Omega (n^m)。$</p>
</blockquote>
<p>  根据这个定理可知，$3n+2 = \Omega(n)$,$10n^2+4n+2 = \Omega(n^2)$,$100n^4+3500n^2+82n+8=\Omega(n^4)$。</p>
<blockquote>
<p>[$\Omega$比率定理]对于函数$f(n)和g(n),若\lim<em>{n\to \infty}f(n)/g(n)存在$，则$f(n)=\Omega(g(n))$当且仅当存在确定的常数c，有 $\lim</em>{n\to \infty}f(n)/g(n)\le c$。   </p>
</blockquote>
<h4 id="24_5Ctheta_24__u7B26_u53F7"><a href="#24_5Ctheta_24__u7B26_u53F7" class="headerlink" title="$\theta$ 符号"></a>$\theta$ 符号</h4><p>  $\theta$ 符号适用于同一个函数g既可以作为f的上限也可以作为f的下限的情形。</p>
<blockquote>
<p>定义：$f(n) = \theta (g(n))$当且仅当存在正常数$c_1,c_2和某个n_0$,使得对于所有的$n\ge n_0$,有$c_1g(n)\le f(n) \le c_2g(n)$。</p>
</blockquote>
<p>  上述定义表明了在$n\ge n_0$的情况下，函数f介于函数g的$c_1倍和c_2倍$之间。它通常仅使用单项形式的g函数。</p>
<p>同样地，也具有下面两个定理</p>
<blockquote>
<p>如果$f(n) = a_m n^m + … + a_1n+a_0,且a_m\gt 0,则f(n) = \theta (n^m)。$</p>
</blockquote>
<p>  根据这个定理，可知$3n+2 = \theta(n)$,$10n^2+4n+2 = \theta(n^2)$,$100n^4+3500n^2+82n+8=\theta(n^4)$。</p>
<blockquote>
<p>[$\theta$比率定理]对于函数$f(n)和g(n),若\lim<em>{n\to \infty}f(n)/g(n)存在$，则$f(n)=\theta(g(n))$当且仅当存在确定的常数c，有 $\lim</em>{n\to \infty}f(n)/g(n)\le c$及$\lim_{n\to \infty}g(n)/f(n)\le c$。</p>
</blockquote>
<h4 id="u5C0F_u5199o_u7B26_u53F7"><a href="#u5C0F_u5199o_u7B26_u53F7" class="headerlink" title="小写o符号"></a>小写o符号</h4><blockquote>
<p>定义：$f(n) = o(g(n))$当且仅当$f(n) = O(g(n)),且f(n) \neq \Omega (g(n))$。</p>
</blockquote>
<p>例如，因为$3n+2 = O(n^2)$,且$3n+2\neq \Omega(n^2)$,所有$3n+2 = o(n^2)$,但$3n+2\neq o(n)$。</p>
<p>（那么其实就是可以理解为：如果$f(n) = \theta (g(n))$,则有$f(n) \neq o(g(n))$。）</p>
<h4 id="u7279_u6027"><a href="#u7279_u6027" class="headerlink" title="特性"></a>特性</h4><blockquote>
<p>定理：对于任一个实数$x \gt 0$和任一个实数$\epsilon \gt 0$,下面的结论都是正确的：<br>1) 存在某个$n_0$使得对于任何$n\gt n_0$,有$(logn)^x\lt(logn)^{x+\epsilon}$.<br>2)存在某个$n_0$使得对于任何$n\gt n_0$,有$(logn)^x\lt n$.<br>3)存在某个$n_0$使得对于任何$n\gt n_0$,有$n^x \lt n^{x+\epsilon}$.<br>4)对于任意实数y，存在某个$n_0$使得对于任何$n\gt n_0$,有$n^x(logn)^y \lt n^{x+\epsilon}$.<br>5)存在某个$n_0$使得对于任何$n\gt n_0$,有$n^x \lt 2^n$。</p>
</blockquote>
<p>根据上述定理，可以有如下结论：$n^3 + n^2 logn = \theta(n^3)$(因为$n^3 \le n^3 + n^2 logn \le 2n^3$);</p>
<p>下面两张图，第一张图中列出了一些常用的有关$O,\Omega,\theta$的标记，在该表中除n以外所有符号均为正常数。第二张图给出了一些关于和与积的有用的引用规则，其中$\oplus 可以是O,\Omega,\theta$之一。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E6%A0%87%E8%AE%B0.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E8%A7%84%E5%88%99.png" alt="此处输入图片的描述"></p>
<h4 id="u590D_u6742_u6027_u5206_u6790_u4E3E_u4F8B"><a href="#u590D_u6742_u6027_u5206_u6790_u4E3E_u4F8B" class="headerlink" title="复杂性分析举例"></a>复杂性分析举例</h4><p>  根据渐进符号，这里重新检查下上一节分析的时间复杂性，对于函数<code>Sum</code>,分析如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A71.png" alt="此处输入图片的描述"><br>同理对于其他函数也有这样的分析，如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A72.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A73.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A74.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A75.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A76.png" alt="此处输入图片的描述"><br>当按照执行步数来分析上述函数的时候，可以把$t_p(n) = \theta (g(n))$,$t_p(n) = O(g(n))或t_p(n) = \Omega (g(n))$看成一条程序P的语句(用于计算时间),因为每一步仅需要$\theta(1)$的执行时间。<br>接下来就是从全局角度来考察程序的渐进复杂性的需要，下面会举例来阐述这种方法。</p>
<blockquote>
<p>[折半搜索]下列程序是一个用在有序数组a[0:n-1]中查找元素x的函数。变量left和right是用来记录查找的起始点和结束点。开始时，将在0到n-1之间进行查找，所以left和right的初值分别是0和n-1。遵循的规律是当前仅当x是a[left:right]中的元素时，x是a[0:n-1]中的元素。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#25240;&#21322;&#25628;&#32034;*/&#10;template&#60;class T&#62;&#10;int BinarySearch(T a[], const T&#38; x, int n)&#123;&#10;    int left = 0, right = n - 1;&#10;    while (left &#60;= right)&#123;&#10;        int middle = (left + right) / 2;&#10;        if (x == a[middle])&#10;            return middle;&#10;        if (x &#62; a[middle])&#10;            left = middle + 1;&#10;        else&#10;            right = middle - 1;&#10;    &#125;&#10;    // &#26410;&#25214;&#21040;x&#10;    return -1;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在折半搜索中，While的循环(最后一次除外)都将以减半的比例缩小搜索的范围，所以该循环在最坏情况下虚执行$\theta(logn)$次，由于每次循环需要耗时$\theta(1)$，因此在最坏的情况下，总的时间复杂性是$\theta(logn)$。</p>
<p>第二个例子是<a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%282%29-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">上一节</a>中的插入排序例子中，对于每个i值，最内部的循环在最坏情况下时间复杂性是$\theta(1)$,因此在最坏情况下，该例子的时间复杂性是$\theta(n^2)$,而最好的情况是$\theta(n)$。程序的渐进复杂性可由$\Omega(n) 和O(n^2)$给出。</p>
<p>小写o符号通常用于执行步数的分析。执行步数$3n+O(n)$表示3n加上上限是n的项。在进行这种分析时，可以忽略步数少于$\theta(n)$的程序部分。<br>还可以扩充渐进符号的定义，采用具有多个变量的函数。例如，$f(n,m)=O(g(n,m))$当且仅当存在正常量$c,n_0,m_0$,使得对于所有的$n\ge n_0和所有的m\ge m_0$，有$f(n,m)\le cg(n,m)$。</p>
<h3 id="u5B9E_u9645_u590D_u6742_u6027"><a href="#u5B9E_u9645_u590D_u6742_u6027" class="headerlink" title="实际复杂性"></a>实际复杂性</h3><p>  根据前面几节内容，我们知道一个程序的时间复杂性通常是其实例特征的函数，在确定程序的时间需求是如何随着实例特征的变化而变化时，这种函数将非常有用。<br>  下面两张图给出各种函数是如何随着n的增长而变化的。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%AE%9E%E9%99%85%E5%A4%8D%E6%9D%82%E6%80%A71.png" alt="此处输入图片的描述"><br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%AE%9E%E9%99%85%E5%A4%8D%E6%9D%82%E6%80%A72.png" alt="此处输入图片的描述"><br>由图中可以看出随着n的增长，$2^n$的增长极快，如果需要执行$2^n$执行步，那么n=40时，执行步数将大约$1.1<em>10^{12}$，在一台每秒执行$10^9$步的计算机中，该程序大约需要执行18.3分钟；而如果n=50，则需要执行13天，n=60时，需要执行310.56年。因此，*</em>具有指数复杂性的程序仅适合于小的n(典型地取$n\le 40$)。<br>  此外，具有高次多项式复杂性的函数也必须限制使用，比如对于需要执行$n^{10}$执行步的程序，当n=10时，同样是每秒执行$10^9$步的计算机中，需要10秒，但是n=100，这个时间就是3171年了。<br>  下面一张图很好地给出了在每秒执行$10^9$条指令的计算机上执行复杂性是$f(n)$所需要的时间。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%AE%9E%E9%99%85%E5%A4%8D%E6%9D%82%E6%80%A73.png" alt="此处输入图片的描述"></p>
<h3 id="u6027_u80FD_u6D4B_u91CF"><a href="#u6027_u80FD_u6D4B_u91CF" class="headerlink" title="性能测量"></a>性能测量</h3><blockquote>
<p>性能测量主要关注于得到一个程序实际需要的空间和时间。</p>
</blockquote>
<p>我们忽略编译所需要的时间和空间是因为每个程序仅需要编译一次(当然是在调试完成之后)，而可以运行无数次。不过，如果测试的次数要比运行最终代码的次数多，则在程序测试期间，编译所需要的时间和空间也是很重要的。<br>而基于以下原因，我们不能精确地测量一个程序运行时所需要的时间和空间:</p>
<ul>
<li>指令空间和数据空间的大小是由编译器在编译时确定的，所以不必要测量这些数据。</li>
<li>根据前几节介绍的方法，可以很准确地估算递归栈空间和变量动态分配所需要的空间。</li>
</ul>
<p>而为了得到程序的执行时间，需要一个定时机制。在C++中包含一个头文件是<code>time.h</code>，定义了一个<code>clock()</code>的函数，它可以返回自程序启动以来所流逝的“滴答”数，然后再将流逝的“滴答”数除以常量<code>CLK_TCK</code>,就可以得到流逝的秒数。</p>
<p>接下来，我们选择作为实验的程序是<a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%282%29-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">上一节</a>中的插入排序<code>InsertionSort</code>函数。而要测量该函数在最坏情况下所需要的时间，首先需要：</p>
<ol>
<li>确定需要测定执行时间的n值；</li>
<li>对于上面的每个n，给出能导致最坏复杂性的测试数据。</li>
</ol>
<h4 id="u9009_u62E9_u5B9E_u4F8B_u7684_u5927_u5C0F"><a href="#u9009_u62E9_u5B9E_u4F8B_u7684_u5927_u5C0F" class="headerlink" title="选择实例的大小"></a>选择实例的大小</h4><p>  可以根据以下两个因素来确定使用哪些n值：</p>
<ul>
<li>程序执行的时间</li>
<li>程序执行的次数</li>
</ul>
<p>在之前的分析中可以知道在最坏的情况下，插入排序的复杂性是$\theta(n^2)$。实践过程中，通常需要3个以上的n值，其原因如下：</p>
<ol>
<li>渐进分析仅给出了对于足够大的n值时程序的复杂性。对于小的n值，程序的运行时间可能并满足渐近曲线。为了确定渐近曲线以外的点，需要使用多个n值。</li>
<li>即使在满足渐近曲线的区间内，程序实际运行时间也可能不满足预定的渐近曲线，原因是在进行渐进分析时，忽略了许多低层次的时间需求。例如，一个程序的渐进复杂性是$\theta(n^2)$，而它的实际复杂性可以是$c_1n^2+c_2nlogn+c_3n+c_4$,或其他任何最高项是$c_1n^2$的函数，其中$c_1$是常数且大于0。</li>
</ol>
<p>而在我们用来实验的插入排序程序，我们期望获得$n\lt 100$的渐进复杂性，所以对于$n\gt 100$的情况，可能只需奥很少量的估算值，一个合理的选择是$n=200,300,400,\ldots,1000$。</p>
<h4 id="u8BBE_u8BA1_u6D4B_u91CF_u6570_u636E"><a href="#u8BBE_u8BA1_u6D4B_u91CF_u6570_u636E" class="headerlink" title="设计测量数据"></a>设计测量数据</h4><p>  对于许多程序，可以手工或者用计算机来产生能导致最好和最后复杂性的测试数据。然而，对于平均的复杂性，通常很难设计相应的数据。如对于我们要用来实验的<code>InsertionSort</code>函数来说，对任何n来说，能导致最坏复杂性的测试数据应是一个递减的序列，如$n,n-1,n-2,\ldots,1$;导致最好复杂性的测试数据应是一个递增的序列，如$0,1,2,\ldots,n-1$。我们很难提供一组测试数据使得<code>InsertionSort</code>函数表现出平均的复杂性。</p>
<h4 id="u8FDB_u884C_u5B9E_u9A8C"><a href="#u8FDB_u884C_u5B9E_u9A8C" class="headerlink" title="进行实验"></a>进行实验</h4><p>  当确定了实例大小，并给出了测试数据，就可以开始进行实验了。<br>  实验运行的代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#60;string&#62;&#10;#include&#60;time.h&#62;&#10;&#10;/*&#21521;&#19968;&#20010;&#26377;&#24207;&#25968;&#32452;&#20013;&#25554;&#20837;&#20803;&#32032;,&#20551;&#23450;a&#30340;&#22823;&#23567;&#36229;&#36807;n*/&#10;template&#60;class T&#62;&#10;void Insert(T a[], int&#38; n, const T&#38; x)&#123;&#10;    int i;&#10;    for (i = n - 1; i &#62;= 0 &#38;&#38; x &#60; a[i]; i--)&#10;        a[i + 1] = a[i];&#10;    a[i + 1] = x;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InsertionSort(T a[], int n)&#123;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        T t = a[i];&#10;        Insert(a, i, t);&#10;    &#125;&#10;&#125;&#10;&#10;int main()&#123;&#10;    using std::cout;&#10;    using std::endl;&#10;    using std::cin;&#10;&#10;    int a[1000], step = 10;&#10;    clock_t start, finish;&#10;    for (int n = 0; n &#60;= 1000; n += step) &#123;&#10;        for (int i = 0; i &#60; n; i++)&#10;            a[i] = n - i; // &#21021;&#22987;&#21270;&#10;        start = clock();&#10;        InsertionSort(a, n);&#10;        finish = clock();&#10;        cout &#60;&#60; n &#60;&#60; &#39; &#39; &#60;&#60;(float)(finish - start) / CLK_TCK &#60;&#60; endl;&#10;        if (n == 100) &#10;            step = 100;&#10;    &#125;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果如下图所示<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%AB%A02%E5%AE%9E%E9%AA%8C%E5%9B%BE1.png" alt="此处输入图片的描述"><br>由上图可以得出这样的结论，排序300个元素以内的数组不需要时间，而排序400-800个元素的数组所花费的时间是一样的。但这个结论并不正确，主要是因为对于计时函数<code>clock()</code>来说，所需要的运行时间太小了。而且，所有测量的精确度均为一个时钟“滴答”。书本中使用的计算机的<code>CLK_TCK=18.2</code>,不过我使用的是<code>Visual Studio</code>中<code>CLK_TCK=1000</code>,即这里测量的误差范围是一个“滴答”时间<code>1/1000 = 0.001</code>秒。<br>而为了提高测量的精确度，对于每个n值，可以重复排序若干次。这里限定的条件是10个时钟“滴答”时间。代码及实验结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#60;string&#62;&#10;#include&#60;time.h&#62;&#10;&#10;/*&#21521;&#19968;&#20010;&#26377;&#24207;&#25968;&#32452;&#20013;&#25554;&#20837;&#20803;&#32032;,&#20551;&#23450;a&#30340;&#22823;&#23567;&#36229;&#36807;n*/&#10;template&#60;class T&#62;&#10;void Insert(T a[], int&#38; n, const T&#38; x)&#123;&#10;    int i;&#10;    for (i = n - 1; i &#62;= 0 &#38;&#38; x &#60; a[i]; i--)&#10;        a[i + 1] = a[i];&#10;    a[i + 1] = x;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InsertionSort(T a[], int n)&#123;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        T t = a[i];&#10;        Insert(a, i, t);&#10;    &#125;&#10;&#125;&#10;&#10;int main()&#123;&#10;    using std::cout;&#10;    using std::endl;&#10;    using std::cin;&#10;&#10;    int a[1000],n,i, step = 10;&#10;    long counter;&#10;    float seconds;&#10;    clock_t start, finish;&#10;    for (int n = 0; n &#60;= 1000; n += step)&#123;&#10;        // &#33719;&#24471;&#23545;&#24212;&#20110;n&#20540;&#30340;&#26102;&#38388;&#10;        start = clock();&#10;        counter = 0;&#10;        while (clock() - start &#60; 10)&#123;&#10;            counter++;&#10;            for (i = 0; i &#60; n; i++)&#10;                a[i] = n - i;&#10;            InsertionSort(a, n);&#10;        &#125;&#10;        finish = clock();&#10;        seconds = (float)(finish - start) / CLK_TCK;&#10;        cout &#60;&#60; n &#60;&#60; &#39; &#39; &#60;&#60; counter&#60;&#60;&#39; &#39; &#60;&#60; seconds&#60;&#60;&#39; &#39;&#60;&#60; seconds/counter&#60;&#60; endl;&#10;        if (n == 100)&#10;            step = 100;&#10;    &#125;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%AB%A02%E5%AE%9E%E9%AA%8C%E5%9B%BE2.png" alt="此处输入图片的描述"><br>上图中每行数据分别是n值，重复次数，总时间以及每次排序时间。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  第二章有关程序性能的笔记就记录到这里了。本章主要是介绍了算法的基础，对于程序的空间和时间复杂性的介绍，还介绍了4种渐进符号，然后就是给出了一个例子来测量运行时间。<br>  本章是一个学习数据结构和算法的基础，因为我还是初学者，所以笔记主要是记录书中的要点，比较少有写上自己的理解，不过，相信随着练习，会慢慢掌握数据结构和算法的知识点的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续上一节的笔记。前2节的笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序性能2--时间复杂性]]></title>
    <link href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    <id>http://ccc013.github.io/2016/06/04/程序性能2-时间复杂性/</id>
    <published>2016-06-04T05:32:07.000Z</published>
    <updated>2016-06-07T01:42:35.303Z</updated>
    <content type="html"><![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能1–空间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能2–时间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/">程序性能3–渐进符号</a></li>
</ol>
<h3 id="u65F6_u95F4_u590D_u6742_u6027"><a href="#u65F6_u95F4_u590D_u6742_u6027" class="headerlink" title="时间复杂性"></a>时间复杂性</h3><h4 id="u65F6_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210"><a href="#u65F6_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210" class="headerlink" title="时间复杂性的组成"></a>时间复杂性的组成</h4><blockquote>
<p>影响一个程序空间复杂性的因素也能影响程序的时间复杂性。</p>
<p>一个程序P所占用的时间T(P) = 编译时间 + 运行时间。编译时间与实例的特征无关。另外，可以假定一个编译过的程序可以运行若干次而不需要重新编译。因此我们将主要关注程序的运行时间，运行时间通常用”$t_p$(实例特征)”来表示。</p>
</blockquote>
<p>存在这一个事实：<strong>一个算术操作所需要的时间取决于操作数的类型(int,float,double等),这个事实增加了获得一个精确的计算公式的烦琐程度。所以必须按照数据类型对操作进行分类。</strong></p>
<p>有两个更可行的方法可用来估算运行时间：</p>
<ol>
<li>找出一个或更多的操作，确定这些关键操作所需要的执行时间；</li>
<li>确定程序总的执行步数。</li>
</ol>
<h4 id="u64CD_u4F5C_u8BA1_u6570"><a href="#u64CD_u4F5C_u8BA1_u6570" class="headerlink" title="操作计数"></a>操作计数</h4><p>估算一个程序或函数的时间复杂性的一种方式就是首先选择一种或多种操作(如加、乘和比较等),然后确定这种(些)操作分别执行了多少次。这种方法是否成功取决于识别关键操作的能力，这些关键操作对时间复杂性的影响最大。下面的几个例子都采用了这种方法。</p>
<h5 id="u4F8B1__u591A_u9879_u5F0F_u6C42_u503C"><a href="#u4F8B1__u591A_u9879_u5F0F_u6C42_u503C" class="headerlink" title="例1 多项式求值"></a>例1 多项式求值</h5><blockquote>
<p> 考察多项式$P(x) = \sum_{i=0}^n c_i x^n$。如果$c_n \neq 0$,则P是一个n维多项式。</p>
</blockquote>
<p>下列程序实现了多项式求值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#22810;&#39033;&#24335;&#27714;&#20540;*/&#10;template&#60;class T&#62;&#10;T PolyEval(T coeff[], int n, const T&#38;x)&#123;&#10;    // &#35745;&#31639;n&#27425;&#22810;&#39033;&#24335;&#30340;&#20540;&#65292;coeff[0:n]&#20026;&#22810;&#39033;&#24335;&#30340;&#31995;&#25968;&#10;    T y = 1, value = coeff[0];&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        y *= x;&#10;        value += y*coeff[i];&#10;    &#125;&#10;    return value;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的for循环中的循环条件，书中代码是有点错误的，应该是<code>i&lt;n</code>,不能带上等于。</p>
<p>在这个例子中，假定根据for循环内部所执行的加和乘的次数来估算时间复杂性。可以使用维数n作为实例特征。进入for循环的总次数为n，每次循环执行1次加法和乘法(这种操作计数不包含循环控制变量i每次递增所执行的加法)。加法的次数为n，乘法的次数为2n。</p>
<p>第二种求解多项式的方法是使用<strong>Horner</strong>法则，它是采用如下的分解式计算一个多项式：<br>$$<br>  P(x) = (\ldots(c<em>n*x+c</em>{n-1})<em>x+c_{n-2})</em>x+c_{n-3})<em>x+\ldots)</em>x+c_0<br>$$<br>代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#20351;&#29992;Horner&#27861;&#21017;&#27714;&#35299;&#22810;&#39033;&#24335;*/&#10;template&#60;class T&#62;&#10;T Horner(T coeff[], int n, const T&#38;x)&#123;&#10;    T value = coeff[n-1];&#10;    for (int i = 2; i &#60;= n; i++)&#123;&#10;        value = value*x + coeff[n - i];&#10;    &#125;&#10;    return value;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>书中的代码也是有些问题，n应该代表的是<code>coeff</code>这个数组的大小，所以首先是<code>T value = coeff[n-1];</code>这句代码，书中是直接等于<code>coeff[n]</code>，这里应该是<code>coeff[n-1]</code>,然后就是for循环的初始条件，是<code>i=2</code>，而不是<code>i=1</code>。</p>
<p>使用<strong>Horner</strong>后，加法还是需要n次，但是乘法也只需要n次即可。因此，使用这个函数会比<code>PolyEval</code>函数更快。</p>
<h5 id="u4F8B2__u8BA1_u6570_u6392_u5E8F"><a href="#u4F8B2__u8BA1_u6570_u6392_u5E8F" class="headerlink" title="例2 计数排序"></a>例2 计数排序</h5><p>这里通过两段代码实现计数排序的方法。</p>
<blockquote>
<p>元素在队列中的名次（ r a n k）可定义为队列中所有比它小的元素数目加上在它左边出现的与它相同的元素数目。<br>例如，给定一个数组 a=[4, 3, 9, 3, 7]作为队列，则各元素<br>的名次为r =[2, 0, 4, 1, 3]</p>
</blockquote>
<p>这里我的实现的代码方法跟书本有所不一样，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Rank(T a[], int n, int r[])&#123;&#10;    // &#35745;&#31639;a[0:n-1]&#20013;n&#20010;&#20803;&#32032;&#30340;&#25490;&#21517;&#10;    for (int i = 0; i &#60; n; i++)&#10;        r[i] = 0;       // &#21021;&#22987;&#21270;&#25490;&#21517;&#25968;&#32452;&#10;    // &#36880;&#23545;&#27604;&#36739;&#25152;&#26377;&#30340;&#20803;&#32032;&#10;    for (int i = 0; i &#60; n; i++)&#123;&#10;        for (int j = i+1; j &#60; n; j++)&#123;&#10;            if (a[i] &#60;= a[j])&#10;                r[j]++;&#10;            else&#10;                r[i]++;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>书中给出的代码，其比较次数是1+2+3+···+n-1 = $(n-1)n\over 2$<br>而我给出的代码实现，其比较总次数也是相同的，$(n-1)n\over 2$,差别应该是在比较是<code>(n-1)+(n-2)+···+2+1</code>.</p>
<blockquote>
<p>根据例2中计算出数组中每个元素的名次，就可以利用元素名次按照递增的次序对数组中的元素进行重新排列，使得$a[0]\le a[1]\le \ldots \le a[n-1]$</p>
</blockquote>
<p>下面代码是使用了一个附加的数组u实现按名次排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#21033;&#29992;Rank&#20989;&#25968;&#20013;&#24471;&#21040;&#30340;&#27599;&#20010;&#20803;&#32032;&#30340;&#21517;&#27425;&#65292;&#23545;&#25968;&#32452;&#37325;&#26032;&#25490;&#24207;*/&#10;template&#60;class T&#62;&#10;void Rearrange(T a[], int n, int r[])&#123;&#10;    // &#25353;&#39034;&#24207;&#37325;&#25490;&#25968;&#32452;a&#20013;&#30340;&#20803;&#32032;&#65292;&#20351;&#29992;&#38468;&#21152;&#25968;&#32452;u&#10;    T *u = new T[n];&#10;    // &#22312;u&#20013;&#31227;&#21160;&#21040;&#27491;&#30830;&#30340;&#20301;&#32622;&#10;    for (int i = 0; i &#60; n; i++)&#10;        u[r[i]] = a[i];&#10;    // &#31227;&#22238;&#21040;a&#20013;&#10;    for (int i = 0; i &#60; n; i++)&#10;        a[i] = u[i];&#10;    delete[] u;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是书中给出的实现方法，这个方法需要移动元素<code>2n</code>次，因此，加上例2中的实现，整个排序需要执行，$(n-1)n\over 2$次比较操作和<code>2n</code>次移动操作，这种排序方法被称为<strong>计数排序</strong>。</p>
<p>另一种方法是原地重排数组元素，不需要一个附加数组，实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Rearrange2(T a[], int n, int r[])&#10;&#123;// &#21407;&#22320;&#37325;&#25490;&#25968;&#32452;&#20803;&#32032;&#10;    for (int i = 0; i &#60; n; i++)&#10;        // &#33719;&#21462;&#24212;&#35813;&#25490;&#22312; a [ i ]&#22788;&#30340;&#20803;&#32032;&#10;    while (r[i] != i) &#123;&#10;        int t = r[i];&#10;        Swap(a[i], a[t]);&#10;        Swap(r[i], r[t]);&#10;    &#125;&#10;&#125;&#10;&#10;/*&#20132;&#25442;&#20004;&#20010;&#25968;&#32452;&#20803;&#32032;*/&#10;template&#60;class T&#62;&#10;void Swap(T&#38; a, T&#38;  b)&#123;&#10;    T temp = a;&#10;    a = b;&#10;    b = temp;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>新的程序需要执行的最少交换次数是0(初始数组已经是按序排列)，最大的交换次数是2(n-1)。注意每次交换操作至少把一个元素移动到正确位置(如a[i])，所以在n-1次交换之后，所有的n个元素已全部按序排列。</p>
<h5 id="u4F8B3__u9009_u62E9_u6392_u5E8F"><a href="#u4F8B3__u9009_u62E9_u6392_u5E8F" class="headerlink" title="例3 选择排序"></a>例3 选择排序</h5><blockquote>
<p>选择排序：首先找出最大的元素，把它移动到 a [ n-1 ]，然后在余下的 n-1个元素中寻找最大的元素并把它移动到a [ n-2 ]，如此进行下去，</p>
</blockquote>
<p>这是按照递增次序重排数组，也可以按照递减次序排序，就是每次找最小的元素，然后依次与数组的第一个元素交换。</p>
<p>代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#36873;&#25321;&#25490;&#24207;&#65292;&#25353;&#29031;&#36882;&#22686;&#27425;&#24207;&#25490;&#21015;*/&#10;template&#60;class T&#62;&#10;void selectionSort(T a[], int n)&#123;&#10;    for (int size = n; size &#62; 1; size--)&#123;&#10;        int max = Max(a, size);&#10;        Swap(a[max], a[size - 1]);&#10;    &#125;&#10;&#125;&#10;&#10;/*&#23547;&#25214;&#25968;&#32452;&#20013;&#26368;&#22823;&#20803;&#32032;*/&#10;template&#60;class T&#62;&#10;int Max(T a[], int n)&#123;&#10;    int pos = 0;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        if (a[pos] &#60; a[i])&#10;            pos = i;&#10;    &#125;&#10;    return pos;&#10;&#125;&#10;/*&#20132;&#25442;&#20004;&#20010;&#25968;&#32452;&#20803;&#32032;*/&#10;template&#60;class T&#62;&#10;void Swap(T&#38; a, T&#38;  b)&#123;&#10;    T temp = a;&#10;    a = b;&#10;    b = temp;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述函数中，Max函数会进行$(n-1)n\over 2$次比较操作，而Swap函数会进行<code>3(n-1)</code>次移动操作。</p>
<p>这种实现方式的选择排序的一个缺点是：<strong>即使元素已经按序排列，程序仍然继续运行</strong>。</p>
<p>因此为了终止不必要的循环，可以在查找最大元素期间检查数组是否已经按序排列，实现方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#21450;&#26102;&#32456;&#27490;&#30340;&#36873;&#25321;&#25490;&#24207;*/&#10;template&#60;class T&#62;&#10;void selectionSort2(T a[], int n)&#123;&#10;    bool isSorted = false;      // &#21152;&#20837;&#32456;&#27490;&#24490;&#29615;&#30340;&#26465;&#20214;&#10;    for (int size = n; !isSorted &#38;&#38; (size &#62; 1); size--)&#123;&#10;        int pos = 0;&#10;        isSorted = true;&#10;        // &#25214;&#26368;&#22823;&#20803;&#32032;&#10;        for (int i = 1; i &#60; size; i++)&#123;&#10;            if (a[pos] &#60;= a[i])&#10;                pos = i;&#10;            else&#10;                // &#27809;&#26377;&#25353;&#24207;&#25490;&#21015;&#10;                isSorted = false;&#10;        &#125;&#10;        Swap(a[pos], a[size - 1]);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种新的实现方法，最好的情况是数组已经是有序数组的情况，那么外部for循环仅需要执行一次，内部寻找最大元素的比较次数是n-1次。而最坏的情况则是外部for循环执行n-1次，执行的比较次数是$(n-1)n\over 2$次。</p>
<h5 id="u4F8B4__u5192_u6CE1_u6392_u5E8F"><a href="#u4F8B4__u5192_u6CE1_u6392_u5E8F" class="headerlink" title="例4 冒泡排序"></a>例4 冒泡排序</h5><blockquote>
<p>冒泡排序是采用一种“冒泡策略”把最大元素移到右部。在冒泡过程中，对相邻的元素进行比较，如果左边的元素大于右边的元素，则交换这两个元素。</p>
</blockquote>
<p>下面是冒泡排序的一种实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#19968;&#27425;&#20882;&#27873;*/&#10;template&#60;class T&#62;&#10;void Bubble(T a[], int n)&#123;&#10;    for (int i = 0; i &#60; n-1; i++)&#123;&#10;        if (a[i]&#62;a[i + 1])&#10;            Swap(a[i], a[i + 1]);&#10;    &#125;&#10;&#125;&#10;&#10;/*&#23545;&#25968;&#32452;a[0:n - 1]&#20013;&#30340;n&#20010;&#20803;&#32032;&#36827;&#34892;&#20882;&#27873;&#25490;&#24207;*/&#10;template &#60;class T&#62;&#10;void BubbleSort(T a[], int n)&#10;&#123;&#10;    for (int i = n; i&#62;1; i--)&#10;            Bubble(a, i);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种实现方法中元素比较的次数是$(n-1)n\over 2$。</p>
<p>冒泡排序跟选择排序一样，也是需要设计一个可以及时终止的冒泡排序函数。如果在一次冒泡过程中没有发生元素互换，这说明数组已经按序排列，没有必要再继续进行冒泡过程。</p>
<p>实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#19968;&#27425;&#20882;&#27873;*/&#10;template&#60;class T&#62;&#10;bool Bubble(T a[], int n)&#123;&#10;    // &#27809;&#26377;&#21457;&#29983;&#20132;&#25442;&#10;    bool isSwaped = false;&#10;    for (int i = 0; i &#60; n - 1; i++)&#123;&#10;        if (a[i]&#62;a[i + 1])&#123;&#10;            Swap(a[i], a[i + 1]);&#10;            // &#21457;&#29983;&#20102;&#20132;&#25442;&#10;            isSwaped = true;&#10;        &#125;&#10;    &#125;&#10;    return isSwaped;&#10;&#125;&#10;&#10;/*&#23545;&#25968;&#32452;a[0:n - 1]&#20013;&#30340;n&#20010;&#20803;&#32032;&#36827;&#34892;&#20882;&#27873;&#25490;&#24207;*/&#10;template &#60;class T&#62;&#10;void BubbleSort(T a[], int n)&#10;&#123;&#10;    for (int i = n; i &#62; 1 &#38;&#38; Bubble(a, i); i--)&#123;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在最好的情况下比较次数只需要n-1次，而最坏情况则和第一种实现方法相同。</p>
<h5 id="u4F8B5__u63D2_u5165_u6392_u5E8F"><a href="#u4F8B5__u63D2_u5165_u6392_u5E8F" class="headerlink" title="例5 插入排序"></a>例5 插入排序</h5><blockquote>
<p>因为只有一个元素的数组是一个有序数组，所以可以从仅包含欲排序的n个元素的第一个元素的数组开始。通过把第二个元素插入到这个单元数组中，可以得到大小为2的有序数组，并按照这个方法继续进行下去，最终将得到一个大小为n的有序数组。而这种排序方式就是插入排序。</p>
</blockquote>
<p>实现代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#21521;&#19968;&#20010;&#26377;&#24207;&#25968;&#32452;&#20013;&#25554;&#20837;&#20803;&#32032;,&#20551;&#23450;a&#30340;&#22823;&#23567;&#36229;&#36807;n*/&#10;template&#60;class T&#62;&#10;void Insert(T a[], int&#38; n, const T&#38; x)&#123;&#10;    int i;&#10;    for (i = n - 1; i &#62;= 0 &#38;&#38; x &#60; a[i]; i--)&#10;        a[i + 1] = a[i];&#10;    a[i + 1] = x;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InsertionSort(T a[], int n)&#123;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        T t = a[i];&#10;        Insert(a, i, t);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种排序方法，最好的情况下比较次数是n-1，最坏的情况是$(n-1)n\over 2$。</p>
<h4 id="u6267_u884C_u6B65_u6570"><a href="#u6267_u884C_u6B65_u6570" class="headerlink" title="执行步数"></a>执行步数</h4><p>  上述例子都是利用操作计数方法来估算程序的时间复杂性，但会忽略了所选择操作之外其他操作的开销。</p>
<blockquote>
<p>在统计步数的方法中，要统计程序/函数中所有部分的时间开销。与操作计数一样，执行步数也是实例特征的函数。尽管任一个特定的程序可能会有若干个特征(如输入个数，输出个数，输入和输出的大小)，但可以把执行步数看成是其中一部分特征的函数。通常是选择一些感兴趣的特征，例如，如要了解程序的运行时间(即时间复杂性)是如何随着输入个数的增加而增加的，这种情况下，可以把执行步数看成是输入个数的函数。因此在确定一个程序的执行步数之前，必须确切地知道将要采用的实力特征，这些特征不仅定义了执行步数表达式中的变量，而且定义了以多少次计算作为一步。</p>
</blockquote>
<h5 id="u64CD_u4F5C_u6B65"><a href="#u64CD_u4F5C_u6B65" class="headerlink" title="操作步"></a>操作步</h5><p><strong>操作步是独立于所选特征的任意计算单位</strong>，如10次加法可以视为一步，100次乘法也可以视为一步，但n次加法不能视为一步，其中n是实例特征。</p>
<h5 id="u7A0B_u5E8F_u6B65"><a href="#u7A0B_u5E8F_u6B65" class="headerlink" title="程序步"></a>程序步</h5><blockquote>
<p>程序步可以定义为一个语法或语义意义上的程序片段，该片段的执行时间独立于实例特征。</p>
</blockquote>
<p>可以通过设置一个全局变量<code>count</code>(其初始值为0)来确定一个程序或函数为完成其预定任务所需要的执行步数。可以把count引入到程序语句之中，每当原始程序或函数中的一条语句被执行时，就为count累加上该语句所需要的执行步数。</p>
<p>一个例子如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;T Sum(T a[], int n)&#10;&#123;// &#35745;&#31639; a[0:n - 1]&#20013;&#20803;&#32032;&#20043;&#21644;&#10;    T tsum = 0;&#10;    count++; // &#23545;&#24212;&#20110;tsum = 0&#10;    for (int i = 0; i &#60; n; i++) &#123;&#10;        count++; // &#23545;&#24212;&#20110;f o r&#35821;&#21477;&#10;        tsum += a[i];&#10;        count++; // &#23545;&#24212;&#20110;&#36171;&#20540;&#35821;&#21477;&#10;    &#125;&#10;    count++; // &#23545;&#24212;&#20110;&#26368;&#21518;&#19968;&#20010;f o r&#35821;&#21477;&#10;    count++; //&#23545;&#24212;&#20110;r e t u r n&#35821;&#21477;&#10;    return tsum;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数<code>Sum</code>是用来计算一个数组元素之和，通过添加一个全局变量<code>count</code>来计算函数的执行步数。可以得知每次调用该函数需要执行<code>2n+3</code>步。</p>
<h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>时间复杂性的介绍就到这里为止，时间复杂性是由编译时间和运行时间决定，但书中说明了编译时间是与实例特征关，同时也假定了一次编译后就可以不用编译就能进行若干次运行。而在估算运行时间的时候介绍了两种方法，分别是估算操作计数和执行步数，书中分别给出了不少例子，这里记录的例子主要是操作计数中的例子，包括了选择排序，计数排序，插入排序，冒泡排序等。</p>
<p>还是需要在不断编程中不断实践本小节所介绍的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序性能1--空间复杂性]]></title>
    <link href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    <id>http://ccc013.github.io/2016/06/04/程序性能1-空间复杂性/</id>
    <published>2016-06-04T05:26:58.000Z</published>
    <updated>2016-06-07T01:42:44.506Z</updated>
    <content type="html"><![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能1–空间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能2–时间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/">程序性能3–渐进符号</a></li>
</ol>
<h3 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>程序性能：是指运行一个程序所需要的内存大小和时间。<br>可以采用两种方法来确定一个程序的性能，一个是分析的方法，一个是实验的方法。在进行性能分析(performance analysis)时，采用分析的方法；而在进行性能测量(performance measurement)时，借助于实验的方法。</p>
<p>程序的空间复杂性是指运行完一个程序所需要的内存大小。</p>
<p>程序的时间复杂性是指运行完该程序所需要的时间。</p>
</blockquote>
<h3 id="u7A7A_u95F4_u590D_u6742_u6027"><a href="#u7A7A_u95F4_u590D_u6742_u6027" class="headerlink" title="空间复杂性"></a>空间复杂性</h3><h4 id="u7A7A_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210"><a href="#u7A7A_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210" class="headerlink" title="空间复杂性的组成"></a>空间复杂性的组成</h4><p>程序所需要的空间主要由以下部分构成：</p>
<ul>
<li>指令空间：是值用来存储经过编译之后的程序指令所需要的空间。</li>
<li>数据空间：是指用来存储所有常量和变量值所需的空间。其主要由两个部分构成：<ul>
<li>存储常量和简单变量所需要的空间</li>
<li>存储复合变量所需要的空间。这一类空间包括数据结构所需要的空间动态分配的空间</li>
</ul>
</li>
<li>环境栈空间：用来保存函数调用返回时恢复运行所需要的信息。例如，如果函数fun1调用了函数fun2，那么至少必须保存fun2结束时fun1将要继续执行的指令的地址。</li>
</ul>
<h5 id="u6307_u4EE4_u7A7A_u95F4"><a href="#u6307_u4EE4_u7A7A_u95F4" class="headerlink" title="指令空间"></a>指令空间</h5><p>  程序所需要的指定空间的数据取决于如下因素：</p>
<ul>
<li>把程序编译成机器代码的编译器；</li>
<li>编译时实际采用的编译器选项；</li>
<li>目标计算机。</li>
</ul>
<p>在决定最终代码需要多少空间的时候，编译器是一个最重要的因素。下图给出了计算表达式<code>a+b+b*c+(a+b-c)/(a+b)+4</code>的三段可能的代码，它们都指向完全相同的算术操作，但每段代码所需要的空间都不一样。所用的编译器将确定产生哪一种代码。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE2-1.png" alt="此处输入图片的描述"></p>
<p>即使采用相同的编译器，所产生程序代码的大小也可能不一样。例如，一个编译器可能为用户提供优化选项，<strong>如代码优化以及执行时间优化等</strong>。如，在图2-1中，非优化模式下，编译器可以产生图2-1b的代码，而优化模式下，则会产生图2-1c中更短更高效的代码。<strong>使用优化模式通常会增加程序编译所需要的时间</strong>。</p>
<p>另一种可以显著减少程序空间的编译器选项就是<strong>覆盖选项</strong></p>
<blockquote>
<p>覆盖模式：空间仅分配给当前正在执行的程序模块，在调用一个新的模块时，需要从磁盘或从其他设备中读取，新模块的代码将覆盖原模块的代码。所以程序的空间就等价于最大的模块所需要的空间，而不是所有模块之和。</p>
</blockquote>
<p>目标计算机的配置也会影响代码的规模。比如计算机具有浮点处理硬件，则每个浮点操作都可以转换成一条机器指令。如果没有安装浮点处理硬件，则必须生成仿真的浮点计算代码。</p>
<h5 id="u6570_u636E_u7A7A_u95F4"><a href="#u6570_u636E_u7A7A_u95F4" class="headerlink" title="数据空间"></a>数据空间</h5><p>对于简单变量和常量来说，所需要的空间取决于<strong>所使用的计算机和编译器以及变量与常量的数目</strong>。</p>
<p>对于一个结构变量，可以把它的每个成员所占用的空间累加起来即可得到该变量所需要的内存。类似地，可以得到一个数组变量所需要的空间，方法是用数组的大小乘以单个数组元素所需要的空间。</p>
<p>比如对于<code>double a[100];</code>，数组a需要的空间是100个double类型元素所占用的空间，若每个元素占用8个字节，则分配给数组的空间总量为800字节。</p>
<h5 id="u73AF_u5883_u6808"><a href="#u73AF_u5883_u6808" class="headerlink" title="环境栈"></a>环境栈</h5><p> 每当一个函数被调用时，下面的数据将被保存在环境栈中：</p>
<ul>
<li>返回地址</li>
<li>函数被调用时所有局部变量的值以及传值形式参数的值(仅对于递归函数而言)</li>
<li>所有引用参数及常量引用参数的定义。</li>
</ul>
<p><strong>值得注意的是</strong>，有些编译器在保留局部变量的值、传值形式参数的值以及引用参数和常量引用参数的定义时，对于递归函数和非递归函数一视同仁，而有些编译器仅为递归函数保存上述内容。所以实际使用的编译器将影响环境栈所需要的空间。</p>
<h5 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h5><p> <strong>指令空间的大小对于所解决的特定问题不够敏感。常量及简单变量所需要的数据空间也独立于所解决的问题</strong>，除非相关数的大小对于所选定的数据类型来说实在太大，这时，要么改变数据类型，要么使用多精度算法重写该程序，然后再对新程序进行分析。<br>  <strong>复合变量及动态分配所需要的空间同样独立于问题的规模</strong>。<strong>而环境栈通常独立于实例的特征</strong>，除非正在使用递归函数。在使用递归函数时，实例特征通常(但不总是)会影响环境栈所需要的空间数量。</p>
<blockquote>
<p>实例的特征包含决定问题规模的因素，如输入输出的数量或相关数的大小。例如，对于一个对n个元素进行排序的程序，可以确定该程序所需要的空间为n的函数；</p>
</blockquote>
<p>因此，可以把一个程序所需要的空间分成两部分：</p>
<blockquote>
<ul>
<li>固定部分，它独立于实例的特征。一般来说，这一部分包含指定空间(即代码空间)、简单变量及定长复合变量所占用空间、常量占用空间等；</li>
<li>可变部分，它由以下部分构成：复合变量所需的空间(这些变量的大小依赖于所解决的具体问题)，动态分配的空间(这种空间一般都依赖于实例的特征)，以及递归栈所需要的空间(该空间也依赖于实例的特征).</li>
</ul>
</blockquote>
<p>任意程序P所需要的空间<code>S(P)</code>可以表示为：<br>$S(P) = c + S_p(实例特征)$<br>其中c是一个常量，表示固定部分所需要的空间，而$S_p$表示可变部分所需要的空间。一个精确的分析还应当包括在<strong>编译期间所产生的临时变量所需要的空间，这种空间是与编译器直接相关的，除依赖于递归函数外，它还依赖于实例的特征</strong>。<br>在分析程序的空间复杂性时，我们将把注意力集中在估算$S_p$(实例特征)上。对于任意给定的问题，首先需要确定实例的特征以便于估算空间需求。<strong>一般，实例特征的选择会受到相关数的数量以及程序输入和输出的规模的限制。</strong></p>
<h4 id="u4E3E_u4F8B"><a href="#u4E3E_u4F8B" class="headerlink" title="举例"></a>举例</h4><p>这里举例说明，例子如下：</p>
<blockquote>
<p>[顺序搜索] 下列程序从左至右检查数组a[0:n-1]中的元素，以查找与x相等的那些元素。如果找到一个元素与x相等，则函数返回x第一次出现所在的位置。如果在数组中没有找到这样的元素，函数返回-1.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#22312;&#26410;&#25490;&#24207;&#30340;&#25968;&#32452; a [ 0 : n-1 ]&#20013;&#25628;&#32034; x&#10;  &#22914;&#26524;&#25214;&#21040;&#65292;&#21017;&#36820;&#22238;&#25152;&#22312;&#20301;&#32622;&#65292;&#21542;&#21017;&#36820;&#22238;- 1*/&#10;template&#60;class T&#62;&#10;int SequentialSearch(T a[], const T&#38; x, int n)&#10;&#123;&#10;    int i;&#10;    for (i = 0; i &#60; n &#38;&#38; a[i] != x; i++);&#10;    if (i == n) return -1;&#10;    return i;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望采用实例特征n来估算该函数的空间复杂性。假定T是<code>int</code>类型，则数组a中的每个元素需要2个字节，实例x需要2个字节，传值形式参数n也需要2个字节，局部变量i需要2个字节，每个整型常量0和-1也分别需要2个字节。因此，所需要的总的数据空间是12字节，因为该空间独立于n，所以$S_{顺序搜索}$(n) = 0.</p>
<p>注意数组a必须足够大以容纳所查找的n个元素。不过，该数组所需要的空间已在定义实际参数(对应于a)的函数中分配，所以不需要把该数组所需要的空间加到上述函数<code>SequentialSearch</code>所需要的空间上去。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[线性代数]Note 1--方程组的几何解释]]></title>
    <link href="http://ccc013.github.io/2016/05/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-Note-1-%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/"/>
    <id>http://ccc013.github.io/2016/05/30/线性代数-Note-1-方程组的几何解释/</id>
    <published>2016-05-30T06:06:39.000Z</published>
    <updated>2016-05-30T11:06:52.501Z</updated>
    <content type="html"><![CDATA[<p>这是记录麻省理工学院公开课：线性代数的笔记，网址是<a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="external">麻省理工公开课：线性代数</a><br>第一节课说的是有关方程组的几何解释。网址是<a href="http://open.163.com/movie/2010/11/7/3/M6V0BQC4M_M6V29E773.html" target="_blank" rel="external">方程组的几何解释</a></p>
<hr>
<p> 首先是介绍方程组的几何解释，提出可以用矩阵表示，然后矩阵表示有两种表达方式，分别是行图像和列图像。行图像比较常见，比如两条直线相交，而列图像则比较少见。</p>
<h3 id="u4E24_u4E2A_u672A_u77E5_u6570_u4E24_u4E2A_u65B9_u7A0B"><a href="#u4E24_u4E2A_u672A_u77E5_u6570_u4E24_u4E2A_u65B9_u7A0B" class="headerlink" title="两个未知数两个方程"></a>两个未知数两个方程</h3><p> 然后老师举例说明，首先是两个方程组两个未知数的例子，例子如下所示：<br>$$<br> \begin{cases}<br> \ 2x-y = 0 \\<br> \ -x+3y= 3<br> \end{cases}<br>$$</p>
<p>用行图像表示如下所示：<br>$$<br> \left[\begin{matrix}2 &amp; -1  \\ -1 &amp; 3  \end{matrix} \right] \left[\begin{matrix} x \\ y \end{matrix}\right]  = \left[\begin{matrix} 0 \\ 3 \end{matrix}\right]<br>$$</p>
<p>这里用<strong>A</strong>=$ \left[\begin{matrix} 2 &amp; -1  \\ -1 &amp; 3  \end{matrix} \right]$,<strong>x</strong> = $\left[\begin{matrix} x\\ y \end{matrix}\right]$,<strong>b</strong>=$\left[\begin{matrix} 0 \\ 3 \end{matrix}\right] $,可以得到<code>Ax =b</code></p>
<p>这里表示的就是两条直线，并且它们相交于点<code>(1,2)</code>。</p>
<p>如果是用列向量，则如下所示：<br>$$<br> x\left[\begin{matrix}2 \\ -1 \end{matrix} \right] + y\left[\begin{matrix}-1\\3\end{matrix}\right] = \left[\begin{matrix} 0\\ 3 \end{matrix}\right]<br>$$</p>
<p>对于这种写法，老师称之为列向量的线性组合，然后在二维坐标平面上表示了这两个向量，而这个列向量的线性组合的解，其实在用行图像表示的时候已经得到了，就是<code>x=1, y=2</code>。</p>
<h3 id="u4E09_u4E2A_u672A_u77E5_u6570_u4E09_u4E2A_u65B9_u7A0B_u7EC4"><a href="#u4E09_u4E2A_u672A_u77E5_u6570_u4E09_u4E2A_u65B9_u7A0B_u7EC4" class="headerlink" title="三个未知数三个方程组"></a>三个未知数三个方程组</h3><p>  接着老师给出了三个未知数的情况，举例如下所示<br>$$<br> \begin{cases}<br> \ 2x-y = 0 \\<br> \ -x+2y-z = -1 \\<br> \    -3y+4z = 4<br> \end{cases}<br>$$<br> 使用行图像表示，<strong>A</strong> = $ \left[\begin{matrix}2 &amp; -1 &amp; 0 \\ -1 &amp; 2 &amp; -1 \\ 0 &amp; -3 &amp; 4\end{matrix}\right]$,<strong>b</strong>=$\left[\begin{matrix}0 \\ -1 \\4\end{matrix}\right]$,</p>
<p> 使用列图像表示是如下所示：<br> $$<br>  x\left[ \begin{matrix} 2 \\ -1 \\0\end{matrix} \right]+y\left[ \begin{matrix}-1 \\ 2 \\ -3\end{matrix} \right]+z\left[ \begin{matrix}0 \\ -1 \\ 4\end{matrix} \right]=\left[ \begin{matrix} 0 \\ -1 \\ 4\end{matrix} \right]<br> $$</p>
<p> 如果通过行图像来求解，需要通过在三维坐标轴上画出3个平面求平面的交点，这是非常困难的。(这里老师也说了下一节课会介绍消元法来求解)。</p>
<p> 而如果看列图像，则可以轻松得到答案：<code>x=0,y=0,z=1</code>，当然这是老师特意设计的题目，所以才这么容易得到这个答案。</p>
<p> 然后老师就问了一个问题：</p>
<blockquote>
<p>对任意的<strong>b</strong>，都能令<code>Ax = b</code>有解吗？<br>这个问题对于这个三个未知数的例子来说，等价于这个例子中的列向量的线性组合是否能覆盖整个三维空间？</p>
</blockquote>
<p>这里的答案当然是不能确定的，如果三个列向量都是在同一个平面上，那么得到的解也就只是在同一个平面的。</p>
<h3 id="u77E9_u9635_u5411_u91CF_u76F8_u4E58_u7684_u89E3_u6CD5"><a href="#u77E9_u9635_u5411_u91CF_u76F8_u4E58_u7684_u89E3_u6CD5" class="headerlink" title="矩阵向量相乘的解法"></a>矩阵向量相乘的解法</h3><p>最后老师介绍了矩阵与向量相乘的两种解法，首先是一个例子<br>$$<br> \left[ \begin{matrix}2 &amp; 5\\1 &amp; 3\end{matrix}\right] \left[\begin{matrix}1\\2\end{matrix}\right]<br>$$<br>两种解法分别是按照行向量还是列向量来解答的。</p>
<p>第一种，如果是按照列向量解答，则可以写成如下所示：<br>$$<br> \left[ \begin{matrix}2 &amp; 5\\1 &amp; 3\end{matrix}\right] \left[\begin{matrix}1\\2\end{matrix}\right] = 1\left[ \begin{matrix}2 \\1\end{matrix}\right]+ 2 \left[ \begin{matrix}5\\3\end{matrix}\right] = \left[ \begin{matrix}12\\7\end{matrix}\right]<br>$$</p>
<p>第二种，就是按行来求解，如下所示：<br>$$<br>  \left[ \begin{matrix}2 &amp; 5 \\ 1 &amp; 3 \end{matrix}\right] \left[\begin{matrix}1\\ 2 \end{matrix}\right] = \left[ \begin{matrix} 2*1+5*2 \\ 1*1+3*2 \end{matrix}\right] = \left[ \begin{matrix} 12 \\ 7 \end{matrix}\right]<br>$$<br>也就是第一个矩阵的第一行乘以第二个向量的对应列，然后第二行乘以第二个向量的对应列。</p>
<p>这种解法也是当初刚开始学习线性代数所学习的方法。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>这节课的收获主要是了解到列向量这种求法，之前对于矩阵的求解，还是通过按行来相乘求解的。不过在这节课中的例子都是矩阵乘以向量得到一个向量，如果是矩阵之间的相乘，不知道是否还是可以如此解决。</p>
<p>最后是手写笔记如下所示<br> <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%89%AB%E6%8F%8F_20160529215117.jpg" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是记录麻省理工学院公开课：线性代数的笔记，网址是<a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="external">麻省理工公开课：线性代数</a><br>]]>
    </summary>
    
      <category term="线性代数" scheme="http://ccc013.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android官方文档Guide阅读系列(2)--Device Compatibility]]></title>
    <link href="http://ccc013.github.io/2016/04/20/Device-Compatibility/"/>
    <id>http://ccc013.github.io/2016/04/20/Device-Compatibility/</id>
    <published>2016-04-20T06:13:07.000Z</published>
    <updated>2016-05-19T00:34:37.911Z</updated>
    <content type="html"><![CDATA[<p>第二篇文章：<a href="http://android.xsoftlab.net/guide/practices/compatibility.html" target="_blank" rel="external">设备的兼容性(Device Compatibility)</a></p>
<h3 id="u8BBE_u5907_u7684_u517C_u5BB9_u6027_28Device_Compatibility_29"><a href="#u8BBE_u5907_u7684_u517C_u5BB9_u6027_28Device_Compatibility_29" class="headerlink" title="设备的兼容性(Device Compatibility)"></a>设备的兼容性(Device Compatibility)</h3><p>Android 现在可以运行在不同的设备上，不只是手机，还有平板电脑，电视。为了能让应用可以成功在这些设备上正常运行，应用应该允许一些特征功能的多样性并且可以提供一个灵活的用户界面来适应不同的屏幕配置。</p>
<p>为了达成这个目标，Android 提供一个可以让开发者使用一些静态文件(如对于不同屏幕尺寸的不同<code>XML</code>布局)来使用特定的配置的应用资源的动态应用框架。Android 可以根据当前设备的配置来加载合适的资源。所以对于开发者，在将你的程序打包成<code>apk</code>文件前，考虑好使用几套资源文件，比如使用几套不同大小的图片来适应不同的屏幕尺寸，对于手机和平板电脑要分别设置不同的布局文件等，这样当发布了你的应用后，就可以给使用不同设备的用户一个最好的用户体验。</p>
<p>最好的情况还是开发者可以指定其应用的功能要求，这样可以控制能够安装其应用的设备类型。更多有关让你的应用适应不同设备的内容，可以查看<a href="http://android.xsoftlab.net/training/basics/supporting-devices/index.html" target="_blank" rel="external">Supporting Different Devices</a>。</p>
<hr>
<h3 id="u517C_u5BB9_u6027_u610F_u5473_u7740_u4EC0_u4E48_uFF1F"><a href="#u517C_u5BB9_u6027_u610F_u5473_u7740_u4EC0_u4E48_uFF1F" class="headerlink" title="兼容性意味着什么？"></a>兼容性意味着什么？</h3><p>  当你阅读了越来越多有关 Android 开发的文章后，你可能在不同情况下会看到这个词语–<code>兼容性</code>。兼容性分为两种，一是设备的兼容性，二是应用的兼容性。</p>
<p>  因为 Android 是一个开源项目，所以任何硬件制造商都可以制造一个能运行 Android 系统的设备，但是一个设备被称为是”兼容 Android”只有在该设备上可以正常运行在 <code>Android 执行环境</code>下编写的应用的前提。而有关<code>Android 执行环境</code>的细节可以查看<a href="http://source.android.com/compatibility/overview.html" target="_blank" rel="external"> Android compatibility program</a>,然后每个设备都必须通过兼容性测试套件(Compatibility Test Suite, CTS)才被认为是可兼容的。</p>
<p>  当然，作为一名应用开发者，是根本不需要考虑设备是否是兼容 Android的，因为可以包含谷歌应用商店(Google Play Store) 的设备都是可以兼容Android的，换句话说，能够安装你的应用的用户都是使用一台兼容Android的设备。</p>
<p>  那么，开发者需要考虑的就是你的应用的兼容性问题了。这也是因为 Android 可以运行在不同配置的设备上，有些功能不是所有的设备都具备的。比如一些设备是不具备有指南针传感器的，所以如果应该的核心功能需要有指南针传感器，那么就只有拥有这指南针传感器的设备可以使用你的应用了。</p>
<hr>
<h3 id="u63A7_u5236_u5E94_u7528_u5BF9_u8BBE_u5907_u7684_u53EF_u7528_u6027"><a href="#u63A7_u5236_u5E94_u7528_u5BF9_u8BBE_u5907_u7684_u53EF_u7528_u6027" class="headerlink" title="控制应用对设备的可用性"></a>控制应用对设备的可用性</h3><p>  Android 支持很多特性功能，这些功能有些是需要硬件支持的，比如上述的指南针传感器，有些是基于软件的，比如应用程序部件，还有一些是依赖于平台的版本。不是每一种设备都支持所有的功能，所以开发者需要根据应用所要求的功能来控制应用对设备的可用性。</p>
<p>  为了让更多的用户可以使用你的应用，你应该在使用一个单独的<code>APK</code>的情况下支持尽可能多的设备配置。大多数情况下，你可以在运行的时候关闭可选的功能特性，然后根据不同配置使用不同资源文件(比如不同屏幕尺寸的布局文件，具体参考<a href="http://android.xsoftlab.net/guide/topics/resources/providing-resources.html" target="_blank" rel="external">提供应用资源</a>)。如果可能，你是可以在谷歌应用商店中根据以下几种设备的特性来限制你的应用的可用性:</p>
<ul>
<li>设备功能(Device features)</li>
<li>平台版本(Platform version)</li>
<li>屏幕配置(Screen configuration)</li>
</ul>
<hr>
<h4 id="u8BBE_u5907_u529F_u80FD_28Device_features_29"><a href="#u8BBE_u5907_u529F_u80FD_28Device_features_29" class="headerlink" title="设备功能(Device features)"></a>设备功能(Device features)</h4><p>  Android 给所有的硬件或软件功能都提供了功能<code>IDs</code>，比如对于指南针传感器的功能 ID 就是<a href="http://android.xsoftlab.net/reference/android/content/pm/PackageManager.html#FEATURE_SENSOR_COMPASS" target="_blank" rel="external"><code>FEATURE_SENSOR_COMPASS</code></a>,而应用程序组件的 ID 是<a href="http://android.xsoftlab.net/reference/android/content/pm/PackageManager.html#FEATURE_APP_WIDGETS" target="_blank" rel="external"><code>FEATURE_APP_WIDGETS</code></a>.</p>
<p>  在你的应用的<a href="http://android.xsoftlab.net/guide/topics/manifest/manifest-intro.html" target="_blank" rel="external"><code>manifest file</code></a>可以通过使用<a href="http://android.xsoftlab.net/guide/topics/manifest/uses-feature-element.html" target="_blank" rel="external"><code>&lt;uses-feature&gt;</code></a>来声明所需要的功能从而防止不具备应用所需要的功能的设备的用户安装你的应用。</p>
<p>  一个要求必须具备指南针传感器功能的应用可以如此写明该功能要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;manifest ... &#62;&#10;    &#60;uses-feature android:name=&#34;android.hardware.sensor.compass&#34;&#10;                  android:required=&#34;true&#34; /&#62;&#10;    ...&#10;&#60;/manifest&#62;</span><br></pre></td></tr></table></figure>
<p>  当然如果你的应用主要功能并不需要一个设备的功能，可以将上述代码中的<code>required</code>设置为<code>false</code>，然后在运行的时候检查设备的功能。如果应用的功能在当前设备上不可用的时候，那么可以关闭这项功能。一个检查当前设备是否具备某个功能的代码例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PackageManager pm = getPackageManager();&#10;if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) &#123;&#10;    // This device does not have a compass, turn off the compass feature&#10;    disableCompassFeature();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用到了<a href="http://android.xsoftlab.net/reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String" target="_blank" rel="external">`hasSystemFeature()’</a>)这个函数，主要是检查设备是否支持某个功能，如果有返回<code>true</code>，否则返回<code>false</code>。</p>
<blockquote>
<p>注意：有些<a href="http://android.xsoftlab.net/guide/topics/security/permissions.html" target="_blank" rel="external">系统权限</a>暗含着需要某些设备功能的支持。比如，如果你的应用需要蓝牙(<code>BLUETOOTH</code>)功能，它其实是需要有<code>FEATURE_BLUETOOTH</code>这个设备功能的。当然你也可以通过在<code>&lt;uses-feature&gt;</code>中对于的功能设置<code>required = false</code>来使得你的应用也可以运行在不具备蓝牙功能的设备上。更多的有关需要设备功能的权限的信息，可以查看<a href="http://android.xsoftlab.net/guide/topics/manifest/uses-feature-element.html#permissions" target="_blank" rel="external">Permissions that Imply Feature Requirements</a>。</p>
</blockquote>
<hr>
<h4 id="u5E73_u53F0_u7248_u672C_28Platform_version_29"><a href="#u5E73_u53F0_u7248_u672C_28Platform_version_29" class="headerlink" title="平台版本(Platform version)"></a>平台版本(Platform version)</h4><p>  不同的设备可能运行不同的系统版本，比如 Android 4.0 和 Android 4.4。而每个连续的系统版本都会增加一些前一个版本不可用的新的 APIs。每个系统版本都有指定一个 <a href="http://android.xsoftlab.net/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="external"><code>API level</code></a>。</p>
<p>  使用<code>API level</code>可以指定你的应用可以兼容的最低系统版本，需要使用<code>minSdkVersion</code>(在Android Studio中这个功能是放在<code>build.gradle</code>中了);同样也可以指定你的应用最适合使用的版本，使用<code>targetSdkVersion</code>这个属性。</p>
<p>  同样的可以在代码中动态地检查当前设备使用的系统版本是否能够支持应用的某些功能，代码例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &#60; Build.VERSION_CODES.HONEYCOMB) &#123;&#10;    // Running on something older than API level 11, so disable&#10;    // the drag/drop features that use ClipboardManager APIs&#10;    disableDragAndDrop();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子是使用了<a href="http://android.xsoftlab.net/reference/android/content/ClipboardManager.html" target="_blank" rel="external">剪切板(ClipboardManager)</a>，这个API是在 API level 11中才增加的，所以低于这个系统版本的是无法实现这个功能的。</p>
<hr>
<h4 id="u5C4F_u5E55_u914D_u7F6E_28Screen_configuration_29"><a href="#u5C4F_u5E55_u914D_u7F6E_28Screen_configuration_29" class="headerlink" title="屏幕配置(Screen configuration)"></a>屏幕配置(Screen configuration)</h4><p>  Android 可以运行在不同的屏幕尺寸上，包括手机，平板电脑以及电视。为了更好的根据屏幕类型来分类设备，Android 对每个设备都定义了两种特性: 屏幕尺寸(屏幕的物理尺寸）,以及屏幕密度(屏幕的物理密度，如<code>dpi</code>)。而为了简化这些不同的配置，Android 分别为这两种特性生成一些变量来方便使用：</p>
<ul>
<li>4种屏幕尺寸: <code>small</code>,<code>normal</code>,<code>large</code>,<code>xlarge</code>;</li>
<li>几种密度: <code>mdpi(medium)</code>,<code>hdpi(hdpi)</code>,<code>xhdpi(extra high)</code>,<code>xxhdpi(extra-extra hdpi)</code>等。</li>
</ul>
<hr>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>  这篇教程主要是说明 Android 的兼容性问题，主要是3个方面的兼容性问题，一是设备的功能，二是系统版本，三是屏幕配置。这些问题的产生原因当然是因为Android是一个开源的系统，所以很多手机制造商都可以运行 Android 的系统，但是这造成了有很多不同配置，不同屏幕大小的 Android 手机，所以这也是在开发过程必须考虑的一个问题，兼容性问题，当然个人感觉主要是最后一个问题会考虑得主要多点，就是屏幕配置问题，现在有很多尺寸的手机，不同分辨率的手机，在考虑界面的时候就需要多做几套图片，几个布局文件来适应尽可能多的不同屏幕配置的手机。</p>
<p>  关于屏幕适配的文章，这里推荐下最近看到的几篇文章，包括几位大神的文章：</p>
<ul>
<li>郭霖： <a href="http://blog.csdn.net/guolin_blog/article/details/8830286" target="_blank" rel="external">Android官方提供的支持不同屏幕大小的全部方法</a></li>
<li>Stormzhang：<a href="http://stormzhang.com/android/2014/05/16/android-screen-adaptation/" target="_blank" rel="external">Android 屏幕适配</a></li>
<li>鸿洋：<a href="http://blog.csdn.net/lmj623565791/article/details/45460089" target="_blank" rel="external">Android 屏幕适配方案</a></li>
<li>凯子： <a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023" target="_blank" rel="external">Android屏幕适配全攻略(最权威的官方适配指导)</a></li>
<li><p>Carson_Ho: <a href="http://www.jianshu.com/p/ec5a1a30694b" target="_blank" rel="external">Android开发：最全面、最易懂的Android屏幕适配解决方案</a></p>
<p>屏幕适配也是一个很重要的知识点，所以也是需要找时间好好看看这方面的内容。</p>
<p>最后，如果有翻译不对，或者表达错误的地方，欢迎指正。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>第二篇文章：<a href="http://android.xsoftlab.net/guide/practices/compatibility.html" target="_blank" rel="external">设备的兼容性(Device Compatibility]]>
    </summary>
    
      <category term="Android" scheme="http://ccc013.github.io/tags/Android/"/>
    
      <category term="阅读笔记" scheme="http://ccc013.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
