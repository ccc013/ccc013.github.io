<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Cai's blog]]></title>
  <subtitle><![CDATA[Stay hungry, stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ccc013.github.io/"/>
  <updated>2016-12-31T08:38:29.424Z</updated>
  <id>http://ccc013.github.io/</id>
  
  <author>
    <name><![CDATA[cai]]></name>
    <email><![CDATA[429546420@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2016总结 & 2017展望]]></title>
    <link href="http://ccc013.github.io/2016/12/31/2016%E6%80%BB%E7%BB%93-2017%E5%B1%95%E6%9C%9B/"/>
    <id>http://ccc013.github.io/2016/12/31/2016总结-2017展望/</id>
    <published>2016-12-31T08:30:39.000Z</published>
    <updated>2016-12-31T08:38:29.424Z</updated>
    <content type="html"><![CDATA[<h4 id="2016__u603B_u7ED3"><a href="#2016__u603B_u7ED3" class="headerlink" title="2016 总结"></a>2016 总结</h4><p>对于2016年，最大的感觉还是自己还总是处于变化的过程吧，主要是对求职方向的变化，上半年主要是处于学习Android的过程，但是后来听了师兄的话后，大概就是6月底，就开始转变，想要往机器学习算法岗位准备，然后到了10月份左右，随着时间和自己准备两方面考虑，又决定应该往C++开发，但是跟师兄交流后，发现似乎这个方向需要准备的东西要更多，还是好好准备机器学习算法岗位吧。这么来来回回变化，也是自己性格上的缺点吧，缺乏恒心，不能坚持太久，或者其实是自己太过浮躁了，每次都有点过于冲动地考虑，又特别容易后悔自己做过的决定，这真的是需要在未来的一年里面去改进的，需要有恒心，专心和坚持完成一件事情。</p>
<p>科研进展方向，自己是写了一篇中文的论文，第一次投稿是被拒绝了，现在第二次投稿，尚处于审稿中，希望可以顺利收录；然后就是看了多篇论文啦，还看完一本介绍Caffe的，也尝试修改了一些代码，但是基本是根据网上别人的代码来修改的，复现的方法也能找到代码，现在毕设题目也是确定了，需要做的就是设计自己的算法，能够有足够的创新性吧。</p>
<p>编程方面，上半年也是看了一两本Android方面的书，然后C++方面，看完《C++ primer plus》，看完《大话数据结构》和《数据结构算法与应用：C++描述》，算法方面则看了《剑指offer》，看完《机器学习》（年终最后一天完成），《现代操作系统》则根据师兄的建议，看完前面比较重要的六章，而Linux方面，正在看鸟哥的《Linux私房菜–基础学习篇》，看完前面十一章内容，打算是看到第三部分的，目前就剩下两章内容，估计需要多两到三天的时间。这是书籍方面的阅读，此外，还有到LeetCode上刷题，目前做了20多道题目，然后在牛客网上也做了不少编程题目，数据结构和操作系统练习，都需要继续坚持。</p>
<p>此外，还是有坚持做了一些笔记，主要是数据结构和算法学习的笔记，需要继续保持。在博客方面，我的技术博客上是发表了30篇日志，当然主要是数据结构学习的比较和总结文章。而在CSDN博客方面，也写了有37篇博文，主要是下半年开始增多，前面主要是机器学习的时候的笔记，之后就是有一些论文阅读笔记和算法学习笔记。而Github方面，今年提交次数也有两百多近三百，当然提交的也都是上述的笔记内容。</p>
<p>其他，锻炼方面也是断断续续做着，还不能很好地坚持，所以基本上体重没有比去年减少多少；旅游方面，上半年去了武汉参加一次会议，然后都是省内游了。</p>
<h4 id="2017__u5C55_u671B"><a href="#2017__u5C55_u671B" class="headerlink" title="2017 展望"></a>2017 展望</h4><p>首先是希望在上半年找到一份比较好的实习，目前求职岗位是机器学习算法，所以希望找到机器学习算法相关的岗位，所以这需要前面两个多月继续好好看书，刷题准备；</p>
<p>其次是希望投稿的论文可以顺利被收录，这样也可以达成毕业条件了。</p>
<p>接着就是下半年秋招可以找到一份好的工作，实习的时候也要争取能收到留下的offer。</p>
<p>最后就是搞定毕设，写好毕设论文了。</p>
<p>上述算是明年比较重要的四件事情了。在这其中，对于找实习还是工作，首先还是需要继续学习，书籍阅读方面，《统计学习方法》是需要好好看透，理解好的，然后《TCP/IP 协议》也要看，掌握网络知识；python方面的知识也要复习一下；然后就是看看《大话设计模式》和《STL源码剖析》，继续加强C++编程能力。</p>
<p>然后需要继续坚持做笔记，写博客，上传代码到Github。希望博客内容可以有更多干货，不只是阅读书籍的学习笔记，还有更多实践内容，比如一些自己做的项目代码，一些应用的实现等。</p>
<p>最后就是坚持锻炼身体，继续减脂训练，跑步和力量训练都要有序进行。</p>
<p>总而言之，希望能够更加专注，更加坚持，脚踏实地做好每件计划好的事情。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="2016__u603B_u7ED3"><a href="#2016__u603B_u7ED3" class="headerlink" title="2016 总结"></a>2016 总结</h4><p>对于2016年，最大的感觉还是自己还总是处于变化的过程吧，主]]>
    </summary>
    
      <category term="总结" scheme="http://ccc013.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="随笔" scheme="http://ccc013.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <link href="http://ccc013.github.io/2016/11/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ccc013.github.io/2016/11/20/排序算法总结/</id>
    <published>2016-11-20T05:27:44.000Z</published>
    <updated>2016-12-08T03:18:55.965Z</updated>
    <content type="html"><![CDATA[<p>这是《大话数据结构》第九章排序算法的知识点总结。</p>
<h4 id="u6392_u5E8F_u7684_u57FA_u672C_u6982_u5FF5_u4E0E_u5206_u7C7B"><a href="#u6392_u5E8F_u7684_u57FA_u672C_u6982_u5FF5_u4E0E_u5206_u7C7B" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h4><blockquote>
<p>假设含有n个记录的序列为${r_1,r_2,\cdots,r_n}$，其相应的关键字分别为${k_1,k_2,\cdots,k_n}$，需要确定$1,2, \cdots, n$的一种排列$p_1,p_2,\cdots,p<em>n$，使其相应的关键字满足$k</em>{p1}\le k<em>{p2}\le \cdots \le k</em>{pn}$非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列${r<em>{p1}, r</em>{p2}, \cdots, r_{pn}}$，这样的操作就称为排序。</p>
</blockquote>
<p><strong>在排序问题中，通常将数据元素称为记录。</strong></p>
<p>排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p>
<p>这里关键字$k_i$可以是记录$r$的主关键字，也可以是次关键字，甚至是若干数据项的组合。</p>
<h5 id="u6392_u5E8F_u7684_u7A33_u5B9A_u6027"><a href="#u6392_u5E8F_u7684_u7A33_u5B9A_u6027" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h5><p>由于排序不仅是针对主关键字，还有针对次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，下面给出稳定与不稳定排序的定义。</p>
<blockquote>
<p>假设$k_i = k_j \ (1\le i \le n, 1\le j\le n, i\neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i \lt j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先于$r_i$，则称所用的排序方法是不稳定的。</p>
</blockquote>
<p>不稳定的排序算法有：<strong>希尔、快速、堆排和选择排序</strong>。</p>
<h5 id="u5185_u6392_u5E8F_u548C_u5916_u6392_u5E8F"><a href="#u5185_u6392_u5E8F_u548C_u5916_u6392_u5E8F" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h5><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序可以分为：内排序和外排序。</p>
<blockquote>
<p>内排序是在排序整个过程中，<strong>待排序的所有记录全部被放置在内存中</strong>。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要<strong>在内外存之间多次交换数据才能进行</strong>。</p>
</blockquote>
<p>对于内排序来说，排序算法的性能主要是受到3个方面的影响：</p>
<h6 id="u65F6_u95F4_u6027_u80FD"><a href="#u65F6_u95F4_u6027_u80FD" class="headerlink" title="时间性能"></a>时间性能</h6><p>在内排序中，主要进行两种操作：<strong>比较和移动</strong>。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</p>
<h6 id="u8F85_u52A9_u7A7A_u95F4"><a href="#u8F85_u52A9_u7A7A_u95F4" class="headerlink" title="辅助空间"></a>辅助空间</h6><p>辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</p>
<h6 id="u7B97_u6CD5_u7684_u590D_u6742_u6027"><a href="#u7B97_u6CD5_u7684_u590D_u6742_u6027" class="headerlink" title="算法的复杂性"></a>算法的复杂性</h6><p>这里指的是算法本身的复杂度，而不是算法的时间复杂度。</p>
<p>根据排序过程中借助的主要操作，我们把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序。</strong></p>
<h5 id="u6392_u5E8F_u7528_u5230_u7684_u7ED3_u6784_u4E0E_u51FD_u6570"><a href="#u6392_u5E8F_u7528_u5230_u7684_u7ED3_u6784_u4E0E_u51FD_u6570" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h5><p>这里先提供一个用于排序用的顺序表结构，这个结构将用于接下来介绍的所有排序算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">10</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 用于存储待排序数组</span></span><br><span class="line">  <span class="keyword">int</span> r[MAXSIZE]; </span><br><span class="line">  <span class="comment">// 用于记录顺序表的长度</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>此外，由于排序最常用到的操作是数组两元素的交换，这里写成一个函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换L中数组r的下标为i和j的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = L-&gt;r[i];</span><br><span class="line">  L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">  L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p><strong>冒泡排序(Bubble sort)是一种交换排序。</strong>它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。</p>
</blockquote>
<p>首先介绍一个简单版本的冒泡排序算法的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序初级版</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort0</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不算是标准的冒泡排序算法，因为不满足“两两比较相邻记录”的冒泡排序思想，它更应该是最简单的交换排序。它的思路是让每一个关键字都和后面的每一个关键字比较，如果大或小则进行交换，这样关键字在一次循环后，第一个位置的关键字会变成最大值或者最小值。</p>
<p>这个最简单的实现算法效率是非常低的。</p>
<p>下面介绍正宗的冒泡排序算法实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正宗的冒泡排序算法实现代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = L-&gt;length - <span class="number">2</span>; j &gt;= i; j--)&#123;</span><br><span class="line">			<span class="comment">// j是从后往前循环</span></span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里改变的地方是在内循环中，<code>j</code>是从数组最后往前进行比较，并且是逐个往前进行相邻记录的比较，这样最大值或者最小值会在第一次循环过后，从后面浮现到第一个位置，如同气泡一样浮到上面。</p>
<p>这段实现代码其实还是可以进行优化的，例如待排序数组是<code>{2,1,3,4,5,6,7,8,9}</code>,需要进行递增排序，可以发现其实只需要交换前两个元素的位置即可完成，但是上述算法还是会在交换完这两者位置后继续进行循环，这样效率就不高了，所以可以在算法中增加一个标志，当有一次循环中没有进行数据交换，就证明数组已经是完成排序的，此时就可以退出算法，实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进版冒泡算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSortOptimz</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length &amp;&amp; flag; i++)&#123;</span><br><span class="line">		<span class="comment">// 若 flag为false则退出循环</span></span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = L-&gt;length - <span class="number">2</span>; j &gt;= i; j--)&#123;</span><br><span class="line">			<span class="comment">// j是从后往前循环</span></span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 如果有数据交换，则flag是true</span></span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法的时间复杂度是$O(n^2)$。</p>
<p>完整的冒泡排序算法代码可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/SortAlgorithms/BubbleSortTest.cpp" target="_blank" rel="external">BubbleSort</a>。</p>
<h4 id="u7B80_u5355_u9009_u62E9_u6392_u5E8F"><a href="#u7B80_u5355_u9009_u62E9_u6392_u5E8F" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><blockquote>
<p>简单选择排序算法(Simple Selection Sort)就是通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字中最小的记录，并和第$i(1\le i \le n)$个记录进行交换。</p>
</blockquote>
<p>下面是实现的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单选择排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, min;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">		min = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &lt; L-&gt;r[min])</span><br><span class="line">				min = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若min不等于i，说明找到最小值，进行交换</span></span><br><span class="line">		<span class="keyword">if</span> (min != i)</span><br><span class="line">			swap(L, i, min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单选择排序的最大特点就是交换移动数据次数相当少。分析其时间复杂度发现，无论最好最差的情况，比较次数都是一样的，都需要比较$\sum_{i=1}^{n-1} (n-i) = (n-1)+(n-2)+\cdots+2+1=\frac{n(n-1)}{2}$次。对于交换次数，最好的时候是交换0次，而最差的情况是$n-1$次。因此，总的时间复杂度是$O(n^2)$，虽然与冒泡排序一样的时间复杂度，但是其性能上还是略好于冒泡排序。</p>
<h4 id="u76F4_u63A5_u63D2_u5165_u6392_u5E8F"><a href="#u76F4_u63A5_u63D2_u5165_u6392_u5E8F" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><blockquote>
<p>直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增加1的有序表。</p>
</blockquote>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j,val;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="comment">// 将L-&gt;r[i]插入有序表中,使用val保存待插入的数组元素L-&gt;r[i]</span></span><br><span class="line">			val = L-&gt;r[i];</span><br><span class="line">			<span class="keyword">for</span> (j = i - <span class="number">1</span>; L-&gt;r[j]&gt;val; j--)</span><br><span class="line">				<span class="comment">// 记录后移</span></span><br><span class="line">				L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[j];	</span><br><span class="line">			<span class="comment">// 插入到正确位置</span></span><br><span class="line">			L-&gt;r[j + <span class="number">1</span>] =val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接插入排序算法是需要有一个保存待插入数值的辅助空间。</p>
<p>在时间复杂度方面，最好的情况是待排序的表本身就是有序的，如{2,3,4,5,6}，比较次数则是$n-1$次，然后不需要进行移动，时间复杂度是$O(n)$。</p>
<p>最差的情况就是待排序表是逆序的情况，如{6,5,4,3,2},此时需要比较$\sum<em>{i=2}^{n} i = \frac{(n+2)(n-1)}{2}$次，而记录的移动次数也达到最大值$\sum</em>{i=2}^{n} (i+1) = \frac{(n+4)(n-1)}{2}$次。</p>
<p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为$\frac{n^2}{4}$。因此，可以得出直接插入排序算法的时间复杂度是$O(n^2)$。同时也可以看出，直接插入排序算法会比冒泡排序和简单选择排序算法的性能要更好一些。</p>
<h4 id="u5E0C_u5C14_u6392_u5E8F"><a href="#u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>上述三种排序算法的时间复杂度都是$O(n^2)$，而希尔排序是突破这个时间复杂度的第一批算法之一。</p>
<p>其实直接插入排序的效率在某些情况下是非常高效的，这些情况是指记录本来就很少或者待排序的表基本有序的情况，但是这两种情况都是特殊情况，在现实中比较少见。而希尔排序就是通过创造条件来改进直接插入排序的算法。</p>
<p>希尔排序的做法是<strong>将原本有大量记录数的记录进行分组，分割成若干个序列</strong>，这样每个子序列待排序的记录就比较少了，然后就可以对子序列分别进行直接插入排序，<strong>当整个序列基本有序时，再对全体记录进行一次直接插入排序。</strong></p>
<p>这里的<strong>基本有序是指小的关键字基本在前面，大的基本在后面，不大不小的在中间。</strong>像{2,1,3,6,4,7,5,8,9}可以称为基本有序。</p>
<p>这里的关键就是如何进行分割，希尔排序采取的是<strong>跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</strong></p>
<p>实现的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j,val;</span><br><span class="line">	<span class="keyword">int</span> increment = L-&gt;length;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="comment">// 增量序列</span></span><br><span class="line">		increment = increment / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = increment; i &lt;= L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i - increment])&#123;</span><br><span class="line">				<span class="comment">// 将L-&gt;r[i]插入有序表中,使用val保存待插入的数组元素L-&gt;r[i]</span></span><br><span class="line">				val = L-&gt;r[i];</span><br><span class="line">				<span class="keyword">for</span> (j = i - increment; j &gt;= <span class="number">0</span> &amp;&amp; L-&gt;r[j]&gt;val; j -= increment)</span><br><span class="line">					<span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">					L-&gt;r[j + increment] = L-&gt;r[j];</span><br><span class="line">				L-&gt;r[j + increment] = val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中增量的选取是<code>increment = increment / 3 + 1</code>，实际上增量的选取是非常关键的，现在还没有人找到一种最好的增量序列，但是大量研究表明，当增量序列是$\delta [k] = 2^{t-k+1} - 1 (0\le k \le t \le \lfloor log_2(n+1)\rfloor)$时，可以获得不错的效率，其时间复杂度是$O(n^{\frac{3}{2}})$，要好于直接插入排序的$O(n^2)$。当然，这里需要注意的是<strong>增量序列的最后一个增量值必须等于1才行</strong>。此外，由于记录是跳跃式的移动，<strong>希尔排序是不稳定的排序算法</strong>。</p>
<h4 id="u6876_u6392_u5E8F"><a href="#u6876_u6392_u5E8F" class="headerlink" title="桶排序"></a>桶排序</h4><p>有一个数量为Size个数的数组A，数组的值范围为(0 - Max)，然后创建一个大小为<code>Max+1</code>的数组B，每个元素都为0.从头遍历A，当读取到A[i]的时候，B[A[i]]的值+1，这样所有的A数组被遍历后，直接扫描B之后，输出表B就可以了。然后再根据B来对A进行排序。</p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得未排序数组中最大的一个元素值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxVal</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxVal = arr[<span class="number">0</span>]; <span class="comment">//假设最大为arr[0]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)  <span class="comment">//遍历比较，找到大的就赋值给maxVal</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">			maxVal = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxVal;  <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong input!"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> size = GetMaxVal(numbers,length) + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(size);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">		bucket[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算数组中每个元素出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = numbers[i];</span><br><span class="line">		bucket[j] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (bucket[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++)&#123;</span><br><span class="line">				numbers[count] = i;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5806_u6392_u5E8F"><a href="#u5806_u6392_u5E8F" class="headerlink" title="堆排序"></a>堆排序</h4><p>简单选择排序在待排序的$n$个记录中选择一个最小的记录需要比较$n-1$次，这是查找第一个数据，所以需要比较这么多次是比较正常的，但是可惜的是它没有把每一趟的比较结果保存下来，这导致在后面的比较中，实际有许多比较在前一趟中已经做过了。因此，如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就会变得很高了。</p>
<p>堆排序(Heap Sort)就是对简单选择排序进行的一种改进，并且效果非常明显。</p>
<blockquote>
<p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为最大堆或者大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为最小堆或者小顶堆。</p>
</blockquote>
<p>下图是一个例子，左边的是大顶堆，而右边的是小顶堆。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png" alt=""></p>
<p>而根据堆的定义，可以知道根结点一定是堆中所有结点最大或者最小者。如果按照层遍历的方式给结点从1开始编号，则结点之间满足下列关系：<br>$$<br>\begin{cases}<br>k<em>i \ge k</em>{2i} \\<br>k<em>i \ge k</em>{2i+1}<br>\end{cases}<br>或<br>\begin{cases}<br>k<em>i \le k</em>{2i} \\<br>k<em>i \le k</em>{2i+1}<br>\end{cases}<br>1 \le i \le \lfloor \frac{n}{2} \rfloor<br>$$<br>如果将上图按照层遍历存入数组，则一定满足上述关系表达，得到的数组如下图所示。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png" alt=""></p>
<blockquote>
<p>堆排序的基本思想是，将待排序的序列构成一个最大堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素进行交换，此时末尾元素就是最大值），然后将剩余的$n-1$个序列重新构成一个堆，这样就会得到$n$个元素中的次最大值。如此反复执行，便能得到一个有序序列。</p>
</blockquote>
<p>下面将给出堆排序算法的代码实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知L-&gt;r[s...m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义</span></span><br><span class="line"><span class="comment">// 本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp, j;</span><br><span class="line">	temp = L-&gt;r[s];</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m - <span class="number">1</span>; j *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="comment">// 沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">		<span class="keyword">if</span> (j &lt; m-<span class="number">1</span> &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">			<span class="comment">// j是关键字中较大的记录的下标</span></span><br><span class="line">			++j;</span><br><span class="line">		<span class="keyword">if</span> (temp &gt;= L-&gt;r[j])</span><br><span class="line">			<span class="comment">// 当前值不需要进行调整</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		L-&gt;r[s] = L-&gt;r[j];</span><br><span class="line">		s = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	L-&gt;r[s] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = L-&gt;length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 将待排序的序列构成一个最大堆</span></span><br><span class="line">		HeapAdjust(L, i, L-&gt;length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始进行排序</span></span><br><span class="line">	<span class="keyword">for</span> (i = L-&gt;length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 将堆顶记录与当前未经排序的子序列的最后一个记录交换</span></span><br><span class="line">		swap(L, <span class="number">0</span>, i);</span><br><span class="line">		<span class="comment">// 重新调整为最大堆</span></span><br><span class="line">		HeapAdjust(L, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，堆排序分两步走，首先是将待排序的序列构造成最大堆，这也是<code>HeapSort()</code>中第一个循环所做的事情，第二个循环也就是第二步，进行堆排序，逐步将每个最大值的根结点和末尾元素进行交换，然后再调整成最大堆，重复执行。</p>
<p>而在第一步中构造最大堆的过程中，是从$\lfloor \frac{n}{2} \rfloor$的位置开始进行构造，这是从下往上、从右到左，将每个非叶结点当作根结点，将其和其子树调整成最大堆。</p>
<p>接下来就是分享堆排序的效率了。堆排序的运行时间主要是消耗在初始构造堆和在重建堆时的反复筛选上。</p>
<p>在构建堆的过程中，因为是从完全二叉树的最下层最右边的非叶结点开始构建，将它与其孩子进行比较和若有必要的交换，对每个非叶结点，最多进行两次比较和互换操作，这里需要进行这种操作的非叶结点数目是$\lfloor \frac{n}{2} \rfloor$个，所以整个构建堆的时间复杂度是$O(n)$。</p>
<p>在正式排序的时候，第$i$取堆顶记录重建堆需要用$O(log i)$的时间(完全二叉树的某个结点到根结点的距离是$\lfloor log_2i \rfloor + 1$)，并且需要取$n-1$次堆顶记录，因此，重建堆的时间复杂度是$O(nlogn)$。</p>
<p><strong>所以，总体上来说，堆排序的时间复杂度是$O(nlogn)$。</strong>由于堆排序对原始记录的排序状态并不敏感，因此它无论最好、最坏和平均时间复杂度都是$O(nlogn)$。同样由于记录的比较与交换是跳跃式进行，<strong>堆排序也不是稳定的排序算法。</strong></p>
<p>另外，由于初始构建堆需要的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p>
<h4 id="u5F52_u5E76_u6392_u5E8F"><a href="#u5F52_u5E76_u6392_u5E8F" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>归并排序(Merging Sort)就是利用归并的思想实现的排序方法，它的原理是假设初始序列有$n$个记录，则可以看成是$n$个有序的子序列，每个子序列的长度为1，然后两两合并，得到$\lceil \frac{n}{2} \rceil$($\lceil x \rceil$表示不小于$x$的最小整数)个长度为2或1的有序子序列；再两两合并，$\cdots \cdots$，如此重复，直至得到一个长度为$n$的有序序列为止，这种排序方法称为2路归并排序。</p>
</blockquote>
<p>下面是介绍实现的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序,使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	MSort(L-&gt;r, L -&gt;r, <span class="number">0</span>, L-&gt;length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将SR[s..t]归并排序为TR1[s..t]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR1[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> TR2[MAXSIZE];</span><br><span class="line">	<span class="keyword">if</span> (s == t)</span><br><span class="line">		TR1[s] = SR[s];</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 将SR[s..t]平分为SR[s...m-1]和SR[m...t]</span></span><br><span class="line">		m = (s + t) / <span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		MSort(SR, TR2, s, m-<span class="number">1</span>);</span><br><span class="line">		MSort(SR, TR2, m, t);</span><br><span class="line">		<span class="comment">// 将TR2[s..m-1]和TR2[m..t]归并到TR1[s..t]</span></span><br><span class="line">		Merge(TR2, TR1, s, m-<span class="number">1</span>, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, k, l;</span><br><span class="line">	<span class="keyword">for</span> (j = m+<span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;</span><br><span class="line">		<span class="comment">// 将SR中记录由小到大并入TR</span></span><br><span class="line">		<span class="keyword">if</span> (SR[i] &lt; SR[j])</span><br><span class="line">			TR[k] = SR[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			TR[k] = SR[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= m)&#123;</span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= m - i; l++)</span><br><span class="line">			<span class="comment">// 将剩余的SR[i..m]复制到TR</span></span><br><span class="line">			TR[k + l] = SR[i + l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &lt;= n)&#123;</span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">			<span class="comment">// 将剩余的SR[j..n-1]复制到TR</span></span><br><span class="line">			TR[k + l] = SR[j + l];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是一个递归版本的归并排序实现算法，其中函数<code>MSort()</code>的作用是将待排序序列进行分割，然后<code>Merge()</code>函数会对需要归并的序列进行排序并两两归并在一起。</p>
<p><strong>归并排序的时间复杂度是$O(nlogn)$，并且无论是最好、最坏还是平均都是同样的时间性能。</strong>另外，在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，并且递归时需要深度为$log_2 n$的栈空间，因此空间复杂度是$O(n+logn)$。</p>
<p>另外，归并排序是使用两两比较，不存在跳跃，这在<code>Merge()</code>中的语句<code>if(SR[i]&lt;SR[j])</code>可以看出，<strong>所以归并排序是一个稳定的排序算法。</strong></p>
<p><strong>总体来说，归并排序是一个比较占用内存，但效率高且稳定的算法。</strong></p>
<p>下面会介绍一个非递归版本的归并排序算法实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 非递归版本的归并排序</span><br><span class="line">void MergeSort2(SqList *L)&#123;</span><br><span class="line">	// 申请额外空间</span><br><span class="line">	int* TR = (int *)malloc(L-&gt;length * sizeof(int));</span><br><span class="line">	int k = 1;</span><br><span class="line">	while (k &lt; L-&gt;length)&#123;</span><br><span class="line">		MergePass(L-&gt;r, TR, k, L-&gt;length);</span><br><span class="line">		// 子序列长度加倍</span><br><span class="line">		k = 2 * k;</span><br><span class="line">		MergePass(TR, L-&gt;r, k, L-&gt;length);</span><br><span class="line">		k = 2 * k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将SR[]中相邻长度为s的子序列两两归并到TR[]</span><br><span class="line">void MergePass(int SR[], int TR[], int s, int n)&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j;</span><br><span class="line">	while (i &lt;= n - 2 * s)&#123;</span><br><span class="line">		// 两两归并</span><br><span class="line">		Merge(SR, TR, i, i + s - 1, i + 2 * s - 1);</span><br><span class="line">		i = i + 2 * s;</span><br><span class="line">	&#125;</span><br><span class="line">	if (i &lt; n - s + 1)</span><br><span class="line">		// 归并最后两个子序列</span><br><span class="line">		Merge(SR, TR, i, i + s - 1, n - 1);</span><br><span class="line">	else&#123;</span><br><span class="line">		// 若最后剩下单个子序列</span><br><span class="line">		for (j = i; j &lt;= n - 1; j++)</span><br><span class="line">			TR[j] = SR[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]</span><br><span class="line">void Merge(int SR[], int TR[], int i, int m, int n)&#123;</span><br><span class="line">	int j, k, l;</span><br><span class="line">	for (j = m+1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;</span><br><span class="line">		// 将SR中记录由小到大并入TR</span><br><span class="line">		if (SR[i] &lt; SR[j])</span><br><span class="line">			TR[k] = SR[i++];</span><br><span class="line">		else</span><br><span class="line">			TR[k] = SR[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	if (i &lt;= m)&#123;</span><br><span class="line">		for (l = 0; l &lt;= m - i; l++)</span><br><span class="line">			// 将剩余的SR[i..m]复制到TR</span><br><span class="line">			TR[k + l] = SR[i + l];</span><br><span class="line">	&#125;</span><br><span class="line">	if (j &lt;= n)&#123;</span><br><span class="line">		for (l = 0; l &lt;= n - j; l++)</span><br><span class="line">			// 将剩余的SR[j..n-1]复制到TR</span><br><span class="line">			TR[k + l] = SR[j + l];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归版本的归并排序算法避免了递归时深度为$log_2 n$的栈空间，空间复杂度是$O(n)$，并且避免递归也在时间性能上有一定的提升。应该说，使用归并排序时，尽量考虑用非递归方法。</p>
<h4 id="u5FEB_u901F_u6392_u5E8F"><a href="#u5FEB_u901F_u6392_u5E8F" class="headerlink" title="快速排序"></a>快速排序</h4><p>在前面介绍的几种排序算法，希尔排序相当于直接插入排序的升级，它们属于插入排序类，而堆排序相当于简单选择排序的升级，它们是属于选择排序类，而接下来介绍的快速排序就是冒泡排序的升级，它们属于交换排序类。</p>
<blockquote>
<p>快速排序(Quick Sort)的基本思想是：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
</blockquote>
<p>下面给出实现的快速排序算法代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	QSort(L, <span class="number">0</span>, L-&gt;length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">		<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">		pivot = Partition(L, low, high);</span><br><span class="line">		<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">		QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 对高子序列递归排序</span></span><br><span class="line">		QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换待排序序列L中子表的记录，使枢轴记录到位，并返回其所在位置</span></span><br><span class="line"><span class="comment">// 并使得其之前位置的值小于它，后面位置的值大于它</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot_key;</span><br><span class="line">	<span class="comment">// 初始值设置为子表的第一个记录</span></span><br><span class="line">	pivot_key = L-&gt;r[low];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivot_key)</span><br><span class="line">			high--;</span><br><span class="line">		<span class="comment">// 将小于枢轴记录的值交换到低端</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivot_key)</span><br><span class="line">			low++;</span><br><span class="line">		<span class="comment">// 将大于枢轴记录的值交换到高端</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码同样是使用了递归，其中<code>Partition()</code>函数要做的就是先选取待排序序列中的一个关键字，然后将其放在一个位置，这个位置左边的值小于它，右边的值都大于它，这样的值被称为枢轴。</p>
<p>快速排序的时间性能取决于快速排序递归的深度。在最优情况下，<code>Partition()</code>每次都划分得很均匀，如果排序$n$个关键字，其递归树的深度技术$\lfloor log_ n \rfloor +1$，即需要递归$log_2n$次，其时间复杂度是$O(nlogn)$。而最坏的情况下，待排序的序列是正序或逆序，得到的递归树是斜树，最终其时间复杂度是$O(n^2)$。</p>
<p><strong>平均情况可以得到时间复杂度是$O(nlogn)$，而空间复杂度的平均情况是$O(logn)$。但是由于关键字的比较和交换是跳跃进行的，所以快速排序也是不稳定排序。</strong></p>
<h5 id="u5FEB_u901F_u6392_u5E8F_u7684_u4F18_u5316"><a href="#u5FEB_u901F_u6392_u5E8F_u7684_u4F18_u5316" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h5><p>快速排序算法是有许多地方可以优化的，下面给出一些优化的方案。</p>
<h6 id="u4F18_u5316_u9009_u53D6_u67A2_u8F74"><a href="#u4F18_u5316_u9009_u53D6_u67A2_u8F74" class="headerlink" title="优化选取枢轴"></a>优化选取枢轴</h6><p>枢轴的值太大或者太小都会影响快速排序的性能，一个改进方法是<strong>三数取中</strong>法，即<strong>取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数</strong>。</p>
<p>需要在<code>Partition()</code>函数中做出下列修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pivot_key;</span><br><span class="line">	<span class="comment">// 使用三数取中法选取枢轴</span></span><br><span class="line">	<span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[low] &gt; L-&gt;r[high])</span><br><span class="line">		<span class="comment">// 保证左端最小</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m] &gt; L-&gt;r[high])</span><br><span class="line">		<span class="comment">// 保证中间较小</span></span><br><span class="line">		swap(L, high, m);</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m] &gt; L-&gt;r[low])</span><br><span class="line">		<span class="comment">// 保证左端较小</span></span><br><span class="line">		swap(L, m, low);</span><br><span class="line"></span><br><span class="line">	pivot_key = L-&gt;r[low];</span><br></pre></td></tr></table></figure>
<p>三数取中对小数组有很大的概率取到一个比较好的枢轴值，但是对于非常大的待排序的序列还是不足以保证得到一个比较好的枢轴值，因此还有一个办法是<strong>九数取中法</strong>，它先从数组中分三次取样，每次去三个数，三个样品各自取出中数，然后从这三个中数当中再取出一个中数作为枢轴。</p>
<h6 id="u4F18_u5316_u4E0D_u5FC5_u8981_u7684_u4EA4_u6362"><a href="#u4F18_u5316_u4E0D_u5FC5_u8981_u7684_u4EA4_u6362" class="headerlink" title="优化不必要的交换"></a>优化不必要的交换</h6><p>优化后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pivot_key = L-&gt;r[low];</span><br><span class="line"><span class="keyword">int</span> temp = pivot_key;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivot_key)</span><br><span class="line">		high--;</span><br><span class="line">	<span class="comment">// 将小于枢轴记录的值交换到低端</span></span><br><span class="line">	<span class="comment">// swap(L, low, high);</span></span><br><span class="line">	<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">	L-&gt;r[low] = L-&gt;r[high];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivot_key)</span><br><span class="line">		low++;</span><br><span class="line">	<span class="comment">// 将大于枢轴记录的值交换到高端</span></span><br><span class="line">	<span class="comment">// swap(L, low, high);</span></span><br><span class="line">	<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">	L-&gt;r[high] = L-&gt;r[low];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将枢轴值替换回L.r[low]</span></span><br><span class="line">L-&gt;r[low] = temp;</span><br><span class="line"><span class="keyword">return</span> low;</span><br></pre></td></tr></table></figure>
<p>这里可以减少多次交换数据的操作，性能上可以得到一定的提高。</p>
<h6 id="u4F18_u5316_u5C0F_u6570_u7EC4_u65F6_u7684_u6392_u5E8F_u65B9_u6848"><a href="#u4F18_u5316_u5C0F_u6570_u7EC4_u65F6_u7684_u6392_u5E8F_u65B9_u6848" class="headerlink" title="优化小数组时的排序方案"></a>优化小数组时的排序方案</h6><p>当数组比较小的时候，快速排序的性能其实还不如直接插入排序(直接插入排序是简单排序中性能最好的)。其原因是快速排序使用了递归操作，在有大量数据排序时，递归操作的影响是可以忽略的，但如果只有少数记录需要排序，这个影响就比较大，所以下面给出改进的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_LENGTH_INSERT_SORT <span class="number">7</span> </span></span><br><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class="line">		<span class="comment">// 当high - low 大于常数时用快速排序</span></span><br><span class="line">		<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">		pivot = Partition(L, low, high);</span><br><span class="line">		<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">		QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 对高子序列递归排序</span></span><br><span class="line">		QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 否则使用直接插入排序</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是先进行一个判断，当数组的数量大于一个预设定的常数时，才进行快速排序，否则就进行直接插入排序。这样可以保证最大化地利用两种排序的优势来完成排序工作。</p>
<h6 id="u4F18_u5316_u9012_u5F52_u64CD_u4F5C"><a href="#u4F18_u5316_u9012_u5F52_u64CD_u4F5C" class="headerlink" title="优化递归操作"></a>优化递归操作</h6><p>递归对性能是有一定影响的，<code>QSort()</code>在其尾部有两次递归操作，如果待排序的序列划分极端不平衡，递归的深度将趋近于$n$，而不是平衡时的$log_2 n$，这就不仅仅是速度快慢的问题了。栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此，如果能减少递归，将会大大提高性能。</p>
<p>下面给出对<code>QSort()</code>实施尾递归优化的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class="line">		<span class="comment">// 当high - low 大于常数时用快速排序</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">			<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">			pivot = Partition(L, low, high);</span><br><span class="line">			<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">			QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 尾递归</span></span><br><span class="line">			low = pivot + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 否则使用直接插入排序</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中使用<code>while</code>循环，并且去掉原来的对高子序列进行递归，改成代码<code>low = privot + 1</code>，那么在进行一次递归后，再进行循环，就相当于原来的<code>QSort(L,privot+1,high);</code>，结果相同，但是从递归变成了迭代，可以缩减堆栈深度，从而提高了整体性能。</p>
<h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>上述总共介绍了7种排序算法，首先是根据排序过程中借助的主要操作，将内排序分为：插入排序、交换排序、选择排序和归并排序，如下图所示。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png" alt=""></p>
<p>事实上，目前还没有十全十美的排序算法，都是各有优点和缺点，即使是快速排序算法，也只是整体上性能优越，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。</p>
<p>下面对这7种算法的各种指标进行对比，如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%954.png" alt=""></p>
<p>从算法的简单性来看，可以分为两类：</p>
<ul>
<li>简单算法：冒泡、简单选择、直接插入。</li>
<li>改进算法：快速、堆、希尔、归并。</li>
</ul>
<p>从平均情况看，快速、堆、归并三种改进算法都优于希尔排序，并远远胜过3种简单算法。</p>
<p>从最好情况看，冒泡和直接插入排序要更好一点，即当待排序序列是基本有序的时候，应该考虑这两种排序算法，而非4种复杂的改进算法。</p>
<p>从最坏情况看，堆和归并排序比其他排序算法都要更好。</p>
<p>从空间复杂度看，归并排序和快速排序都对空间有要求，而其他排序反而都只是$O(1)$的复杂度。</p>
<p>从稳定性上看，归并排序是改进算法中唯一稳定的算法。而不稳定的排序算法有“快些选堆”，即快速、希尔、选择和堆排序四种算法（书中给出的简单选择排序是不稳定的，但是从网上查找资料看到选择排序是一个不稳定的算法）。</p>
<p>排序算法的总结就到这里，实际上还是要根据实际问题来选择适合的排序算法。</p>
<p>全部排序算法的代码可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/SortAlgorithms" target="_blank" rel="external">排序算法实现代码</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是《大话数据结构》第九章排序算法的知识点总结。</p>
<h4 id="u6392_u5E8F_u7684_u57FA_u672C_u6982_u5FF5_u4E0E_u5206_u7C7B"><a href="#u6392_u5E8F_u7684_u57FA_u672C]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图的基本定义]]></title>
    <link href="http://ccc013.github.io/2016/11/08/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/"/>
    <id>http://ccc013.github.io/2016/11/08/图的基本定义/</id>
    <published>2016-11-08T09:18:08.000Z</published>
    <updated>2016-11-08T09:21:46.527Z</updated>
    <content type="html"><![CDATA[<p>这是《大话数据结构》第七章图的基本知识总结，首先是总结图的基本定义和相关的术语，包括有向图，无向图，连通图等术语的定义。</p>
<blockquote>
<p>图(Graph)是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为：<strong>G（V, E）</strong>，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p>
</blockquote>
<p>对于上述图的定义，需要注意的是：</p>
<ul>
<li>线性表中的数据元素被称为元素，树中将数据元素称为结点，而图中数据元素被称为<strong>顶点</strong></li>
<li>线性表可以没有数据元素，称为空表；树也可以没有结点，称为空树。但是图的定义中强调了顶点集合<strong>V</strong>是有穷非空的集合，所以图结构中不能没有顶点。</li>
<li>线性表中，相邻的数据元素之间具有线性关系；树结构中，相邻两层的结点具有层次关系。而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</strong></li>
</ul>
<h5 id="u5404_u79CD_u56FE_u5B9A_u4E49"><a href="#u5404_u79CD_u56FE_u5B9A_u4E49" class="headerlink" title="各种图定义"></a>各种图定义</h5><p>接下来会介绍各自图的定义，包括无向图与有向图，有向完全图和无向完全图，稀疏与稠密图等。</p>
<blockquote>
<p>无向边： 若顶点$v_i$ 到$v_j$之间的边没有方向，则称这条边为<strong>无向边(Edge)</strong>,用无序偶对$(v_i, v_j)$来表示。</p>
</blockquote>
<p>如果图中任意两个顶点之间的边都是无向边，则称该图是<strong>无向图</strong>。</p>
<p>如下图左边的图就是一个无向图$G_1$，$G_1 = （V_1,{E_1}）$，其中顶点集合 $V_1 = {A,B,C,D}$,边集合是$E_1 = {(A, B), (B, C), (C, D), (D, A), (A, C)}$。</p>
<blockquote>
<p>有向边： 若顶点$v_i$ 到$v_j$之间的边有方向，则称这条边为<strong>有向边，也称为弧(Arc)</strong>。用有序偶$<v_i, v_j="">$来表示，$v_i$称为弧尾，$v_j$称为弧头。</v_i,></p>
</blockquote>
<p>如果图中任意两个顶点之间的边都是有向边，则称该图是<strong>有向图</strong>。</p>
<p>如下图右边的图就是一个有向图 $G_2$，$G_2 =（V_2, {E_2}） $,其中顶点集合 $V_2 = {A,B,C,D}$,边集合是$E_2 = {<a, d="">, <b, a="">, <c, a="">, <b, c="">}$。</b,></c,></b,></a,></p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE1.png" alt=""></p>
<p>这里需要注意有向图中有向边的表示是不能随意乱写的，必须是按照定义中$<v_i, v_j="">$，弧尾在前，弧头在后的写法。</v_i,></p>
<blockquote>
<p>图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图是简单图。</p>
</blockquote>
<p>如下图所示都不是简单图，而我们主要讨论的都是简单图。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE2.png" alt=""></p>
<blockquote>
<p><strong>无向完全图</strong>是指在无向图中，任意两个顶点之间都存在边。</p>
</blockquote>
<p>含有$n$个顶点的无向完全图有$\frac{n\times (n-1)}{2}$条边。</p>
<blockquote>
<p><strong>有向完全图</strong>是指在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。</p>
</blockquote>
<p>含有$n$个顶点的有向完全图有$n\times (n-1)$条边。</p>
<p>由此可以得到一个结论：</p>
<p><strong>对于具有$n$个顶点和$e$条边数的图，无向图有$0 \le e \le \frac{n\times (n-1)}{2}$, 有向图有$0 \le e \le n \times (n-1)$</strong>。</p>
<blockquote>
<p>有很少边或弧的图称为稀疏图，反之称为稠密图。</p>
</blockquote>
<p>这里的稀疏与稠密都是相对而言的。</p>
<blockquote>
<p>与图的边或弧相关的数值称为<strong>权(Weight)</strong>，它可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为<strong>网(Network)</strong>。</p>
</blockquote>
<p>下图就是一个带权的图的例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE3.png" alt=""></p>
<blockquote>
<p>假设有两个图 $G = （V，{E}）$，和 $G^\prime = （V^\prime,  {E^\prime}） $,如果$V^\prime \subseteq V$, 且 $E^\prime \subseteq E$,则称$G^\prime$是$G$的子图。</p>
</blockquote>
<p>下面展示了无向图和有向图与其子图。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE4.png" alt=""></p>
<h5 id="u56FE_u7684_u9876_u70B9_u4E0E_u8FB9_u7684_u5173_u7CFB"><a href="#u56FE_u7684_u9876_u70B9_u4E0E_u8FB9_u7684_u5173_u7CFB" class="headerlink" title="图的顶点与边的关系"></a>图的顶点与边的关系</h5><blockquote>
<p>在无向图 $G=(V,{E})$，如果边 $(v, v^\prime) \in E$,则称顶点$v和v^\prime$互为<strong>邻接点(Adjacent)</strong>,即$v 和 v^\prime$相邻接。边$(v, v^\prime)$依附(incident)于顶点$v 和 v^\prime$，或者说$(v,v^\prime)$与顶点$v 和 v^\prime$相关联。<strong>顶点$v$的度(Degree)是和$v$相关联的边的数目，记为TD($v$)。</strong></p>
</blockquote>
<p>例如对于上图中上方的无向图，顶点A与B互为邻接点，边(A, B)依附于顶点A与B上，顶点A的度为3。通过计算，可以知道，<strong>无向图的边数是各顶点度数和的一半，即$e = \frac{1}{2} \sum_{i=1}^n TD(v_i)$。</strong></p>
<blockquote>
<p>有向图 $G=(V,{E})$,如果弧$<v,v^\prime> \in E$, 则称顶点$v$邻接到顶点$v^\prime$，顶点$v^\prime$邻接自顶点$v$。弧$<v,v^\prime>$和顶点$v,v^\prime$相关联。<strong>以顶点$v$为头的弧的数目称为$v$的入度(InDegree),记为$ID(v)$；以顶点$v$为尾的弧的数目称为$v$的出度(OutDegree),记为$OD(v)$,因此顶点$v$的度为$TD(v) = ID(v) + OD(v)$。</strong> </v,v^\prime></v,v^\prime></p>
</blockquote>
<p>例如对上图中下方的有向图，顶点A的入度是2（从B到A的弧，C到A的弧），出度是1（从A到D的弧），所以顶点A的度是3。同样通过计算，可以得到$e =\sum_{i=1}^n ID(v<em>i) = \sum</em>{i=1}^n OD(v_i) $。</p>
<blockquote>
<p>在无向图 $G=(V,{E})$中从顶点$v$到$v^\prime$的<strong>路径(Path)</strong>是一个顶点序列$(v=v<em>{i,0},v</em>{i,1},\cdots,v<em>{i,m}=v^\prime),其中(v</em>{i,j-1},v_{i,j}) \in E, 1 \le j \le m$。</p>
</blockquote>
<p>下图就展示了顶点B到顶点D的四种不同路径。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE5.png" alt=""></p>
<p>如果$G$是有向图，则路径也是有向的，顶点序列应满足$<v_{i,j-1}, v_{i,j}=""> \in E, 1 \le j \le m$。如下图所示，顶点B到D右两种路径，而顶点A到B就不存在路径。</v_{i,j-1},></p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE6.png" alt=""></p>
<blockquote>
<p><strong>路径的长度是路径上的边或弧的数目。</strong></p>
</blockquote>
<p>如上图有向图中，左侧的路径长度是2，经过两条弧，而右侧的路径长度是3，经过3条弧。</p>
<blockquote>
<p>第一个顶点到最后一个顶点相同的路径称为<strong>回路或环(Cycle)</strong>。序列中顶点不重复出现的路径称为<strong>简单路径</strong>。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为<strong>简单回路或简单环</strong>。</p>
</blockquote>
<p>下图中，两个图都是一个环，但左侧的图是一个简单环，而右侧图中顶点C重复出现，因此它不是一个简单环。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE7.png" alt=""></p>
<h5 id="u8FDE_u901A_u56FE_u76F8_u5173_u672F_u8BED"><a href="#u8FDE_u901A_u56FE_u76F8_u5173_u672F_u8BED" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h5><p>接下来会介绍有关连通图的定义和相关术语。</p>
<blockquote>
<p>无向图$G$中，如果从顶点$v$到$v^\prime$有路径，则称$v$和$v^\prime$是<strong>连通的。</strong>如果对于图中<strong>任意两个顶点$v_i、v_j \in V$，$v_i$和$v_j$都是连通的，则称$G$是连通图。</strong></p>
</blockquote>
<p><strong>无向图中的极大连通子图称为连通分量</strong>。这个连通分量的前提条件有：</p>
<ul>
<li>是子图；</li>
<li>子图是要连通的；</li>
<li>连通子图要有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<blockquote>
<p>有向图$G$中，如果对于每一对$v_i,v_j \in V, v_i \neq v_j$,从$v_i$到$v_j$和从$v_j$到$v_i$都存在路径，则称$G$是<strong>强连通图</strong>。有向图中的<strong>极大强连通子图</strong>称做有向图的<strong>强连通分量</strong>。</p>
</blockquote>
<p>如下图所示，图1并不是强连通图，因为顶点A到顶点D存在路径，但不存在从顶点D到顶点A的路径。图2就是强连通图，而且显然图2是图1的极大强连通子图，即是它的强连通分量。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE8.png" alt=""></p>
<p>接下来是连通图的生成树定义：</p>
<blockquote>
<p>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的 n-1 条边。</p>
</blockquote>
<p>如下图所示，图1是一个普通图，但是显然它不是生成树，当去掉两条构成环的边后，如图2或图3，就满足生成树的条件了，即n个顶点和n-1条边且连通的定义，它们都是一棵生成树。由此可以得知，<strong>如果一个图有n个顶点和小于n-1条边，则是非连通图；如果它多于n-1条边，则必定构成一个环。</strong>但有n-1条边也不一定是生成树，如图4。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE9.png" alt=""></p>
<p>接下来是有向树的定义：</p>
<blockquote>
<p>如果一个有向图中<strong>恰有一个顶点的入度为0，其余顶点的入度均为1</strong>，则是一棵有向树。</p>
</blockquote>
<p>这里入度为0的顶点就相当于树的根结点，而其余顶点的入度都是1，是因为树的非根结点的双亲只有1个。</p>
<blockquote>
<p>一个有向图的生成森林由<strong>若干棵有向树组成，含有图中全部顶点</strong>，但<strong>只有足以构成若干棵不相交的有向树的弧。</strong></p>
</blockquote>
<p>如下图所示，图1是一个有向图，再去掉一些弧后，得到图2和图3，也就是分解成两棵有向树，即图2和图3，而这两棵有向树也是图1有向图的生成森林。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE10.png" alt=""></p>
<h5 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h5><p>图的基本定义就简单总结到这里，图的术语还是不比树的少，需要多看几遍，同时多使用，接下来会继续总结图的存储结构、遍历等知识点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是《大话数据结构》第七章图的基本知识总结，首先是总结图的基本定义和相关的术语，包括有向图，无向图，连通图等术语的定义。</p>
<blockquote>
<p>图(Graph)是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为：<strong>G（V, E）</str]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树2]]></title>
    <link href="http://ccc013.github.io/2016/10/28/%E4%BA%8C%E5%8F%89%E6%A0%912/"/>
    <id>http://ccc013.github.io/2016/10/28/二叉树2/</id>
    <published>2016-10-28T09:28:47.000Z</published>
    <updated>2016-10-28T09:31:15.149Z</updated>
    <content type="html"><![CDATA[<p>这是《大话数据结构》第六章树的内容，这里总结线索二叉树，二叉树、树和森林的转换以及赫夫曼树的知识点，其中赫夫曼树的总结是在做<a href="http://www.nowcoder.com/918856" target="_blank" rel="external">牛客网</a>上的数据结构选择题的时候，遇到有关这个知识点的时候总结的内容，主要是通过百度得到的，也有结合书本的内容。</p>
<h4 id="u7EBF_u7D22_u4E8C_u53C9_u6811"><a href="#u7EBF_u7D22_u4E8C_u53C9_u6811" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h5 id="u7EBF_u7D22_u4E8C_u53C9_u6811_u539F_u7406"><a href="#u7EBF_u7D22_u4E8C_u53C9_u6811_u539F_u7406" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h5><p>首先如下图所示的二叉树，其中<code>^</code>符号表示空指针域，对于一个有<code>n</code>个结点的二叉链表，每个结点都有指向左右孩子的两个指针域，所以一共有<code>2n</code>个指针域。而<code>n</code>个结点的二叉树是有<code>n-1</code>条分支线数，也就是存在$2n-(n-1)=n+1$个空指针域，这些空间是不存储任何东西，也就是浪费内存的资源。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt=""></p>
<p>另一方面，在对上图的二叉树做中序遍历时，可以得到<code>HDIBJEAFCG</code>这样的字符序列，通过这样的遍历，可以知道，结点<code>I</code>的前驱是<code>D</code>，后继是<code>B</code>。即我们可以知道任意一个结点的前驱和后继分别是哪个，但这是在经过遍历之后的结果，即每次使用都需要先遍历一次，才可以知道任意结点的前驱和后继。</p>
<p>综合上述两种情况，为了更好利用内存资源，节省时间，就有了<strong>线索二叉树</strong>了，我们将<strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就是线索二叉树了</strong>。</p>
<p><strong>线索化是对二叉树以某种次序遍历使其变为线索二叉树的过程。</strong></p>
<p>我们对上图的二叉树按照中序遍历的方式进行线索化，可以得到下图，其中虚线箭头是表示后继，实线箭头是前驱。这里设置二叉树的<strong>左指针是指向前驱，右指针指向后继。</strong></p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt=""></p>
<p>但是增加了线索后，需要解决的问题就是如何判断当前结点的左指针是指向其左孩子，还是前驱呢。这里就需要在每个结点增加两个标志域<code>ltag</code>和<code>rtag</code>，用来表示左右指针指向的是左右孩子还是前驱或者后继。</p>
<h5 id="u7EBF_u7D22_u4E8C_u53C9_u6811_u7ED3_u6784_u5B9E_u73B0"><a href="#u7EBF_u7D22_u4E8C_u53C9_u6811_u7ED3_u6784_u5B9E_u73B0" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h5><p>二叉树的线索存储结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Link == 0 表示指向左右孩子指针； Thread == 1 表示指向前驱或者后继的线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Link, Thread&#125; PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树线索存储结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BiThrNode</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 结点数据  </span></span><br><span class="line">	TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> BiThrNode *lchild, *rchild;</span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    PointerTag RTag;</span><br><span class="line">&#125;  BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<p><strong>线索化的实质就是将二叉链表中的空指针改为指向前驱或者后继的线索</strong>，因此线索化的过程就是在遍历的过程中修改空指针的过程。</p>
<p>下面是中序遍历线索化的递归函数代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line">BiThrTree pre;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p)&#123;</span><br><span class="line">    InThreading(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)&#123;</span><br><span class="line">      <span class="comment">// 没有左孩子</span></span><br><span class="line">      p-&gt;LTag = Thread;</span><br><span class="line">      p-&gt;lchild = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;rchild)&#123;</span><br><span class="line">      <span class="comment">// 没有右孩子</span></span><br><span class="line">      p-&gt;RTag = Thread;</span><br><span class="line">      <span class="comment">// 指向后继，也就是当前结点p</span></span><br><span class="line">      p-&gt;rchild = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保持 pre 指向p的前驱</span></span><br><span class="line">    pre = p;</span><br><span class="line">    InThreading(p-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码可以得到线索二叉树，而对它进行遍历会发现相当于是操作一个双向链表一样。同样是在二叉线索链表上添加一个头结点，如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%913.png" alt=""></p>
<p>这里令二叉树的中序序列中的第一个结点<code>H</code>的左指针和最后一个结点<code>G</code>的右指针指向头结点，令头结点的左指针指向根结点，右指针指向结点<code>G</code>。这样做的好处是我们既可以从第一个结点开始顺其后继进行遍历，也可以从最后一个结点开始顺前驱进行遍历。</p>
<p>遍历的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span>&#123;</span><br><span class="line">  BiThrTree p;</span><br><span class="line">  <span class="comment">// p 指向根结点</span></span><br><span class="line">  p = T-&gt;lchild;</span><br><span class="line">  <span class="keyword">while</span>(p != T)&#123;</span><br><span class="line">    <span class="comment">// 空树或者遍历结束时，p == T</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;LTag == Link)</span><br><span class="line">      <span class="comment">// 循环到中序遍历序列的第一个结点</span></span><br><span class="line">      p = p-&gt;lchild;</span><br><span class="line">    <span class="comment">// 显示结点数据，也可以实现其他操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)&#123;</span><br><span class="line">      <span class="comment">// 根据线索，寻找后继结点，并输出数值或者进行其他操作</span></span><br><span class="line">      p = p-&gt;rchild;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p 指向当前结点的右孩子，暂时结束了根据线索来寻找后继结点</span></span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线索二叉链表的存储结构适用于<strong>如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继。</strong></p>
<h4 id="u6811_u3001_u68EE_u6797_u4E0E_u4E8C_u53C9_u6811_u7684_u8F6C_u6362"><a href="#u6811_u3001_u68EE_u6797_u4E0E_u4E8C_u53C9_u6811_u7684_u8F6C_u6362" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h4><h5 id="u6811_u8F6C_u6362_u4E3A_u4E8C_u53C9_u6811"><a href="#u6811_u8F6C_u6362_u4E3A_u4E8C_u53C9_u6811" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h5><p>树转换为二叉树的步骤如下：</p>
<ol>
<li><strong>加线</strong>。在所有兄弟结点之间加一条连线。</li>
<li><strong>去线</strong>。对树中每个结点，只保留<strong>它与第一个孩子结点的连线</strong>，删除它与其他孩子结点之间的连线。</li>
<li><strong>层次调整</strong>。以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。<strong>注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</strong></li>
</ol>
<p>上述步骤可以如下图所示一样：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%914.png" alt=""></p>
<h5 id="u68EE_u6797_u8F6C_u6362_u4E3A_u4E8C_u53C9_u6811"><a href="#u68EE_u6797_u8F6C_u6362_u4E3A_u4E8C_u53C9_u6811" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h5><p>步骤如下：</p>
<ol>
<li>将每棵树先转为二叉树；</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，<strong>依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</strong>当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<p>下图就是一个森林转为二叉树的例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%915.png" alt=""></p>
<h5 id="u4E8C_u53C9_u6811_u8F6C_u6362_u4E3A_u6811"><a href="#u4E8C_u53C9_u6811_u8F6C_u6362_u4E3A_u6811" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h5><p>二叉树转为树是树转为二叉树的逆过程，具体步骤如下：</p>
<ol>
<li>加线。若某结点的左孩子存在，则将其左孩子的所有右孩子结点都与当前结点连接起来。</li>
<li>去线。删除原来二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明。</li>
</ol>
<p>下图是一个例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%916.png" alt=""></p>
<h5 id="u4E8C_u53C9_u6811_u8F6C_u4E3A_u68EE_u6797"><a href="#u4E8C_u53C9_u6811_u8F6C_u4E3A_u68EE_u6797" class="headerlink" title="二叉树转为森林"></a>二叉树转为森林</h5><p>判断一棵二叉树能够转为森林还是一棵树的方法很简单，就是<strong>看其根结点是否有右孩子，如果有就是森林，没有就是一棵树。</strong></p>
<p>转换为森林的步骤如下：</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除，如此重复，直到所有右孩子连线都删除为止，得到分离后的二叉树。</li>
<li>将所有二叉树转为树即可。</li>
</ol>
<p>下图是一个例子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%917.png" alt=""></p>
<h5 id="u6811_u4E0E_u68EE_u6797_u7684_u904D_u5386"><a href="#u6811_u4E0E_u68EE_u6797_u7684_u904D_u5386" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h5><p>最后是介绍树和森林的遍历问题。</p>
<h6 id="u6811_u7684_u904D_u5386"><a href="#u6811_u7684_u904D_u5386" class="headerlink" title="树的遍历"></a>树的遍历</h6><p>树的遍历分为两种方式：</p>
<ol>
<li>先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>
</ol>
<p>如对下图的树，它的先根遍历序列是<code>ABEFCDG</code>，后根遍历序列是<code>EFBCGDA</code>。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%918.png" alt=""></p>
<h6 id="u68EE_u6797_u7684_u904D_u5386"><a href="#u68EE_u6797_u7684_u904D_u5386" class="headerlink" title="森林的遍历"></a>森林的遍历</h6><p>森林的遍历也是分两种：</p>
<ol>
<li><strong>前序遍历：</strong>先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如对于上述二叉树转为森林的例子中最后得到的三棵树的森林，前序遍历的序列是<code>ABCDEFGHJI</code>。</li>
<li><strong>后序遍历：</strong>是先访问森林中的第一棵树，然后用后根遍历的方法遍历每一棵子树，然后再访问根结点，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。同样还是刚才的例子，后根遍历的序列是<code>BCDAFEJHIG</code>。</li>
</ol>
<p>对照上述例子中的二叉树的前序和中序遍历结果可以发现，<strong>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</strong>同时，<strong>当以二叉链表作树的存储结构时</strong>，<strong>树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。</strong></p>
<h4 id="u8D6B_u592B_u66FC_u6811"><a href="#u8D6B_u592B_u66FC_u6811" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><blockquote>
<p>定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，<strong>称这样的二叉树为最优二叉树，也称为赫夫曼树(Huffman Tree)。</strong>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
</blockquote>
<p>假设有$n$个权值，则构造出的赫夫曼树有$n$个叶子结点。 n个权值分别设为 $w_1,w_2,\ldots,w_n$，则赫夫曼树的构造规则为：</p>
<ol>
<li>将$w_1,w_2,\ldots,w_n$看成是有$n$ 棵树的森林(每棵树仅有一个结点)；</li>
<li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li>
<li>从森林中删除选取的两棵树，并将新树加入森林；</li>
<li>重复2、3步，直到森林中只剩一棵树为止，该树即为所求得的赫夫曼树。</li>
</ol>
<p>赫夫曼树的性质有：</p>
<ul>
<li>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从<strong>根结点到第L层结点的路径长度为L-1</strong>。</li>
<li>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</strong></li>
<li>树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为WPL</li>
<li><em>赫夫曼树的形状是不唯一的，但是它的带权路径长度WPL是唯一的。*</em></li>
</ul>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>这部分内容是之前看《数据结构算法与应用：C++语言描述》时没有记录到的知识点，但是在做有关树的练习题的时候却有涉及到，比如线索二叉树和赫夫曼树，特别是后者，一般会考察如何构造赫夫曼树以及求其带权路径长度。刚好在《大话数据结构》中看到，就做下笔记，总结下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是《大话数据结构》第六章树的内容，这里总结线索二叉树，二叉树、树和森林的转换以及赫夫曼树的知识点，其中赫夫曼树的总结是在做<a href="http://www.nowcoder.com/918856" target="_blank" rel="external">牛客网]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搜索树1-二叉搜索树]]></title>
    <link href="http://ccc013.github.io/2016/08/31/%E6%90%9C%E7%B4%A2%E6%A0%911-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://ccc013.github.io/2016/08/31/搜索树1-二叉搜索树/</id>
    <published>2016-08-31T00:46:46.000Z</published>
    <updated>2016-10-25T11:50:21.630Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第11章搜索树的内容。</p>
<p>本节首先介绍的是二叉搜索树的内容。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><p>  在<a href="http://ccc013.github.io/2016/07/27/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%971-%E5%AD%97%E5%85%B8-%E8%B7%B3%E8%A1%A8/">跳表&amp;散列1-字典&amp;跳表</a>介绍了抽象数据类型<strong>Dictionary</strong>，从中可以发现当用<a href="http://ccc013.github.io/2016/08/07/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%972-%E6%95%A3%E5%88%97/">散列</a>来描述一个字典时，字典操作（包括插入、删除和搜索）所需要的平均时间是$\theta(1)$。而这些操作最坏情况下的时间正比于字典中的元素个数$n$。如果扩充字典的抽象数据类型描述，增加以下操作，那么散列将不能再提供比较好的评价性能：<br>  1) 按关键值的升序输出字典元素；<br>  2）按升序找到第k个元素；<br>  3）删除第k个元素。</p>
<p>  为了执行操作1），需要从表中取出数据，将它们排序后输出。如果使用除数是D的链表，那么能在$\theta(D+n)$的时间内取出元素，在$O(nlogn)$时间内完成排序和$\theta(n)$时间内输出，因此共需时间$O(D+nlogn)$。如果对散列使用线性开型寻址，则取出元素所需时间是$\theta(b)$,b是桶的个数，这时需要时间是$O(b+nlogn)$。<br>  如果使用链表，操作2）和3）可以在$O(D+n)$的时间内完成，如果使用线性开型寻址，它们可以在$\theta(b)$时间内完成。</p>
<p>  如果使用平衡搜索树，那么对字典的基本操作（搜索、插入和删除）能够在$O(logn)$的时间内完成，操作1）能在$\theta(n)$的时间内完成。通过使用带索引的平衡搜索树，也能够在$O(logn)$的时间内完成操作2）和3）。</p>
<p>  在学习平衡树之前，首先来看一种叫做二叉搜索树的简单结构。</p>
<blockquote>
<p>定义 [二叉搜索树] 二叉搜索树(binary search tree)是一棵可能为空的二叉树，一棵非空的二叉搜索树满足以下特征：<br>1）每个元素有一个关键值，并且没有任意两个元素有相同的关键值；因此，所有的关键值都是唯一的。<br>2）根节点左子树的关键值（如果有的话）小于根节点的关键值。<br>3）根节点右子树的关键值（如果有的话）大于根节点的关键值。<br>4）根节点的左右子树也都是儿茶搜索树。</p>
</blockquote>
<p>下图11-1给出3个含有不同关键值的二叉树，其中11-1a的二叉树满足了上述特征1-3，但是不满足特征4，而11-b和11-c的二叉树则是二叉搜索树。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>在放弃二叉搜索树中所有元素必须拥有不同关键值的要求，然后用小于等于代替特征2）中的小于，用大于等于代替特征3）中的大于，这样就可以得到一棵<strong>有重复值的二叉搜索树</strong>。</p>
<p><strong>带索引的二叉搜索树源于普通的二叉搜索树，它只是在每个节点中添加一个LeftSize域，这个域的值是该节点左子树的元素个数加1。</strong>下图11-2是两棵带索引的二叉搜索树。注意，LeftSize同时给出了一个元素在子树中的排名。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h3 id="u7C7BBSTree"><a href="#u7C7BBSTree" class="headerlink" title="类BSTree"></a>类BSTree</h3><p>  可以从<a href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/">二叉树的基本概念和实现</a>中介绍的类<strong>BinaryTree</strong>中派生类<strong>BSTree</strong>,这样可以大大简化类BSTree的设计，实现如下程序所示。另外，为了访问<strong>BinaryTree</strong>类的私有成员<strong>root</strong>，需要将类<strong>BSTree</strong>定义为<strong>BinaryTree</strong>的友元。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> BSTree : <span class="keyword">public</span> BinaryTree&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp;k, E&amp; e)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    BSTree&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp; e);</span><br><span class="line">    BSTree&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp;k, E&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ascend</span><span class="params">()</span></span>&#123; InOutput(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索元素的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> BSTree&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp;k, E &amp;e) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k匹配的元素</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data)</span><br><span class="line">            p = p-&gt;LeftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k&gt;p-&gt;data)</span><br><span class="line">            p = p-&gt;RightChild;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找到元素</span></span><br><span class="line">            e = p-&gt;data;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若在二叉搜索树中插入一个新元素e，首先要验证e的关键值与树中已有元素的关键值是否相同，这可以通过用e的关键值对二叉树进行搜索来实现。如果搜索不成功，那么新元素将被插入到搜索的中端点，下面给出插入函数的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">BSTree&lt;E, K&gt;&amp; BSTree&lt;E, K&gt;::Insert(<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 如果不出现重复，则插入e</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *p = root, *pp = <span class="number">0</span>;   <span class="comment">// p是搜索节点，pp是p的父节点</span></span><br><span class="line">    <span class="comment">// 寻找插入点</span></span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; p-&gt;data)</span><br><span class="line">            p = p-&gt;LeftChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e&gt;p-&gt;data)</span><br><span class="line">            p = p-&gt;RightChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 出现重复</span></span><br><span class="line">            <span class="keyword">throw</span> BadInput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *r = <span class="keyword">new</span> BinaryTreeNode&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">if</span> (root)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; pp-&gt;data)</span><br><span class="line">            pp-&gt;LeftChild = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp-&gt;RightChild = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于删除操作，对包含被删除元素的节点p有三种情况：1）p是叶节点；2）p只有一个非空子树；3）p有两个非空子树。</p>
<p>对于第一种情况可以采用直接丢弃叶节点的方法来处理。</p>
<p>对于第二种情形，如果p没有父节点，即p是根节点，则将p丢弃，p的唯一孩子成为新的搜索树的根节点；如果p有父节点pp，则修改pp的指针，使其指向p的唯一孩子，然后删除节点p。</p>
<p>最后，对于第三种情形，<strong>只需要将元素替换成它的左子树中的最大元素或者右子树中的最小元素。</strong>注意，必须确保右子树中的最小元素以及左子树中的最大元素即不会在没有子树的节点中，也不会在只有一个子树的节点中。可以按下述方法来查找到左子树中的最大元素：<strong>首先移动到子树的根，然后沿着各节点的右孩子指针移动，直到右孩子指针为0为止。</strong>类似地，也可以找到右子树的最小元素：<strong>首先移动到子树的根，然后沿着各节点的左孩子指针移动，直到左孩子指针为0为止。</strong></p>
<p>下面程序给出删除操作实现，它一般使用左子树的最大元素来进行替换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line">BSTree&lt;E, K&gt;&amp; BSTree&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 删除关键值是k的元素，并将其放入e</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将p指向关键值是k的节点</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *p = root, *pp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != k)&#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; p-&gt;data)</span><br><span class="line">            p = p-&gt;LeftChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;RightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">throw</span> BadInput();</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="comment">// 对树进行重构，处理p有两个孩子的情形</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;LeftChild &amp;&amp; p-&gt;RightChild)&#123;</span><br><span class="line">        <span class="comment">// 转换成有0或1个孩子的情形，在p的左子树中寻找最大元素</span></span><br><span class="line">        BinaryTreeNode&lt;E&gt; *s = p-&gt;LeftChild, *ps = p;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;RightChild)&#123;</span><br><span class="line">            ps = s;</span><br><span class="line">            s = s-&gt;RightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最大元素从s移动到p</span></span><br><span class="line">        p-&gt;data = s-&gt;data;</span><br><span class="line">        p = s;</span><br><span class="line">        pp = ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于p最多有一个孩子</span></span><br><span class="line">    BinaryTreeNode&lt;E&gt; *c;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;LeftChild)</span><br><span class="line">        c = p-&gt;LeftChild;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = p-&gt;RightChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除p</span></span><br><span class="line">    <span class="keyword">if</span> (p == root)</span><br><span class="line">        root = c;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == pp-&gt;LeftChild)</span><br><span class="line">            pp-&gt;LeftChild = c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp-&gt;RightChild = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u7C7BDBSTree"><a href="#u7C7BDBSTree" class="headerlink" title="类DBSTree"></a>类DBSTree</h3><p>  若二叉搜索树中的不同元素可以包含相同的关键值，则称这种树是<strong>DBSTree</strong>。在实现该类的时候，只需要把<strong>BSTree::Insert</strong>的while循环改成如下所示即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p)&#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; p-&gt;data)</span><br><span class="line">        p = p-&gt;LeftChild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e&gt;p-&gt;data)</span><br><span class="line">        p = p-&gt;RightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更完整的例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SearchTrees/BSTree.h" target="_blank" rel="external">二叉搜索树的实现</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节内容就简单介绍了二叉搜索树的代码实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第11章搜索树的内容。</p>
<p>本节首先介绍的是二叉搜索树的内容。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" ]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优先队列2-左高树]]></title>
    <link href="http://ccc013.github.io/2016/08/24/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%972-%E5%B7%A6%E9%AB%98%E6%A0%91/"/>
    <id>http://ccc013.github.io/2016/08/24/优先队列2-左高树/</id>
    <published>2016-08-24T10:50:30.000Z</published>
    <updated>2016-10-23T07:20:35.491Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本节将介绍另一种实现优先队列的数据结构–左高树</p>
<h3 id="u9AD8_u5EA6_u4E0E_u5BBD_u5EA6_u4F18_u5148_u7684_u6700_u5927_u53CA_u6700_u5C0F_u5DE6_u9AD8_u6811"><a href="#u9AD8_u5EA6_u4E0E_u5BBD_u5EA6_u4F18_u5148_u7684_u6700_u5927_u53CA_u6700_u5C0F_u5DE6_u9AD8_u6811" class="headerlink" title="高度与宽度优先的最大及最小左高树"></a>高度与宽度优先的最大及最小左高树</h3><p>  上一节讲述的堆结构是一种<strong>隐式数据结构</strong>，用完全二叉树表示的堆在数组中时隐式存储的（即没有明确的指针或其他数据能够重构这种结构）。由于没有存储结构信息，这种描述方法空间利用率很高，事实上是没有空间浪费，尽管堆结构的时间和空间效率都很高，但它不适合所有优先队列的应用，尤其是当需要合并两个优先队列或多个长度不同的队列时，需要借助其他数据结构来实现这类应用，比如<strong>左高树(leftist tree)</strong>。</p>
<p>  考察一棵二叉树，如下图9-6a所示，它有一类特殊的节点叫做<strong>外部节点，用来代替树中的空子树，其余节点叫做内部节点。</strong>增加了外部节点的二叉树被称为扩充二叉树，如下图9-6b所示，外部节点用阴影框表示，并且为了方便起见，这些节点用a~f标注。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%B7%A6%E9%AB%98%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  令$s(x)$是从节点$x$到它的子树的外部节点的所有路径横纵最短的一条，根据其定义可知，如果$x$是外部节点，则$s$=0，若$x$是内部节点，则其$s$值为$min{s(L),s(R)}+1$，其中$L,R$分别是$x$的左右子树。所以上述扩充二叉树各节点的s值如上图9-c所示。</p>
<blockquote>
<p>定义 [高度优先左高树] 当且仅当一棵二叉树的任何一个内部节点，<strong>其左孩子的$s$值大于等于右孩子的$s$值时</strong>，该二叉树是高度优先左高树(height-biased leftist tree,HBLT)。</p>
<p>定义 [最大(小)HBLT] 即同时是最大(小)树的HBLT; </p>
</blockquote>
<p>图9-6a所示的二叉树并不是HBLT，因为外部节点a的父节点，其左孩子$s$=0，右孩子$s$=1，不满足条件，如果将这两个子树进行交换就可以满足HBLT的条件。</p>
<blockquote>
<p>定理9-1 若x是一个HBLT的内部节点，则<br>1) 以$x$为根的子树的节点数目至少是$2^{s(x)}-1$.<br>2) 若子树$x$有$m$个节点，$s(x)$最多为$log_2(m+1)$<br>3) 通过最右路径（即路径是从$x$开始沿右孩子移动）从$x$到达外部节点的路径长度是$s(x)$。</p>
</blockquote>
<p><strong>可以通过考察子树的节点数目来得到另一类左高树。</strong>定义$x$的重量$w(x)$是以$x$为根的子树的内部节点数目。如果$x$是外部节点，则其重量为0；若$x$是内部节点，则其重量是其孩子节点的重量之和加1，如上图9-6d展示了二叉树各节点的重量。</p>
<blockquote>
<p>定义 [重量优先左高树] 当且仅当一棵二叉树的任何一个内部节点，其左孩子的$w$值大于等于右孩子的$w$时，该二叉树为重量优先左高树(weight-biased leftist tree,WBLT);</p>
</blockquote>
<p>[最大(小)WBLT]即同时又是最大(小)树的WBLT。</p>
<p>同HBLT类似，具有$m$个节点的WBLT的最右路径长度最多为$log_2(m+1)$。可以对WBLT和HBLT执行优先队列的查找、插入和删除操作，其时间复杂性与堆的相应操作相同。并且跟堆一样，WBLT和HBLT可以在线性时间内完成初始化。用WBLT或HBLT描述的两个优先队列可在对数时间内合并为一个，而堆描述的优先队列无法做到。</p>
<p>接下来将介绍HBLT的操作，而WBLT的查找、插入、删除、合并和初始化操作与HBLT非常相似。</p>
<h3 id="u6700_u5927HBLT_u7684_u63D2_u5165"><a href="#u6700_u5927HBLT_u7684_u63D2_u5165" class="headerlink" title="最大HBLT的插入"></a>最大HBLT的插入</h3><p>  <strong>插入操作可借助于合并操作来完成。</strong>它可以通过先建立一棵仅包含待插入元素的HBLT，然后与原来的HBLT合并即可。</p>
<h3 id="u6700_u5927HBLT_u7684_u5220_u9664"><a href="#u6700_u5927HBLT_u7684_u5220_u9664" class="headerlink" title="最大HBLT的删除"></a>最大HBLT的删除</h3><p>  根是最大元素，如果跟被删除，将留下分别以其左右孩子为根的两棵HBLT的子树，将其合并到一起，便得到包含除删除元素外所有元素的最大HBLT。</p>
<h3 id="u5408_u5E76_u4E24_u68F5_u6700_u5927HBLT"><a href="#u5408_u5E76_u4E24_u68F5_u6700_u5927HBLT" class="headerlink" title="合并两棵最大HBLT"></a>合并两棵最大HBLT</h3><p>  具有$n$个元素的最大HBLT，其最右路径的长度为$O(logn)$。合并操作操作仅需遍历欲合并的HBLT的最右路径，即仅需移动右孩子。</p>
<p> 合并策略最好用递归来实现。令$A,B$是需要合并的两棵最大HBLT，假设两者均不为空，为实现合并，首先需要检查两个根元素，较大者是合并后HBLT的根。假设$A$具有较大的根，且其左子树是$L$,$C$是由$A$的右子树与$B$合并而成的HBLT。所以$A,B$合并的结果是以$A$的根为根，$L,C$为左右子树的最大HBLT。如果$L$的$s$值小于$C$的$s$值，则$C$是右子树，$L$是左子树。</p>
<h3 id="u521D_u59CB_u5316_u6700_u5927HBLT"><a href="#u521D_u59CB_u5316_u6700_u5927HBLT" class="headerlink" title="初始化最大HBLT"></a>初始化最大HBLT</h3><p>  通过将$n$个元素插入到最初为空的最大HBLT中来进行初始化，所需时间是$O(logn)$。为得到具有线性时间的初始化算法，首先创建$n$个最大HBLT，每个树中仅包含$n$个元素中的某一个，这$n$棵树排成一个FIFO队列，然后从队列中依次删除两个HBLT，将其合并，然后再加入队列末尾，直到最后只有一棵HBLT。</p>
<h3 id="u7C7BMaxHBLT"><a href="#u7C7BMaxHBLT" class="headerlink" title="类MaxHBLT"></a>类MaxHBLT</h3><p>  最大HBLT的每个节点均需要$data,LeftChild,RightChild和s$四个域，相应的节点类是$HBLTNode$,如下代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> MaxHBLT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> HBLTNode&#123;</span><br><span class="line">    <span class="keyword">friend</span> MaxHBLT&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    T data;</span><br><span class="line">    HBLTNode&lt;T&gt;* LeftChild, *RightChild;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HBLTNode(<span class="keyword">const</span> T&amp;e, <span class="keyword">const</span> <span class="keyword">int</span> sh)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        s = sh;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而最大HBLT可用下面代码定义的类MaxHBLT来实现。类MaxHBLT的每个对象都有一个唯一的私有成员$root$，用来指向最大HBLT的根。构造函数在初始化时将其置为0，因此初始的最大HBLT是空。析构函数通过调用私有成员函数$Free$来删除HBLT中的所有节点，该函数按后序遍历整棵HBLT，每访问一个节点就删除该节点。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class MaxHBLT&#123;</span><br><span class="line">private:</span><br><span class="line">    HBLTNode&lt;T&gt; *root;</span><br><span class="line">    void PostOrder(void(*Visit)(HBLTNode&lt;T&gt;*u), HBLTNode&lt;T&gt;* t)&#123;</span><br><span class="line">        // 后序遍历</span><br><span class="line">        if (t)&#123;</span><br><span class="line">            PostOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">            PostOrder(Visit, t-&gt;RightChild);</span><br><span class="line">            Visit(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void free(HBLTNode&lt;T&gt;* t)&#123;</span><br><span class="line">        delete t;</span><br><span class="line">    &#125;</span><br><span class="line">    void Free(HBLTNode&lt;T&gt; *t)&#123;</span><br><span class="line">        PostOrder(free, t);</span><br><span class="line">        t = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void Meld(HBLTNode&lt;T&gt; * &amp;x, HBLTNode&lt;T&gt;* y);</span><br><span class="line">public:</span><br><span class="line">    MaxHBLT()&#123; root = 0 &#125;;</span><br><span class="line">    ~MaxHBLT()&#123; Free(root); &#125;</span><br><span class="line">    T Max()&#123;</span><br><span class="line">        if (!root)</span><br><span class="line">            throw OutOfBounds();</span><br><span class="line">        return root-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxHBLT&lt;T&gt;&amp; Insert(const T&amp; x);</span><br><span class="line">    MaxHBLT&lt;T&gt;&amp; DeleteMax(T&amp; x);</span><br><span class="line">    MaxHBLT&lt;T&gt;&amp; Meld(MaxHBLT&lt;T&gt;&amp; x)&#123;</span><br><span class="line">        Meld(root, x.root);</span><br><span class="line">        x.root = 0;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Initialize(T a[], int n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来先给出合并操作的函数实现代码，该函数首先要处理合并的树中至少有一个为空的特殊情况。当没有空树时要确保$x$指向根值较大的树，如果$x$不是指向根值较大的树，则将$x$和$y$的指针进行交换。接下来把$x$的右子树与以$y$为根的最大HBLT进行递归合并。合并后为保证整棵树是最大HBLT，$x$的左右孩子可能需要交换，这是通过计算$x$的$s$值来确定的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxHBLT&lt;T&gt;::Meld(HBLTNode&lt;T&gt;* &amp;x, HBLTNode&lt;T&gt;* y)&#123;</span><br><span class="line">    <span class="comment">// 合并两棵根分别是*x和*y的左高树，返回指向新根 x的指针</span></span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x)&#123;</span><br><span class="line">        x = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;data &lt; y-&gt;data)&#123;</span><br><span class="line">        <span class="comment">// 交换x和y</span></span><br><span class="line">        HBLTNode&lt;T&gt; * temp = y;</span><br><span class="line">        y = x;</span><br><span class="line">        x = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    Meld(x-&gt;RightChild, y);</span><br><span class="line">    <span class="keyword">if</span> (!x-&gt;LeftChild)&#123;</span><br><span class="line">        <span class="comment">// 左子树为空,交换子树</span></span><br><span class="line">        x-&gt;LeftChild = x-&gt;RightChild;</span><br><span class="line">        x-&gt;RightChild = <span class="number">0</span>;</span><br><span class="line">        x-&gt;s = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;LeftChild-&gt;s &lt; x-&gt;RightChild-&gt;s)&#123;</span><br><span class="line">            <span class="comment">// 交换左右子树</span></span><br><span class="line">            HBLTNode&lt;T&gt; * temp = x-&gt;LeftChild;</span><br><span class="line">            x-&gt;RightChild = x-&gt;LeftChild;</span><br><span class="line">            x-&gt;LeftChild = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;s = x-&gt;RightChild-&gt;s + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后给出插入，删除和初始化函数的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHBLT&lt;T&gt;&amp; MaxHBLT&lt;T&gt;::Insert(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将x插入左高树</span></span><br><span class="line">    HBLTNode&lt;T&gt;* q = <span class="keyword">new</span> HBLTNode&lt;T&gt;(x, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将q与原树合并</span></span><br><span class="line">    Meld(root, q);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHBLT&lt;T&gt;&amp; MaxHBLT&lt;T&gt;::DeleteMax(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除最大元素，并将其放入x</span></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line"></span><br><span class="line">    x = root-&gt;data;</span><br><span class="line">    HBLTNode&lt;T&gt;*L = root-&gt;LeftChild;</span><br><span class="line">    HBLTNode&lt;T&gt;*R = root-&gt;RightChild;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    root = L;</span><br><span class="line">    Meld(root, R);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxHBLT&lt;T&gt;::Initialize(T a[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="comment">// 初始化有n个元素的HBLT树</span></span><br><span class="line">    Queue&lt;HBLTNode&lt;T&gt;*&gt;Q(n);</span><br><span class="line">    <span class="comment">// 删除老节点</span></span><br><span class="line">    Free(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        HBLTNode&lt;T&gt;* q = <span class="keyword">new</span> HBLTNode&lt;T&gt;(a[i-<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        Q.Add(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断合并队列中的树；</span></span><br><span class="line">    HBLTNode&lt;T&gt;*b, *c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Q.Delete(b).Delete(c);</span><br><span class="line">        Meld(b, c);</span><br><span class="line">        <span class="comment">// 将合并后得到的树放入对了</span></span><br><span class="line">        Q.Add(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">        Q.Delete(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于上述函数的复杂性，构造函数只需要耗时$\theta(1)$,而析构函数需要$\theta(n)$，其中$n$是要删除的最大HBLT中的元素个数。<strong>Max</strong>函数的复杂性是$\theta(1)$，<strong>Insert,DeleteMax</strong>及共享成员函数<strong>Meld</strong>的复杂性与私有成员函数<strong>Meld</strong>的复杂性相同，由于私有成员函数<strong>Meld</strong>仅在以$<em>x$和$</em>y$为根的树的右子树中移动，因此其复杂性是$O(x-&gt;s+y-&gt;s)$。又由于$<em>x$和$</em>y$的最大$s$值分别为$log_2(m+1)$和$log_2(n+1)$,其中$m,n$分别是以$<em>x$和$</em>y$为根的最大HBLT中的元素个数，所以私有成员函数<strong>Meld</strong>的复杂性是$O(logmn)$。</p>
<p>更完整的代码例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/PriorityQueue/MaxHBLT.h" target="_blank" rel="external">最大高度优先左高树的实现</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本节将介绍另一种实现优先队列的数据结构–左高树</p>
<h3 id="u9AD8_u5EA6_u4E0E_u5BBD_u5EA6_u4F18_u5148_u7684_u6700_u5927_u5]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优先队列1--堆]]></title>
    <link href="http://ccc013.github.io/2016/08/23/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%971-%E5%A0%86/"/>
    <id>http://ccc013.github.io/2016/08/23/优先队列1-堆/</id>
    <published>2016-08-23T12:27:57.000Z</published>
    <updated>2016-10-23T07:19:13.371Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本小节主要介绍的是优先队列的定义以及其中一种实现方法–最大堆的实现，最后是堆的一个应用–堆排序。</p>
<p>优先队列删除元素时根据优先权高或低的次序，而不是元素进行队列的次序，这与之前第六章介绍的FIFO结构的队列不同。</p>
<p><strong>可以利用堆数据结构来高效地实现优先队列，堆是一棵完全二叉树</strong>。</p>
<h3 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>优先队列（priority queue)是0个或多个元素的集合，每个元素都有一个优先权或值，对优先队列执行的操作有1）查找；2）插入一个新元素；3）删除。</p>
</blockquote>
<p>优先队列可以按搜索的是优先权大或小的元素分为最大优先队列或者最小优先队列，而删除操作则是用来删除对应查找的元素。另外，优先队列中的元素可以有相同的优先权，查找和删除操作可根据任意优先权进行。</p>
<p>下面给出最大优先队列的抽象数据类型，最小优先队列的抽象数据类型与之相似，只需要将最大改为最小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型MaxPriorityQueue&#123;</span><br><span class="line">实例</span><br><span class="line">    有限的元素集合，每个元素都有一个优先权</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空的优先队列</span><br><span class="line">    Size(): 返回队列中的元素数目</span><br><span class="line">    Max(): 返回具有最大优先权的元素</span><br><span class="line">    Insert(x): 将x插入队列</span><br><span class="line">    DeleteMax(x): 从队列中删除具有最大优先权的元素，并将该元素返回至x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u5806"><a href="#u5806" class="headerlink" title="堆"></a>堆</h3><h4 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>[最大树（最小树）] 每个节点的值都大于（小于）或等于其子节点（如果有的话）值的树。</p>
</blockquote>
<p>最大树与最小树的例子分别如下图9-1,9-2所示。虽然这些树都是二叉树，但最大树不必是二叉树，最大树或最小树节点的子节点个数可以大于2。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%861.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>[最大堆(最小堆)] 最大（最小）的完全二叉树。</p>
</blockquote>
<p>上图9-1b并所示的最大树并不是最大堆，因为它不是完全二叉树，而其他两个最大树是最大堆。同样，图9-2b也不是完全二叉树，所以也不是最小堆，其他两个最小树则是最小堆。</p>
<p>堆是完成二叉树，可以利用<a href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/">二叉树的基本概念和实现</a>中介绍的公式化描述方案，可用一维数组有效地描述堆，利用二叉树的特性4可将堆中的节点移动到其父节点或子节点处。<strong>另外，堆是完全二叉树，拥有n个元素的堆高度是$\left\lceil  log_2(n+1) \right\rceil$,因此，如果可在$O(height)$时间内完成插入和删除操作，其复杂性是$O(log_2n)$。</strong></p>
<h4 id="u6700_u5927_u5806_u7684_u63D2_u5165"><a href="#u6700_u5927_u5806_u7684_u63D2_u5165" class="headerlink" title="最大堆的插入"></a>最大堆的插入</h4><p>  如下图9-3a是一个具有5个元素的最大堆，当要加入一个元素的时候，因为堆是完全二叉树，得到的新树结构必然如9-3b所示，这个时候如果新元素的值是5，它比2要大，此时需要将2下移变成左孩子，如图9-3c所示，此外还要与根节点进行比较，这里如果新插入的元素值是21，就大于根节点的20了，此时还需要将20下移到原来2的位置，变成如图9-3d所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%862.png" alt="此处输入图片的描述"></p>
<p>  插入策略从叶到根只有单一路径，每层工作需耗时$\theta(1)$,因此实现此策略的时间复杂性是$O(height)=O(log_2n)$。</p>
<h4 id="u6700_u5927_u5806_u7684_u5220_u9664"><a href="#u6700_u5927_u5806_u7684_u5220_u9664" class="headerlink" title="最大堆的删除"></a>最大堆的删除</h4><p>  假设对图9-3d的最大堆进行删除，需要删除的是元素21，这个时候只剩下5个元素，需要重新构建最大堆的结构，那么最终应该得到如图9-3a的最大堆形式。然后接下来要删除的是元素20，并得到如图9-4b所示的结构，则首先10从位置5移出，但将其放在根节点的位置得到的不是最大堆，则把根节点的两个孩子15和2中较大的一个放到根节点，然后假设将10插入位置2，但是还不是最大堆，因此将14上移到位置2,10放到位置4，得到如图9-4c所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%863.png" alt="此处输入图片的描述"></p>
<p>  删除策略如插入策略一样，从堆的根节点到叶节点只有单一路径，每层工作需耗时$\theta(1)$,因此实现此策略的时间复杂性是$O(height)=O(log_2n)$。</p>
<h4 id="u6700_u5927_u5806_u7684_u521D_u59CB_u5316"><a href="#u6700_u5927_u5806_u7684_u521D_u59CB_u5316" class="headerlink" title="最大堆的初始化"></a>最大堆的初始化</h4><p>  现在假设开始有数组a，它有n个元素，n=10，它可以用如图9-5a所示的完全二叉树表示，但它不是最大堆。为了将其转化为最大堆，从第一个具有孩子的节点开始（即节点10），<strong>这个元素在数组中的位置是$i=[n/2]$，如果以这个元素为根的子树已经是最大堆，则不需要调整，否则必须调整子树成为最大堆，然后继续检查$i-1,i-2,\ldots$等节点为根的子树，直到检查到根节点为止。</strong></p>
<p>  对图9-5a所示的完全二叉树，首先i=5，因为$10&gt;1$,所以以位置i为根的子树已经是最大堆，接下来检查位置4的子树，$15&lt;17$,它不是最大堆，将其变为最大堆，可得到如图9-5b所示，然后依次检查位置3，位置2以及根节点，分别得到如图9-5c，d所示的最大堆。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%864.png" alt="此处输入图片的描述"></p>
<h4 id="u7C7BMaxHeap"><a href="#u7C7BMaxHeap" class="headerlink" title="类MaxHeap"></a>类MaxHeap</h4><p>  下面程序给出最大堆的类定义。n是私有成员，代表目前堆中的元素的个数；MaxSize是堆的最大容量；heap是存储堆元素的数组，默认大小是10。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> MaxHeap&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> CurrentSize, MaxSize;</span><br><span class="line">    T* heap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(<span class="keyword">int</span> MaxHeapSize = <span class="number">10</span>);</span><br><span class="line">    ~MaxHeap()&#123; <span class="keyword">delete</span>[] heap; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> CurrentSize; &#125;</span><br><span class="line">    <span class="function">T <span class="title">Max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    MaxHeap&lt;T&gt;&amp; Insert(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    MaxHeap&lt;T&gt;&amp; DeleteMax(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T a[], <span class="keyword">int</span> size, <span class="keyword">int</span> ArraySize)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面给出最大堆的插入、删除和初始化代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将x插入到最大堆中</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为x寻找插入位置</span></span><br><span class="line">    <span class="keyword">int</span> i = ++CurrentSize;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">1</span> &amp;&amp; x &gt; heap[i / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="comment">// 不能够将x放入heap[i]</span></span><br><span class="line">        heap[i] = heap[i / <span class="number">2</span>];  <span class="comment">// 将元素下移</span></span><br><span class="line">        i /= <span class="number">2</span>; <span class="comment">// 移向父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;::DeleteMax(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将最大元素放入x，并从堆中删除最大元素</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line"></span><br><span class="line">    x = heap[<span class="number">1</span>];    <span class="comment">// 最大元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重构堆</span></span><br><span class="line">    T y = heap[CurrentSize--];  <span class="comment">// 最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从根开始，为y寻找合适的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, ci = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (ci &lt;= CurrentSize)&#123;</span><br><span class="line">        <span class="comment">// heap[ci]应是i较大的孩子</span></span><br><span class="line">        <span class="keyword">if</span> (ci &lt; CurrentSize &amp;&amp; heap[ci] &lt; heap[ci + <span class="number">1</span>])</span><br><span class="line">            ci++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否能将y放入heap[i]</span></span><br><span class="line">        <span class="keyword">if</span> (y &gt;= heap[ci])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能</span></span><br><span class="line">        heap[i] = heap[ci];</span><br><span class="line">        <span class="comment">// 下移一层</span></span><br><span class="line">        i = ci;</span><br><span class="line">        ci *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::Initialize(T a[], <span class="keyword">int</span> size, <span class="keyword">int</span> ArraySize)&#123;</span><br><span class="line">    <span class="comment">// 把最大堆初始化为a</span></span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap = <span class="keyword">new</span> T[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= size; s++)&#123;</span><br><span class="line">        heap[s] = a[s - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    CurrentSize = size;</span><br><span class="line">    MaxSize = ArraySize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生一个最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        T y = heap[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找放置y的位置</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">2</span> * i;</span><br><span class="line">        <span class="keyword">while</span> (c &lt;= CurrentSize)&#123;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; CurrentSize&amp;&amp;heap[c] &lt; heap[c + <span class="number">1</span>])</span><br><span class="line">                c++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (y &gt;= heap[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            heap[c / <span class="number">2</span>] = heap[c];</span><br><span class="line">            c *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[c / <span class="number">2</span>] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入代码中，i从新创建的叶节点位置CurrentSize开始，对从该位置到根的路径进行遍历，对每个位置，都检查是否到达跟(i=1)或在i处插入新元素不会改变最大树的性质–$x \le heap[i/2]$，只要满足其中一个条件，就可以在i处插入x，否则会执行循环体中的代码。插入操作的时间复杂性是$O(logn)$。</p>
<p>删除操作的时间复杂性也是$O(logn)$。</p>
<p>初始化函数<strong>Initialize</strong>中for循环每次所花时间是$O(logn)$,循环次数是n/2，总的复杂性是$O(nlogn)$。实际应用中，初始化操作的复杂性是$\theta(n)$。</p>
<p>更完整的代码例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/PriorityQueue/MaxHeap.h" target="_blank" rel="external">最大堆的实现</a>。</p>
<h3 id="u5806_u6392_u5E8F"><a href="#u5806_u6392_u5E8F" class="headerlink" title="堆排序"></a>堆排序</h3><p>  利用堆来实现n个元素的排序，所需时间是$O(nlogn)$,可以将先要排序的n个元素初始化为一个最大堆，然后每次从堆中提取（即删除）元素，各元素将按递减次序排列。初始化所需要的时间是$\theta(n)$,每次删除所需要的时间是$O(logn)$,因此总时间是$O(nlogn)$。</p>
<p>实现代码如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 利用堆排序算法对a[1:n]进行排序</span></span><br><span class="line">    MaxHeap&lt;T&gt; H(<span class="number">1</span>);</span><br><span class="line">    H.Initialize(a, n, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中逐个抽取元素</span></span><br><span class="line">    T x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        H.DeleteMax(x);</span><br><span class="line">        a[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆的析构函数中保存数组a</span></span><br><span class="line">    H.Deactivate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">20</span>, <span class="number">12</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    HeapSort(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%865.png" alt="此处输入图片的描述"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第九章优先队列的内容。本小节主要介绍的是优先队列的定义以及其中一种实现方法–最大堆的实现，最后是堆的一个应用–堆排序。</p>
<p>优先队列删除元素时根据优先权高或低的次序，而不是元素进行队列的次序，这与之前第六章介]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的基本概念和实现]]></title>
    <link href="http://ccc013.github.io/2016/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://ccc013.github.io/2016/08/18/二叉树的基本概念和实现/</id>
    <published>2016-08-18T07:05:01.000Z</published>
    <updated>2016-10-25T11:52:45.346Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。</p>
</blockquote>
<p>在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的<strong>孩子(children)</strong>，而Joe是他们的<strong>父母(parent)</strong>。有相同父母的孩子是<strong>兄弟(sibling)</strong>。Ann，Mary,John都是兄弟。此外，还有其他术语：<strong>孙子(grandchild),祖父(grandparent),祖先(ancestor),后代(descendent)等</strong>。树中没有孩子的元素称为<strong>叶子(leaf)</strong>。图中Ann,Mark,Sue和Chris是树的叶子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>树的另一个常用术语是<strong>级(level)</strong>。指定树根的级是1，其孩子的级是2，依次类推。上图中Joe的级是1，而Ann，Mary,John的级是2，然后Mark,Sue,Chris的级是3。</p>
<p><strong>元素的度是指其孩子的个数。</strong>叶节点的度是0。<strong>树的度是其元素度的最大值</strong>。所以上图中的度是3。</p>
<h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p>定义：二叉树(binary tree)t是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个称为根的元素，余下的元素（如果有的话）被组成2个二叉树，分别称为t的左子树和右子树。</p>
</blockquote>
<p><strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树可以为空，树不能为空</li>
<li>二叉树中每个元素都恰好有两棵子树（其中一个或两个可能为空）。而树中每个元素可以有若干子树。</li>
<li>在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树间是无序的。</li>
</ul>
<p>下图给出了表示数学表达式的二叉树，总共有3个数学表达式。每个操作符可以有一个或两个操作数，左操作数是操作符的左子树，而右操作数则是右子树。树中的叶节点是常量或者变量。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h3 id="u4E8C_u53C9_u6811_u7684_u7279_u6027"><a href="#u4E8C_u53C9_u6811_u7684_u7279_u6027" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><blockquote>
<p><strong>特性1： 包含n(n&gt;0)个元素的二叉树边数是n-1。</strong></p>
</blockquote>
<p>证明 二叉树中每个元素 (除了根节点)有且只有一个父节点。在子节点与父节点间有且只有一条边，因此边数为n-1。</p>
<p><strong>二叉树的高度或者深度是指该二叉树的层数。</strong></p>
<blockquote>
<p><strong>特性2： 若二叉树的高度为h,$h \ge 0$,则该二叉树最少有h个元素，最多有$2^h - 1$个元素。</strong></p>
</blockquote>
<p>证明 因为每一层最少要有1个元素，因此元素数最少为h。每元素最多有2个子节点，则第i层节点元素最多为$2^i-1$个,i&gt;0。h=0时，元素的总数为0，也就是$2^0-1$。当h&gt;0时，元素的总数不会超过$\sum_{i=1}^h 2^{i-1}=2^h-1$。</p>
<blockquote>
<p><strong>特性3： 包含n个元素的二叉树的高度最大是n，最小是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
</blockquote>
<p>证明 因为每层至少有一个元素，因此高度不会超过n。由特性2，可以得知高度为h的二叉树最多有$2^h-1$个元素。因为$n \le 2^h-1$,因此$h \ge log_2(n+1)$。由于h是整数，所以$h \ge \left\lceil  log_2(n+1) \right\rceil$。</p>
<p><strong>当高度是h的二叉树恰好有$2^h - 1$个元素时，称其为满二叉树(full binary tree)。</strong>下图就是一个高度为4的满二叉树。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>假设对高度为h的满二叉树中的元素从上到下，从左到右的顺序进行从1到$2^h - 1$进行编号，如上图所示。假设从满二叉树中删除k个元素，其编号为$2^h - i, 1 \le i \le k$,所得到的二叉树称为<strong>完全二叉树(complete binary tree)</strong>。如下图给出的三棵完全二叉树。注意，<strong>满二叉树是完全二叉树的一个特例，并且有n个元素的完全二叉树的深度是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>在完全二叉树中，一个元素与其孩子的编号有非常好的对应关系。其关系在下面特性4中给出。</p>
<blockquote>
<p><strong>特性4： 设完全二叉树中一元素的序号是i，$1 \le i \le n$。则有以下关系成立：</strong><br>1) 当i=1时，该元素为二叉树的根，若i&gt;1,则该元素父节点的编号是$\left\lfloor i/2 \right\rfloor$。<br>2) 当2i&gt;n时，该元素没有左子树，否则，其左子树的编号是2i。<br>3) 若2i+1&gt;n时，该元素没有右子树，否则，其右子树的编号是2i+1。</p>
</blockquote>
<h3 id="u4E8C_u53C9_u6811_u63CF_u8FF0"><a href="#u4E8C_u53C9_u6811_u63CF_u8FF0" class="headerlink" title="二叉树描述"></a>二叉树描述</h3><h4 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h4><p>  二叉树的公式化描述利用特性4。二叉树可以作为缺少了部分元素的完全二叉树。下图给出了二叉树的两个例子。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  在公式化描述方法中，按照二叉树对元素的编号方法，将二叉树的元素存储在数组中。上图同时给出了二叉树的公式化描述，即图中右侧的数组表示。</p>
<p>  当缺少很多元素时，这种描述方法非常浪费空间。实际上，一个有n个元素的二叉树可能最多需要$2^n-1$的空间来存储。当每个节点都是其他节点的右孩子时，存储空间达到最大。如下图所示的一棵有四个元素的二叉树，这种类型的二叉树称为右斜二叉树。当缺少的元素比较少时，这种描述方法很有效。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h4 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h4><p>  <strong>二叉树最常用的描述方法是用链表或指针。</strong>每个元素都用一个有两个指针域的节点表示，这两个域是<strong>LeftChild和RightChild</strong>。除此两个指针域外，每个节点还有一个data域。其代码实现如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> BinaryTreeNode&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Visit</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* LeftChild, *RightChild;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTreeNode()&#123;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode(<span class="keyword">const</span> T&amp; e)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode(<span class="keyword">const</span> T&amp;e, BinaryTreeNode *l, BinaryTreeNode* r)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        LeftChild = l;</span><br><span class="line">        RightChild = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的边可以用一个从父节点到子节点的指针来描述。指针放在父节点的指针域中，因为包括n个元素的二叉树恰有n-1条边，所以有<code>2n-(n-1)=n+1</code>个指针域没有值，这些域被值为0。下图给出了公式化描述中第一幅图的二叉树的链表描述。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>二叉树中不设置指向父节点的指针一般不会有什么问题，因为在二叉树的大部分函数中并不需要此指针。</p>
<h3 id="u4E8C_u53C9_u6811_u904D_u5386"><a href="#u4E8C_u53C9_u6811_u904D_u5386" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>  有四种遍历二叉树的方法：</p>
<ul>
<li><strong>前序遍历</strong></li>
<li><strong>中序遍历</strong></li>
<li><strong>后序遍历</strong></li>
<li><strong>逐层遍历</strong></li>
</ul>
<p>前3种遍历方法将在下面给出代码实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 前序遍历左子树</span></span><br><span class="line">        PreOrder(t-&gt;LeftChild);</span><br><span class="line">        <span class="comment">// 前序遍历右子树</span></span><br><span class="line">        PreOrder(t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        InOrder(t-&gt;LeftChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">        InOrder(t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        PostOrder(t-&gt;LeftChild);</span><br><span class="line">        PostOrder(t-&gt;RightChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三种方法，每个节点的左子树都在其右子树之前遍历。<strong>这三种遍历的区别在于对同一个节点在不同时刻进行访问。</strong>在进行前序遍历时，每个节点是在其左右子树被访问之前进行访问的；在中序遍历时，首先访问左子树，然后访问子树的根节点，最后访问右子树。在后序遍历时，当左右子树均访问完之后才访问子树的根节点。</p>
<p>下图给出上述三种方法对前文给出的数学表达式分别产生的结果，其中<code>Visit(t)</code>由<code>cout&lt;&lt; t-&gt;data;</code>代替。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>当对一棵数学表达式树进行前、中、后序遍历时，便分别得到表达式的前缀、中缀和后缀表达式。中缀（infix）形式就是平时书写的数学表达式。使用中缀形式的时候由于没有括号，可能会产生一些歧义，比如对于<code>x+y*z</code>，可以理解为<code>(x+y)*z</code>或者<code>x+(y*z)</code>，为了避免这种歧义，可以使用完全括号化的中缀表达式，每个操作符和相应的操作数都用一对括号括起来。下面是改进后的中序遍历算法的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Infix</span><span class="params">(BinaryTreeNode&lt;T&gt; *t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 输出完全括号的中缀表达式</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">        <span class="comment">// 左操作数</span></span><br><span class="line">        Infix(t-&gt;LeftChild);</span><br><span class="line">        <span class="comment">// 操作符</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t-&gt;data;</span><br><span class="line">        <span class="comment">// 右操作数</span></span><br><span class="line">        Infix(t-&gt;RightChild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在后缀(postfix)表达式中，每个操作符跟在操作数之后，操作数从左到右的顺序出现；在前缀(prefix)表达式中，操作符位于操作数之前。前缀和后缀表达式都不会存在歧义，不需要采用括号或者优先级。从左到右或者从右到左扫描表达式并采用操作数栈，可以很容易确定操作数和操作符的关系。若在扫描中遇到一个操作数，把它压入堆栈，遇到一个操作符，则将其与栈顶的操作数相匹配，把这些操作数推出栈，由操作符执行相应的计算，并将所得结果作为操作数压入堆栈。</p>
<p>逐层遍历就是<strong>按从顶层到底层的次序访问树中元素，在同一层中，从左到右进行访问。</strong>由于遍历中使用的是一个队列而不是栈，因此写一个按层遍历的递归程序很困难。下列程序是采用队列来实现对二叉树进行逐层遍历，队列中的元素指向二叉树节点，这里使用了之前<a href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%971-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">队列章节</a>中使用的类<strong>LinkedQueue</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对*t逐层遍历</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt;  Q;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 将t的右孩子放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;LeftChild)</span><br><span class="line">            Q.Add(t-&gt;LeftChild);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;RightChild)</span><br><span class="line">            Q.Add(t-&gt;RightChild);</span><br><span class="line">        <span class="comment">// 访问下一个节点</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Q.Delete(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述程序中，首先仅当树非空时，才进入<code>while</code>循环。首先访问根节点，然后将其子节点加到队列中。当队列添加操作失败时，由Add会引发<code>NoMem</code>异常，由于没有捕捉该异常，所以发生该异常时函数将退出。在添加操作成功后，就进行从队列中删除t元素，如果成功，则删除的元素会返回到t中，这个删除的元素也就是下一个要访问的节点。下次访问该节点的时候，又会将其左右子树加入到队列的尾部，然后下一个要访问的就是根节点的右子树（如果存在），如此就可以实现逐层遍历了。而如果删除失败就表明队列为空，也就是意味着遍历的结束。</p>
<p>假设二叉树中元素的数目是<code>n</code>。这四种遍历算法的空间复杂性均为$O(n)$,时间复杂性是$\theta(n)$。当t的高度是n的时候，通过观察期前序、中序和后序遍历时所使用的递归栈空间可得到上述结论。当t是满二叉树的时候，逐层遍历所需要的队列空间是$\theta(n)$。每个遍历算法花在树中每个节点上的时间是$\theta(1)$(假设访问一个节点的时间是$\theta(1)$)。</p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578BBinaryTree"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578BBinaryTree" class="headerlink" title="抽象数据类型BinaryTree"></a>抽象数据类型BinaryTree</h3><p>  下面给出二叉树的抽象数据类型，这里只列出几个常用的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 BinaryTree&#123;</span><br><span class="line">实例</span><br><span class="line">    元素集合；如果不空，则被划分为根节点、左子树和右子树；</span><br><span class="line">    每个子树仍是一个二叉树</span><br><span class="line">操作</span><br><span class="line">    Create()：创建一个空的二叉树；</span><br><span class="line">    IsEmpty：如果二叉树为空，则返回 true ，否则返回false</span><br><span class="line">    Root(x)：取x为根节点；如果操作失败，则返回false，否则返回true</span><br><span class="line">    MakeTree(root,left，right)：创建一个二叉树，root作为根节点，left作为左子树， right作为右子树</span><br><span class="line">    BreakTree(root，left，right)：拆分二叉树</span><br><span class="line">    PreOrder：前序遍历</span><br><span class="line">    InOrder：中序遍历</span><br><span class="line">    PostOrder：后序遍历</span><br><span class="line">    LevelOrder：逐层遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u7C7BBinaryTree"><a href="#u7C7BBinaryTree" class="headerlink" title="类BinaryTree"></a>类BinaryTree</h3><p>  下面给出类<strong>BinaryTree</strong>的C++定义。函数<strong>Visit</strong>作为遍历函数的参数，以实现不同操作的实现。该定义中使用了链表描述的二叉树。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class BinaryTree&#123;</span><br><span class="line">private:</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *root;    // 根节点指针</span><br><span class="line">    void PreOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">    void Inorder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">    void PostOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">public:</span><br><span class="line">    BinaryTree()&#123; root = 0; &#125;</span><br><span class="line">    ~BinaryTree()&#123;&#125;;</span><br><span class="line">    bool IsEmpty() const&#123;</span><br><span class="line">        return ((root) ? false : true);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Root(T&amp; x)const;</span><br><span class="line">    void MakeTree(const T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);</span><br><span class="line">    void BreakTree(const T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);</span><br><span class="line">    void PreOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        PreOrder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void Inorder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        Inorder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void PostOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        PostOrder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void LevelOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u));</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面会给出共享成员函数<code>Root,MakeTree,BreakTree</code>的代码。函数<code>MakeTree</code>和<code>BreakTree</code>要求参与操作的三棵树应该互不相同，否则程序会得出错误的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;T&gt;::Root(T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 取根节点的data域，放入x，如果没有则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (root)&#123;</span><br><span class="line">        x = root-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::MakeTree(<span class="keyword">const</span> T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)&#123;</span><br><span class="line">    <span class="comment">// 将left，right和element合并成一棵新树，并且要求left和right及this必须是不同的树。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新树</span></span><br><span class="line">    root = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(element, left.root, right.root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止访问left和right</span></span><br><span class="line">    left.root = right.root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::BreakTree(T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)&#123;</span><br><span class="line">    <span class="comment">// left,right 和this必须是不同的树</span></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="comment">// 空树</span></span><br><span class="line">        <span class="keyword">throw</span> BadInput();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分解树</span></span><br><span class="line">    element = root-&gt;data;</span><br><span class="line">    left.root = root-&gt;LeftChild;</span><br><span class="line">    right.root = root-&gt;RightChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出四种遍历方法的实现代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        PreOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">        PreOrder(Visit, t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::Inorder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        Inorder(Visit, t-&gt;LeftChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">        Inorder(Visit, t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PostOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        PostOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">        PostOrder(Visit, t-&gt;RightChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::LevelOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;* u))&#123;</span><br><span class="line">    <span class="comment">// 逐层遍历</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt;Q;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *t;</span><br><span class="line">    t = root;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 将t的右孩子放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;LeftChild)</span><br><span class="line">            Q.Add(t-&gt;LeftChild);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;RightChild)</span><br><span class="line">            Q.Add(t-&gt;RightChild);</span><br><span class="line">        <span class="comment">// 访问下一个节点</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Q.Delete(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是对类BinaryTree的简单应用，程序中构造了一个四节点的二叉树，并进行了前序遍历以确定书中的节点数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"xcept.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"BinaryTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">BinaryTree&lt;<span class="keyword">int</span>&gt;a, x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ct</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    y.MakeTree(<span class="number">1</span>, a, a);</span><br><span class="line">    z.MakeTree(<span class="number">2</span>, a, a);</span><br><span class="line">    x.MakeTree(<span class="number">3</span>, y, z);</span><br><span class="line">    y.MakeTree(<span class="number">4</span>, x, a);</span><br><span class="line">    y.PreOrder(ct);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Tree y has "</span>&lt;&lt; count &lt;&lt;<span class="string">" nodes"</span>&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B_u53CA_u7C7B_u7684_u6269_u5145"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B_u53CA_u7C7B_u7684_u6269_u5145" class="headerlink" title="抽象数据类型及类的扩充"></a>抽象数据类型及类的扩充</h3><p>  本节将扩充之前给出的抽象数据类型，增加如下二叉树操作：</p>
<ul>
<li><strong>PreOutput():</strong>按前序方式输出数据域</li>
<li><strong>InOutput():</strong>按中序方式输出数据域</li>
<li><strong>PostOutput():</strong>按后序方式输出数据域</li>
<li><strong>LevelOutput():</strong>逐层输出数据域</li>
<li><strong>Delete():</strong>删除一棵二叉树，释放其节点</li>
<li><strong>Height():</strong>返回树的高度</li>
<li><strong>Size():</strong>返回树中节点数</li>
</ul>
<h4 id="u8F93_u51FA"><a href="#u8F93_u51FA" class="headerlink" title="输出"></a>输出</h4><p>  四个输出函数可以通过定义一个私有静态成员函数Output来实现，该函数代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Output</span><span class="params">(BinaryTreeNode&lt;T&gt;*t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而四个共享输出函数的形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PreOrder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Inorder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PostOrder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LevelOrder(Output);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Visit操作的时间复杂性是$\theta(1)$,对包括n个节点的二叉树来说，每种遍历方法所花费的时间是$\theta(n)$(遍历成功的话），因此每种输出方法的时间复杂性均为$\theta(n)$。</p>
<h4 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h4><p>  要删除一棵二叉树，需要删除其所有节点，可以通过<strong>后序遍历</strong>在访问一个节点时，将其删除，也就是先删除左子树，然后右子树，最后删除根。因此函数<strong>Delete</strong>的形式如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PostOrder(Free, root);</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Free</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中函数<strong>Free</strong>是一个私有成员函数。要删除的二叉树有n个节点时，<strong>Delete</strong>函数的时间复杂性是$\theta(n)$。</p>
<h4 id="u8BA1_u7B97_u9AD8_u5EA6"><a href="#u8BA1_u7B97_u9AD8_u5EA6" class="headerlink" title="计算高度"></a>计算高度</h4><p>  <strong>通过进行后序遍历，可以得到二叉树的高度。</strong>首先得到左子树的高度hl，然后得到右子树的高度hr，则树的高度为<strong>max{hl,hr}+1</strong>。</p>
<p>  但是这里不能使用之前定义的后序遍历代码，因为在进行遍历的时候需要有返回值（也就是子树的高度）。所以首先需要在增加一个共享成员函数Height,其代码为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Height(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后增加一个私有成员函数<strong>Height</strong>，其实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> BinaryTree&lt;T&gt;::Height(BinaryTreeNode&lt;T&gt; *t)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回树*t的高度</span></span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左子树高度</span></span><br><span class="line">    <span class="keyword">int</span> hl = Height(t-&gt;LeftChild);</span><br><span class="line">    <span class="comment">// 右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> hr = Height(t-&gt;RightChild);</span><br><span class="line">    <span class="keyword">if</span> (hl &gt; hr)</span><br><span class="line">        <span class="keyword">return</span> ++hl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ++hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数的时间复杂性是$\theta(n)$。</p>
<h4 id="u7EDF_u8BA1_u8282_u70B9_u6570"><a href="#u7EDF_u8BA1_u8282_u70B9_u6570" class="headerlink" title="统计节点数"></a>统计节点数</h4><p>  可以用上述四种遍历方法中的任何一种来获取二叉树中的节点数，因为每种遍历方法都对每个节点仅访问一次，只要在访问每个节点的时候将一个全局计数器加1即可。所以首先在类<strong>BinaryTree</strong>定义外定义一个全局变量：<code>int _count;</code>,然后增加一个共享成员函数<strong>Size</strong>和私有成员函数<strong>Add1</strong>，其代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add1</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    _count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _count = <span class="number">0</span>;</span><br><span class="line">    PreOrder(Add1, root);</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<strong>Size</strong>的时间复杂性是$\theta(n)$。</p>
<p>对于类<strong>BinaryTree</strong>的定义以及测试例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/BinaryTree" target="_blank" rel="external">二叉树</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节内容主要是介绍了树的基本概念以及二叉树的定义、特性和实现代码，包括四种遍历树的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳表&散列2-散列]]></title>
    <link href="http://ccc013.github.io/2016/08/07/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%972-%E6%95%A3%E5%88%97/"/>
    <id>http://ccc013.github.io/2016/08/07/跳表-散列2-散列/</id>
    <published>2016-08-07T10:38:48.000Z</published>
    <updated>2016-10-27T12:10:56.751Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节内容是介绍字典的另一种描述方法–散列。</p>
<h3 id="u6563_u5217_u8868_u63CF_u8FF0"><a href="#u6563_u5217_u8868_u63CF_u8FF0" class="headerlink" title="散列表描述"></a>散列表描述</h3><h4 id="u7406_u60F3_u6563_u5217"><a href="#u7406_u60F3_u6563_u5217" class="headerlink" title="理想散列"></a>理想散列</h4><blockquote>
<p>字典的另一种描述方法就是<strong>散列（hash）</strong>，它是用一个散列函数（hash function）把关键字映射到散列表（hash table）中的特定位置。</p>
</blockquote>
<p>也就是使用哈希表来描述字典了。</p>
<p>在理想情况下，如果元素e的关键字是k，散列函数是f，那么e在散列表中的位置为$f(k)$。要搜索关键字为k的元素，首先要计算出$f(k)$，然后看$f(k)$处是否有元素，如果有，则找到该元素，如果没有，说明该字典中不包含该元素。在前一种情况中，如果要删除该元素，只需要把表中$f(k)$位置置为空即可，在后一种情况中，可以通过把元素放在$f(k)$位置以实现插入。</p>
<p>理想情况下，初始化一个空字典需要的时间为$\theta(b)$(b是散列表中位置的个数），搜索、插入和删除操作的时间均为$\theta(1)$。在许多场合都可以使用理想的散列方法，但对于关键字变化范围太大的应用是不能创建这样一个散列表的。</p>
<h4 id="u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u6563_u5217"><a href="#u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u6563_u5217" class="headerlink" title="线性开型寻址散列"></a>线性开型寻址散列</h4><p>  当关键字的范围太大，不能用理想方法表示时，可以采用比关键字范围小的散列表以及把多个关键字映射到同一个位置的散列函数。虽然有多种函数映射方法，但最常用的还是<strong>除法映射</strong>。其形式如下：<br>$$<br>f(k) = k \% D<br>$$<br>其中k是关键字，而D是散列表的大小，也就是位置数，而%是求模操作符。散列表中的位置号从0到D-1，每一个位置称为<strong>桶（bucket）</strong>。若关键字不是正整数型（如int，long,char, unsigned char等），则在计算f(k)之前必须把它转换成非负整数。对于一个长字符串，可以采用取其2个或4个字母来变成无符号整数或无符号长整数的方法。f(k)是存储关键字为k的元素的<strong>起始桶</strong>，在良性情况下，起始桶中存储的元素即是关键字为K的元素。</p>
<p>下图中给出一个散列表ht，桶号从0到10，在图a中，表中只有3个元素，除数D是11，由于80%11=3，所以80的位置是3,40%11=7,65%11=10，每个元素都在相应的桶中，散列表中余下的桶为空。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%971.png" alt="此处输入图片的描述"></p>
<p>现在假设要插入58,58的起始桶应该是f(58)=58%11=3,但是此时该桶中已经放了80了，这个时候就发生了<strong>碰撞</strong>。一般来说，一个桶中是可以存储多个元素的，而存储桶中若没有空间就发生<strong>溢出</strong>。但在我们的表中，每个桶只能存储一个元素，因此同时发生了碰撞和溢出。这个时候处理58的最简单的办法就是将其存储到表中下一个可用的桶中，这种解决溢出的方法叫做<strong>线性开型寻址(linear open addressing)</strong>。</p>
<p>因此如图b所示，将58存放在4号桶中。假设下一个要插入的元素值是24，其起始桶应该是2，然后就放入2号桶中，然后要插入35，其起始桶是2号，使用线性开型寻址的方法，它将被放入5号桶，最后一个要插入的是98，而10号桶已经满了，此时它被插入0号桶中。<strong>因此，在寻找下一个可用桶时，表被视为环形的。</strong></p>
<p>下面给出采用线性开型寻址的散列表的类定义。在类定义中假定散列表中每个元素的类型都是E，每个元素都有一个类型为K的key域。key域是用来计算起始桶的，因此类型K必须能够适应取模操作%。散列表使用了两个数组，ht和empty。当且仅当ht[i]中不含有元素时，empty[i]为true。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> HashTable&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hSearch</span><span class="params">(<span class="keyword">const</span> K&amp; k)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 散列函数的除数</span></span><br><span class="line">    <span class="keyword">int</span> D;</span><br><span class="line">    <span class="comment">// 散列数组</span></span><br><span class="line">    E *ht;</span><br><span class="line">    <span class="comment">// 一维数组</span></span><br><span class="line">    <span class="keyword">bool</span> *empty;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HashTable(<span class="keyword">int</span> divisor = <span class="number">11</span>);</span><br><span class="line">    ~HashTable()&#123; </span><br><span class="line">        <span class="keyword">delete</span>[] ht;</span><br><span class="line">        <span class="keyword">delete</span>[] empty;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp; k, E&amp; e)</span><span class="keyword">const</span></span>;</span><br><span class="line">    HashTable&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp;e);</span><br><span class="line">    HashTable&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp;k, E&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索操作的实现，对于私有成员<strong>hSearch</strong>会返回b号桶的三种情况有：1）<code>empty[b] == false &amp;&amp; ht[b] == k</code>；2）<code>empty[b] == true</code>，即表中没有关键字值为k的元素；3）<code>empty[b] == true &amp;&amp; ht[b] != k</code>,且表已满。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">int</span> HashTable&lt;E, K&gt;::hSearch(<span class="keyword">const</span> K&amp; k)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 查找一个开地址表，如果存在，返回k的位置，否则返回插入点（如果有足够空间）</span></span><br><span class="line">    <span class="comment">// 起始桶</span></span><br><span class="line">    <span class="keyword">int</span> i = k % D;</span><br><span class="line">    <span class="comment">// 在起始桶开始</span></span><br><span class="line">    <span class="keyword">int</span> j = i;  </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty[j] || ht[j] == k)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        <span class="comment">// 下一个桶</span></span><br><span class="line">        j = (j + <span class="number">1</span>) % D;</span><br><span class="line">    &#125; <span class="keyword">while</span> (j != i); <span class="comment">// j== i 表示回到起始桶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表已经满</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> HashTable&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp; k, E&amp; e)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k相匹配的元素并放入e，如果不存在，则返回false;</span></span><br><span class="line">    <span class="keyword">int</span> b = hSearch(k);</span><br><span class="line">    <span class="keyword">if</span> (empty[b] || ht[b] != k)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = ht[b];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入和删除操作如下，其中书中没有实现删除操作，而是作为课后练习题，所以删除操作是自己实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">HashTable&lt;E, K&gt;&amp; HashTable&lt;E, K&gt;::Insert(<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 在散列表中插入一个元素</span></span><br><span class="line">    K k = e;</span><br><span class="line">    <span class="keyword">int</span> b = hSearch(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否能完成插入</span></span><br><span class="line">    <span class="keyword">if</span> (empty[b])&#123;</span><br><span class="line">        empty[b] = <span class="literal">false</span>;</span><br><span class="line">        ht[b] = e;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能插入，检查是否有重复值或者表满</span></span><br><span class="line">    <span class="keyword">if</span> (ht[b] == k)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key "</span> &lt;&lt; k &lt;&lt; <span class="string">" already in the HashTable\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The  HashTable is full.\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">HashTable&lt;E, K&gt;&amp; HashTable&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 删除与k相匹配的元素，并放入e</span></span><br><span class="line">    <span class="keyword">int</span> b = hSearch(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否能进行删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (empty[b])&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key "</span> &lt;&lt; k &lt;&lt; <span class="string">" is not in the HashTable\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以删除</span></span><br><span class="line">    e = ht[b];</span><br><span class="line">    empty[b] = <span class="literal">true</span>;</span><br><span class="line">    ht[b] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = b;</span><br><span class="line">    <span class="keyword">int</span> j = (b+<span class="number">1</span>) % D;</span><br><span class="line">    <span class="comment">// 从下一个桶开始搜索是否存在另一个起始桶一样的元素</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!empty[j])&#123;</span><br><span class="line">            <span class="keyword">if</span> (ht[j] % D == i)&#123;</span><br><span class="line">                empty[i] = <span class="literal">false</span>;</span><br><span class="line">                ht[i] = ht[j];</span><br><span class="line">                empty[j] = <span class="literal">true</span>;</span><br><span class="line">                ht[j] = <span class="number">0</span>;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j = (j + <span class="number">1</span>) % D;</span><br><span class="line">    &#125; <span class="keyword">while</span> (j != b || empty[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更详细的例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/HashTable.h" target="_blank" rel="external">字典–哈希表实现</a></p>
<p>设b是散列表中桶的个数，散列函数中D为除数，且b=D。初始化表的时间是$\theta(b)$。当表中有n个元素时，最坏情况下插入和搜索时间均为$\theta(n)$。而当所有n个关键字值都在同一个桶中时出现最坏的情况。通过比较散列在最坏情况下的复杂性与线性表在最坏情况下的复杂性，可以看到两者完全相同。</p>
<p>但散列的平均性能还是相当好的。用$S_n$和$U_n$来分别表示一次成功搜索和不成功搜索中平均搜索的桶的个数。对于线性开型寻址，有如下公式成立：<br>$$<br>U_n \sim \frac{1}{2} (1+\frac{1}{(1-\alpha)^2}) \<br>S_n \sim \frac{1}{2} (1+\frac{1}{1-\alpha})<br>$$<br>其中$\alpha = \frac{n}{b}$是负载因子。</p>
<p>所以若$\alpha =0.5$，则在不成功搜索时平均搜索的桶的个数为2.5个，而成功搜索时则是1.5个。当$\alpha =0.8$，则是50.5和5.5。所以当负载因子为0.5时，使用线性开型寻址散列表的平均性能要比线性表好。</p>
<p>另一个影响性能的参数是D。<strong>当D是素数或者D没有小于20的素数因子时，可以使性能达到最佳（D等于桶的个数b）</strong>。</p>
<p>而确定D的值，首先要了解影响成功搜索和不成功搜索性能的因素。通过$S_n$和$U_n$的公式，可以确定$\alpha$的值,然后再结合n的值，可以得到b的最小许可值，然后找到一个比b大的最小整数，这个整数要么是素数，要么没有小于20的素数因子，这个整数即可作为D和b的值。</p>
<p>另一种计算D的方法是首先根据散列表的最大空间来确定b的最大可能值，然后取D为不大于这个最大值的整数，该整数要么是素数，要么没有小于20的素数因子。例如，如果在表中最多可以分配530个桶，则D和b的最佳选择为23(因23*23=529)。</p>
<h4 id="u94FE_u8868_u6563_u5217"><a href="#u94FE_u8868_u6563_u5217" class="headerlink" title="链表散列"></a>链表散列</h4><p>  当散列发生溢出的时候，链表是一种好的解决方法。下图给出了散列表在发生溢出时采用链表来进行解决的方法。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%972.png" alt="此处输入图片的描述"></p>
<p>  在该散列表的组织中，每个桶仅含有一个节点指针，所有的元素都是存储在该指针所指向的链表中。</p>
<p>  下面给出代码实现，该类使用了类<strong>SortedChain</strong>的成员。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> ChainHashTable&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 位置数</span></span><br><span class="line">    <span class="keyword">int</span> D;</span><br><span class="line">    <span class="comment">// 链表数组</span></span><br><span class="line">    SortedChain&lt;E, K&gt;* ht;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChainHashTable(<span class="keyword">int</span> divisor = <span class="number">11</span>)&#123;</span><br><span class="line">        D = divisor;</span><br><span class="line">        ht = <span class="keyword">new</span> SortedChain&lt;E, K&gt;[D];</span><br><span class="line">    &#125;</span><br><span class="line">    ~ChainHashTable()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ht;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp;k, E&amp; e)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ht[k%D].Search(k, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ChainHashTable&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">        ht[k%D].DistinctInsert(k, e);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ChainHashTable&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">        ht[k%D].Delete(k, e);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>一种改进方法是在每条链表中添加一个尾节点，尾节点中的关键字值最起码要比散列中所有元素的关键字值都大。</strong>如下图所示。在实际实现的过程中，所有的链表可以共用同一个尾节点。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%A3%E5%88%973.png" alt="此处输入图片的描述"></p>
<h4 id="u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u4E0E_u94FE_u8868_u6563_u5217_u7684_u6BD4_u8F83"><a href="#u7EBF_u6027_u5F00_u578B_u5BFB_u5740_u4E0E_u94FE_u8868_u6563_u5217_u7684_u6BD4_u8F83" class="headerlink" title="线性开型寻址与链表散列的比较"></a>线性开型寻址与链表散列的比较</h4><p>  将线性开型寻址与没有尾节点的链表散列进行比较。令s为每个元素需占用的空间（以字节为单位），每个指针和每个整数类型的变量各占用2个字节空间。同时，设散列表中有b个桶和n个元素。首先注意到使用线性开型寻址时有$n \le b$,而使用链表散列则是n可能大于b。</p>
<p>  采用线性开型寻址所需要的空间为$b(s+2)$个字节，其中s为每个元素所占用的字节数。而使用链表所需要的空间为$2b+2n+ns$字节，当$n \lt \frac{bs}{s+2}$时，链表所用的空间要比开型寻址少。</p>
<p>  在最坏情况下，两种方法进行搜索，都需要搜索所有的n个元素。链表散列的平均搜索次数，其一次不成功搜索和一次成功搜索的平均搜索的桶数如下公式所示：<br>$$<br>U_n   \sim \frac{\alpha+1}{2},\alpha \ge 1 \<br>S_n   \sim 1+\frac{\alpha}{2}<br>$$</p>
<p>将线性开型寻址的公式与链表散列的公式相比较，可以看到使用链表时的平均性能要优于使用线性开型寻址。例如，当$\alpha = 0.9$时，链表散列的一次不成功搜索，平均需要检查0.95个元素，一次成功搜索需要检查1.45个元素。而对于线性开型寻址，则是分别为50.5个5.5个元素。</p>
<h4 id="u6563_u5217_u4E0E_u8DF3_u8868_u6BD4_u8F83"><a href="#u6563_u5217_u4E0E_u8DF3_u8868_u6BD4_u8F83" class="headerlink" title="散列与跳表比较"></a>散列与跳表比较</h4><p>  散列与跳表均使用了随机过程来提高字典操作的性能。<strong>使用跳表时，插入操作用随机过程来决定一个元素的级数。</strong>这种级数分配不需要考虑插入元素的值。<strong>在散列中，当对不同元素进行插入时，散列函数随机地位不同元素分配桶，但散列函数需要使用元素的值。</strong></p>
<p>  <strong>通过使用随机过程，跳表和散列操作的平均复杂性分别为对数时间和常数时间。</strong>跳表的最坏时间复杂性为$(n+ MaxLevel)$，而散列的最坏时间复杂性为$\theta(n)$ 。跳表中指针平均占用的空间约为$Maxlevel+\frac{n}{1-p}$，在最坏情况下可能相当大。链表散列的指针所占用的空间为$D+n$。</p>
<p>不过，跳表比散列更灵活。例如，只需简单地沿着0级链就可以在线性时间内按升序输出所有的元素。而采用链表散列时，需要$\theta(D+n)$时间去收集n个元素并且需要$O(nlogn)$时间进行排序，之后才能输出。对于其他的操作，如查找或删除最大或最小元素，散列可能要花费更多的时间（仅考虑平均复杂性）。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节介绍了字典的另一种实现方法–散列的实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节内容是介绍字典的另一种描述方法–散列。</p>
<h3 id="u6563_u5217_u8868_u63CF_u8FF0"><a href="#u6563_u5217_u8868_u63C]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳表&散列1-字典&跳表]]></title>
    <link href="http://ccc013.github.io/2016/07/27/%E8%B7%B3%E8%A1%A8-%E6%95%A3%E5%88%971-%E5%AD%97%E5%85%B8-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/07/27/跳表-散列1-字典-跳表/</id>
    <published>2016-07-27T14:09:02.000Z</published>
    <updated>2016-10-27T12:10:14.361Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节会介绍字典和跳表。</p>
<p>对于一个有n个元素的有序数组，用折半搜索法进行搜索需要的时间是$O(logn)$,而对一个有序链表进行搜索所需要的时间是$O(n)$。我们可以通过对有序链表上的全部或部分节点增加额外的指针，来提供搜索性能。在搜索时，可以通过这些指针来跳过链表中若干个节点，因此没有必要从左到右搜索链表中的所有节点。</p>
<p><strong>增加了向前指针的链表叫做跳表。</strong>跳表采用随机技术决定链表中哪些节点应增加向前指针以及在节点中应增加多少个指针。采用这种随机技术，跳表中的搜索、插入和删除操作的时间均为$O(logn)$,然而，最坏情况下下时间复杂性却变成$\theta(n)$。而在一个有序数组或链表中进行插入/删除操作的时间为$O(n)$,最坏情况下为$\theta(n)$。</p>
<p><strong>散列法是用来搜索、插入和删除记录的另一种随机方法</strong>。与跳表相比，它的插入/删除操作时间提高到$\theta(1)$,最坏情况下仍为$\theta(n)$。尽管如此，在经常将所有元素按序输出或按序号搜索元素时，跳表的执行效率将优于散列。</p>
<h3 id="u5B57_u5178"><a href="#u5B57_u5178" class="headerlink" title="字典"></a>字典</h3><blockquote>
<p>字典(dictionary)是一些元素的集合。每个元素有一个称作key的域，不同元素的key各不相同。</p>
</blockquote>
<p>抽象数据类型如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型Dictionary&#123;</span><br><span class="line">实例</span><br><span class="line">    具有不同关键字的元素集合</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空字典</span><br><span class="line">    Search(k,x): 搜索关键字为k的元素，结果放入x;如果没找到，则返回false，否则返回true；</span><br><span class="line">    Insert(x): 向字典中插入元素x</span><br><span class="line">    Delete(k,x): 删除关键字为k的元素，并将其放入x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若仅按照一个字典元素本身的关键字来访问该元素，则称为<strong>随机访问</strong>；而<strong>顺序访问</strong>是指按照关键字的递增顺序逐个访问字典中的元素。顺序访问需要借助于<strong>Begin(用来返回关键字最小的元素</strong>和<strong>Next（用来返回下一个元素）</strong>等操作来实现。</p>
<p>在有重复元素的字典与上述抽象数据类型定义的字典相似，只是它允许有相同的关键字。在有重复关键字的字典中，在搜索和删除时需要一个规则来消除歧义。也就是说，如果搜索或删除关键字为k的元素，那么在所有关键字为k的元素中应该返回或者删除哪一个。在有些字典应用中，可能需要，删除在某个时间以后插入的所有元素。</p>
<h3 id="u7EBF_u6027_u8868_u63CF_u8FF0"><a href="#u7EBF_u6027_u8868_u63CF_u8FF0" class="headerlink" title="线性表描述"></a>线性表描述</h3><p>  字典可以保存在线性序列($e_1,e_2,\cdots$)中，其中$e_i$是字典中的元素，其关键字从左到右依次增大。这里可以根据公式化描述或者链表描述自定义类SortedList和SortedChain。</p>
<p>  下面给出的是类SortedChain的定义。E表示链表元素的数据类型，K是链表中排序用到的关键字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> SORTEDCHAIN_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SORTEDCHAIN_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SortedChainNode&#123;</span><br><span class="line">    <span class="keyword">friend</span> SortedChain&lt;E, K&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    K key;</span><br><span class="line">    E data;</span><br><span class="line">    SortedChainNode&lt;E,K&gt; * link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SortedChain&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SortedChainNode&lt;E, K&gt;* first;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SortedChain()&#123; first = <span class="number">0</span>; &#125;</span><br><span class="line">    ~SortedChain();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp; k, E&amp; e)</span><span class="keyword">const</span></span>;</span><br><span class="line">    SortedChain&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp; k, E&amp;e);</span><br><span class="line">    SortedChain&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp; e);</span><br><span class="line">    SortedChain&lt;E, K&gt;&amp; DistinctInsert(<span class="keyword">const</span> K&amp; k, <span class="keyword">const</span> E&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面给出搜索和删除操作的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> SortedChain&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp; k, E&amp; e)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k匹配的元素，结果放入e，如果没有匹配的元素，则返回false</span></span><br><span class="line"></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* p = first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索与K相匹配的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; p&amp;&amp; p-&gt;key != k; p = p-&gt;link)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&amp;&amp;p-&gt;key == k)&#123;</span><br><span class="line">        e = p-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no key--"</span> &lt;&lt; k &lt;&lt; <span class="string">" in sortedChain\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SortedChain&lt;E, K&gt;&amp; SortedChain&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp; k, E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 删除与k相匹配的元素，并将其放入e</span></span><br><span class="line"></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* p = first;</span><br><span class="line">    <span class="comment">// 跟踪p</span></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* tp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; p-&gt;key != k; tp = p, p = p-&gt;link)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;key == k)&#123;</span><br><span class="line">        e = p-&gt;data;</span><br><span class="line">        <span class="comment">// 从链表中删除p所指向的元素</span></span><br><span class="line">        <span class="keyword">if</span> (tp)</span><br><span class="line">            tp-&gt;link = p-&gt;link;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// p是链表首节点</span></span><br><span class="line">            first = p-&gt;link;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> p;   </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no key--"</span> &lt;&lt; k &lt;&lt; <span class="string">" in sortedChain\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入操作如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SortedChain&lt;E, K&gt;&amp; SortedChain&lt;E, K&gt;::DistinctInsert(<span class="keyword">const</span> K&amp; k,<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 如果表中不存在关键值与e相同的元素，则插入e，否则引发异常BadInput</span></span><br><span class="line"></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* p = first;</span><br><span class="line">    <span class="comment">// 跟踪p</span></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* tp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动tp以便把e插入到tp之后</span></span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; p-&gt;key != k; tp = p, p = p-&gt;link);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;key == k)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is already key--"</span> &lt;&lt; k &lt;&lt; <span class="string">" in sortedChain,please choose another key.\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若没有出现重复关键值，则产生一个关键值为e的新节点</span></span><br><span class="line">    SortedChainNode&lt;E, K&gt;* q = <span class="keyword">new</span> SortedChainNode&lt;E, K&gt;;</span><br><span class="line">    q-&gt;data = e;</span><br><span class="line">    q-&gt;key = k;</span><br><span class="line">    <span class="comment">// 将新节点插入到tp之后</span></span><br><span class="line">    q-&gt;link = p;</span><br><span class="line">    <span class="keyword">if</span> (tp)</span><br><span class="line">        tp-&gt;link = q;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        first = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类SortedChain提供了两种插入操作，上述<code>DistinctInset</code>操作保证链中所有元素有不同的关键字，而<code>Insert</code>允许有相同的关键字。</p>
<p>更详细的内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/SortedChain.h" target="_blank" rel="external">字典–链表实现</a></p>
<h3 id="u8DF3_u8868_u63CF_u8FF0"><a href="#u8DF3_u8868_u63CF_u8FF0" class="headerlink" title="跳表描述"></a>跳表描述</h3><h4 id="u7406_u60F3_u60C5_u51B5"><a href="#u7406_u60F3_u60C5_u51B5" class="headerlink" title="理想情况"></a>理想情况</h4><p>  在一个有序链表描述的具有n个元素的字典中进行搜索，至多需要进行n次比较，而如果在链表中部节点加一个指针，则比较次数可以减少到$\frac{n}{2}+1$。搜索的时候，首先将欲搜索元素与中间元素进行比较，如果欲搜索的元素较小，则仅需搜索链表的左半部分，否则，只需搜索链表的右半部分。</p>
<p>  如下图a所示是一个有序链表的七个元素，它有一个头节点和一个尾节点。节点中的数是该节点的值。对该链表搜索可能需要进行7次比较。如果使用图b的方法，在中间增加一个指针，则最坏情况下比较次数减少到4次。</p>
<p>  还可以像图c中一样，再在左半部分和右半部分各增加一个指针，这样可以进一步减少最坏情况下的比较次数。在该图中有3条链，0级链就是图a中的初始链，1级链包括第二，四，六个元素，而2级链只包括第四个元素。</p>
<p>  一个例子是要查找元素77，首先会跟40相比，由于$70 \gt 40$,则在1级链中与75比较，然后$77 \gt 75$，因此在0级链中与80比较，此时可以知道77不在字典中。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E8%B7%B3%E8%A1%A81.png" alt="此处输入图片的描述"></p>
<p>  <strong>通常0级链包括n个元素，1级链包括$\frac{n}{2}$个元素，2级链包括$\frac{n}{4}$个元素，而每$2^i$个元素就有一个i级链指针。当且仅当一个元素在0~i级链上，但不在i+1级（若该链存在）链上时，我们就是说该元素是i级链元素</strong>。所以图c中，40是2级链上唯一的元素，75是1级链元素，20、30、60、80是0级链元素。</p>
<p>  图c所示的结构就是<strong>跳表（skip list）</strong>。在该结构中有一组有层次的链。0级链式包含所有元素的有序链表，1级链是0级链的一个子集。<strong>i级链是i-1级链的子集</strong>。</p>
<h4 id="u63D2_u5165_u548C_u5220_u9664"><a href="#u63D2_u5165_u548C_u5220_u9664" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>  在进行插入和删除时，要想保持上图c的跳表结构，必须耗时$O(n)$。注意到在这种结构中，有<strong>$\frac{n}{2^i}$个元素为i级链元素</strong>，所以在进行插入时应尽量逼近这种结构。在进行插入时，新元素属于i级链的概率为$\frac{1}{2^i}$。在确定新元素的级时，应考虑各种可能的情况。因此，把新元素作为i级链元素的可能性为$p^i$,图c中p=0.5。对于一般的p，链的级数为$\lfloor (log_{\frac{1}{p}}n) \rfloor + 1$,在这种情况下，每p个i-1级链就有一个在i级链中。</p>
<p>  上图d是插入元素77的示例，新元素插在75和80之间，如图d中的虚线所示。插入时，要为新元素分配一个级，分配过程由随机数产生器完成。</p>
<p>  若新元素为i级链元素，则仅影响由虚线断开的0~i级链指针。上图e给出新插入元素77作为1级链表时链表的结构。</p>
<p>  对于删除操作，我们无法控制其结构。</p>
<h4 id="u7EA7_u7684_u5206_u914D"><a href="#u7EA7_u7684_u5206_u914D" class="headerlink" title="级的分配"></a>级的分配</h4><p>  在级基本的分配过程中，可以观察到，在一般跳表结构中，i-1级链中的元素属于i级链的概率为p。假设有一随机数产生器所产生的数在0到RAND_MAX之间，则下一次所产生的随机数小于等于<code>CutOff = p * RAND_MAX</code>的概率为p。因此，若下一随机数小于等于<code>CutOff</code>,则新元素应在1级链上，然后继续确定新元素是否在2级链上，这将由下一个随机数来决定，如果新的随机数继续小于等于<code>CutOff</code>,重复这个过程，直到一个随机数大于<code>CutOff</code>为止。</p>
<p>  所以可以用下列代码为要插入的元素分配级:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lev = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(rand() &lt;= CutOff)</span><br><span class="line">    lev++;</span><br></pre></td></tr></table></figure></p>
<p>  这种方法潜在的缺点是可能为某些元素分配特别大的级，从而导致一些元素的级远远超过$log<em>{\frac{1}{p}}N$,其中N为字典中预期的最大数目。为避免这种情况，可以设定一个上限lev。在有N个元素的跳表中，级MaxLevel的最大值为$\lceil log</em>{\frac{1}{p}}N \rceil -1$,可以采用此值作为上限。</p>
<p>  另一个缺点是即使采用上面给出的上限，但还是可能存在下面的情况，如在插入一个元素前有3条链，但在插入之后就有了10条链，此时，新插入元素的是9级，尽管在前面插入中没有出现3到8级的元素，也就是在此插入前并没有插入3到8级的元素。既然这些空级没有直接的好处，那么可以直接把新元素的级调整为3。</p>
<h4 id="u7C7BSkipNode"><a href="#u7C7BSkipNode" class="headerlink" title="类SkipNode"></a>类SkipNode</h4><p>  跳表结构的头节点需要有足够的指针域，以满足可能构造最大级数的需要，而尾节点不需要指针域。每个存有元素的节点都有一个data域和（级数+1）个指针域。下面给出自定义类<strong>SkipNode</strong>，指针域由数组link表示，其中link[i]表示i级链指针。构造函数为指针数组分配空间，对于一个lev级链元素，其size值为lev+1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SkipList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SkipNode&#123;</span><br><span class="line">    <span class="keyword">friend</span> SkipList&lt;E, K&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SkipNode(<span class="keyword">int</span> size)&#123;</span><br><span class="line">        link = <span class="keyword">new</span> SkipNode&lt;E, K&gt;*[size];</span><br><span class="line">    &#125;</span><br><span class="line">    ~SkipNode() &#123; <span class="keyword">delete</span>[] link; &#125;</span><br><span class="line"></span><br><span class="line">    E data;</span><br><span class="line">    <span class="comment">// 一维指针数组</span></span><br><span class="line">    SkipNode&lt;E, k&gt; **link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="u7C7BSkipList"><a href="#u7C7BSkipList" class="headerlink" title="类SkipList"></a>类SkipList</h4><p>  下面给出类<strong>SkipList</strong>的定义。MaxE是字典的最大容量。虽然给出的代码中允许元素数目超过MaxE，但若元素数目不超过MaxE，平均性能会更好一些。一个元素既在i-1级链上又在i级链上的概率是p，Large是一个比字典中任意一个数均大的值。尾节点的值为Large。0级链上的值（不包括头节点，因其没有值）从左到右按升序排列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E,<span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> SkipList&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Level</span><span class="params">()</span></span>;</span><br><span class="line">    SkipNode&lt;E, K&gt;* SaveSearch(<span class="keyword">const</span> K&amp; k);</span><br><span class="line">    <span class="comment">// 所允许的最大级数</span></span><br><span class="line">    <span class="keyword">int</span> MaxLevel;</span><br><span class="line">    <span class="comment">// 当前非空链的个数</span></span><br><span class="line">    <span class="keyword">int</span> Levels;</span><br><span class="line">    <span class="comment">// 用于确定级号</span></span><br><span class="line">    <span class="keyword">int</span> CutOff;</span><br><span class="line">    <span class="comment">// 一个很大的key值</span></span><br><span class="line">    K TailKey;</span><br><span class="line">    <span class="comment">// 头节点指针</span></span><br><span class="line">    SkipNode&lt;E, K&gt;* head;</span><br><span class="line">    <span class="comment">// 尾节点指针</span></span><br><span class="line">    SkipNode&lt;E, K&gt;* tail;</span><br><span class="line">    <span class="comment">// 指针数组</span></span><br><span class="line">    SkipNode&lt;E, K&gt;** last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SkipList(K Large, <span class="keyword">int</span> MaxE = <span class="number">10000</span>, <span class="keyword">float</span> p = <span class="number">0.5</span>);</span><br><span class="line">    ~SkipList();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> K&amp;k, E&amp;e)</span><span class="keyword">const</span></span>;</span><br><span class="line">    SkipList&lt;E, K&gt;&amp; Insert(<span class="keyword">const</span> E&amp; e);</span><br><span class="line">    SkipList&lt;E, K&gt;&amp; Delete(<span class="keyword">const</span> K&amp;k, E&amp;e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造函数和析构函数如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;::SkipList(K Large, <span class="keyword">int</span> MaxE, <span class="keyword">float</span> p)&#123;</span><br><span class="line">    CutOff = p * RAND_MAX;</span><br><span class="line">    MaxLevel = <span class="built_in">ceil</span>(<span class="built_in">log</span>(MaxE) / <span class="built_in">log</span>(<span class="number">1</span> / p)) - <span class="number">1</span>;</span><br><span class="line">    TailKey = Large;</span><br><span class="line">    <span class="comment">// 初始化随机发生器</span></span><br><span class="line">    randomize();</span><br><span class="line">    <span class="comment">// 对级号进行初始化</span></span><br><span class="line">    Levels = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建头节点、尾节点以及数组last</span></span><br><span class="line">    head = <span class="keyword">new</span> SkipNode&lt;E, K&gt;(MaxLevel + <span class="number">1</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> SkipNode&lt;E, K&gt;(<span class="number">0</span>);</span><br><span class="line">    last = <span class="keyword">new</span> SkipNode&lt;E, K&gt; *[MaxLevel + <span class="number">1</span>];</span><br><span class="line">    tail-&gt;data = Large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有级均置空，即将head指向tail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MaxLevel; i++)</span><br><span class="line">        head-&gt;link[i] = tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;::~SkipList()&#123;</span><br><span class="line">    SkipNode&lt;E, K&gt;* next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过删除0级链来删除所有节点</span></span><br><span class="line">    <span class="keyword">while</span> (head != tail)&#123;</span><br><span class="line">        next = head-&gt;link[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>搜索、插入和删除函数均要求对E进行重载，以便在E的成员之间、E与K的成员之间进行比较。从K到E的赋值和转换也必须定义。当每个元素都有一个整数域data和一个长整数域key，且元素的值由key给出时，可使用下列程序定义的重载。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> element&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">long</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    element&amp; <span class="keyword">operator</span>=(<span class="keyword">long</span> y)&#123;</span><br><span class="line">        key = y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">long</span> key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>SkipList</strong>有两个搜索函数。当需要定位一个值为k的元素时，可使用共享成员函数<strong>Search</strong>。该函数从最高级链（Levels级，仅含一个元素）开始查找，一直到0级链。在每一级链中尽可能地逼近要查找的元素。当从for循环退出时，正好处在欲寻找元素的左边。与0级链中的下一个元素进行比较，即可确定要找的元素是否在跳表中。</p>
<p>第二个搜索函数是私有成员函数<strong>SaveSearch</strong>，由插入和删除操作来调用。<strong>SaveSearch</strong>不仅包含了<strong>Search</strong>的功能，而且可把每一级中遇到的最后一个节点存放在数组last之中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;E, K&gt;::Search(<span class="keyword">const</span> K&amp; k, E&amp; e)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 搜索与k相匹配的元素，并将找到的元素放入e，如果不存在则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= TailKey)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 调整指针p，使其恰好指向可能与k相匹配的节点的前一个节点</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Levels; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="comment">// 逐级向下</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;link[i]-&gt;data &lt; k)</span><br><span class="line">            <span class="comment">// 在第i级链中搜索</span></span><br><span class="line">            p = p-&gt;link[i];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 检查是否下一个节点拥有关键值k</span></span><br><span class="line">    e = p-&gt;link[<span class="number">0</span>]-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> (e == k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipNode&lt;E, K&gt;* SkipList&lt;E, K&gt;::SaveSearch(<span class="keyword">const</span> K&amp; k)&#123;</span><br><span class="line">    <span class="comment">// 搜索k并保存最终所得到的位置</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Levels; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 逐级向下</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;link[i]-&gt;data &lt; k)</span><br><span class="line">            <span class="comment">// 在第i级链中搜索</span></span><br><span class="line">            p = p-&gt;link[i];</span><br><span class="line">        last[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;link[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出插入和删除操作的实现代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line"><span class="keyword">int</span> SkipList&lt;E, K&gt;::Level()&#123;</span><br><span class="line">    <span class="comment">// 产生一个随机级号，该级号&lt;= MaxLevel</span></span><br><span class="line">    <span class="keyword">int</span> lev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (rand() &lt;= CutOff)</span><br><span class="line">        lev++;</span><br><span class="line">    <span class="keyword">return</span> (lev &lt;= MaxLevel) ? lev : MaxLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;&amp; SkipList&lt;E, K&gt;::Insert(<span class="keyword">const</span> E&amp; e)&#123;</span><br><span class="line">    <span class="comment">// 如果不存在重复，则插入e</span></span><br><span class="line">    K k = e;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= TailKey)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is larger than "</span> &lt;&lt; TailKey &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否重复</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = SaveSearch(k);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data == e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is already in SkipList\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不重复，为新节点确定级号</span></span><br><span class="line">    <span class="keyword">int</span> lev = Level();</span><br><span class="line">    <span class="keyword">if</span> (lev &gt; Levels)&#123;</span><br><span class="line">        lev = ++Levels;</span><br><span class="line">        last[lev] = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生新节点，并将新节点插入p之后</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*y = <span class="keyword">new</span> SkipNode&lt;E, K&gt;(lev + <span class="number">1</span>);</span><br><span class="line">    y-&gt;data = e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lev; i++)&#123;</span><br><span class="line">        <span class="comment">// 插入到第i级链</span></span><br><span class="line">        y-&gt;link[i] = last[i]-&gt;link[i];</span><br><span class="line">        last[i]-&gt;link[i] = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> K&gt;</span><br><span class="line">SkipList&lt;E, K&gt;&amp; SkipList&lt;E, K&gt;::Delete(<span class="keyword">const</span> K&amp;k, E&amp;e)&#123;</span><br><span class="line">    <span class="comment">// 删除与k相匹配的元素，并将删除的元素放入e。</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= TailKey)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is larger than "</span> &lt;&lt; TailKey &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否存在与k相匹配的元素</span></span><br><span class="line">    SkipNode&lt;E, K&gt;*p = SaveSearch(k);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data ！= e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"The key is already in SkipList\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从跳表中删除节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Levels &amp;&amp; last[i]-&gt;link[i] == p; i++)</span><br><span class="line">        last[i]-&gt;link[i] = p-&gt;link[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改级数</span></span><br><span class="line">    <span class="keyword">while</span> (Levels &gt; <span class="number">0</span> &amp;&amp; head-&gt;link[Levels] == tail)</span><br><span class="line">        Levels--;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当跳表中有n个元素的时候，搜索、插入和删除操作的复杂性均为$O(n+MaxLevel)$。</p>
<p>更详细内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/SkipList&amp;HashTable/SkipList.h" target="_blank" rel="external">跳表的实现</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节首先介绍了字典的定义以及使用链表描述来实现字典，然后介绍了跳表及其代码实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第七章跳表和散列的内容，本节会介绍字典和跳表。</p>
<p>对于一个有n个元素的有序数组，用折半搜索法进行搜索需要的时间是$O(logn)$,而对一个有序链表进行搜索所需要的时间是$O(n)$。我们可以通过对有序链表]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[队列-基本概念及实现方法]]></title>
    <link href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%97-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://ccc013.github.io/2016/07/23/队列-基本概念及实现方法/</id>
    <published>2016-07-23T09:43:35.000Z</published>
    <updated>2016-10-21T14:24:06.929Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第六章队列的内容。</p>
<blockquote>
<p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行，因此，队列是一个<strong>先进先出(first-in-first-out,FIFO)的线性表</strong>。</p>
</blockquote>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><blockquote>
<p>定义  队列(queue)是一个线性表，其插入和删除操作分别在表的不同端进行。添加新元素的那一端称为队尾(rear),而删除元素的那一端被称为队首(front)。</p>
</blockquote>
<p>其抽象数据类型如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型Queue&#123;</span><br><span class="line">实例</span><br><span class="line">    有序线性表，一端称为front，另一端称为rear；</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空的队列；</span><br><span class="line">    IsEmpty(): 如果队列为空，则返回true，否则返回false；</span><br><span class="line">    IsFull(): 如果队列满，则返回true，否则返回false；</span><br><span class="line">    First(): 返回队列的第一个元素；</span><br><span class="line">    Last(): 返回队列的最后一个元素；</span><br><span class="line">    Add(x): 向队列中添加元素x；</span><br><span class="line">    Delete(x): 删除队首元素，并送入x；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u516C_u5F0F_u63CF_u8FF0"><a href="#u516C_u5F0F_u63CF_u8FF0" class="headerlink" title="公式描述"></a>公式描述</h3><p>  使用公式$location(i)=i-1$来描述一个队列，那么所使用的数组是<code>queue[MaxSize]</code>,那么第一个元素是queue[0],第二个元素是queue<a href="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%971.png" target="_blank" rel="external">1</a>,$\cdots$。<strong>front总是为0，而rear始终是最后一个元素的位置，队列的长度为rear+1，对于一个空队列有rear=-1</strong>。</p>
<p>  按照上述公式描述队列，在添加一个元素的时候，需要将rear加1，并把新元素放入queue[rear]，其所需要的时间是$O(1)$。而删除一个元素，则需要将位置1到位置n的元素分别左移一个位置，即删除一个元素需要花费的时间是$\theta(n)$，n是删除完成后队列中的元素数目。因此，这个公式对于队列的删除操作会花费比较多时间，虽然其应用在堆栈的时候，堆栈的添加和删除操作所需时间只需要$\theta(1)$。</p>
<p>  这里考虑另一个公式$location(i)=location(1)+i-1$,它可以使得队列的删除操作所需要的时间减小至$\theta(1)$。因为在删除的时候，只需要简单的将location(1)加1即可。在用该公式的时候，<strong>front = location(1), rear=location(最后一个元素),一个空队列具有形状$rear \lt front$</strong>。</p>
<p>  如下图所示，每次操作将导致front右移一个位置。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%971.png" alt="此处输入图片的描述"></p>
<p>  当$rear \lt MaxSize-1$时才可以直接在队列的尾部添加新元素。若$rear = MaxSize-1且front \gt 0$时（表明队列未满），为了能够继续向队列添加新元素，必须将所有元素平移到队列的左端，如下图所示，以便在队列的右端留出空间。在使用新的公式情况下，最坏情况下的时间复杂性增加了$\theta(n)$，所以，新公式在提高删除操作执行效率的同时，却降低了添加操作的执行效率。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%972.png" alt="此处输入图片的描述"></p>
<p>  上述两个公式都各有缺点，所以这里就有了第三个公式，可以将队列的添加和删除操作在最坏情况下的时间复杂性均为$\theta(1)$,如下所示：<br>$$<br>location(i) = (location(1)+i-1)\% MaxSize<br>$$<br>这个时候用来描述队列的数组被视为一个环，如下所示，此时，<strong>front指向队列首元素的下一个位置（逆时针），而rear的含义不变</strong>。下图b是添加一个元素，而图c表示的是删除了一个元素。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%973.png" alt="此处输入图片的描述"></p>
<p>当且仅当front=rear时队列为空，但是由于队列满的条件也是front=rear，所以为了避免这种问题，可以不允许队列被填满，在添加元素前，先判断本次操作是否会导致队列被填满，如果是，则报错。因此，队列的最大容量实际上是MaxSize-1。</p>
<p>下面给出基于公式化描述的类Queue的代码实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> QUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Queue&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 与第一个元素在逆时针方向上相差一个位置</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">// 指向最后一个元素</span></span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    T* <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Queue(<span class="keyword">int</span> MaxQueueSize = <span class="number">10</span>);</span><br><span class="line">    ~Queue()&#123; <span class="keyword">delete</span>[] <span class="built_in">queue</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> front == rear; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((rear + <span class="number">1</span>) % MaxSize == front) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">First</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Last</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Queue&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    Queue&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面给出其添加和删除操作函数的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Queue&lt;T&gt;&amp; Queue&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 将x添加到队列的尾部</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull())</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="built_in">queue</span>[rear] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Queue&lt;T&gt;&amp; Queue&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除第一个元素，并将其送入x</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">    x = <span class="built_in">queue</span>[front];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他成员函数实现可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Queue/Queue.h" target="_blank" rel="external">Queue-数组实现</a></strong>。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><p>  像堆栈一样，也可以使用链表来实现一个队列。此时需要两个变量<strong>front和rear</strong>分别跟踪队列的两端。这时有两种情形：从front开始链接到rear，如下图a所示，或者从rear开始链接到front，如下图b所示。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%974.png" alt="此处输入图片的描述"></p>
<p>  下面两张图分别展示了两种情形添加和删除操作，两种情形都适合于添加操作，而从front到rear的链接更便于删除操作的执行，因此，我们将采用从front到rear的链接模式。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%975.png" alt="此处输入图片的描述"> <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%98%9F%E5%88%976.png" alt="此处输入图片的描述"></p>
<p>  可以取处置<strong>front=rear=0，且当且仅当队列为空时front=0</strong>。下面程序给出自定义类<strong>LinkedQueue</strong>。除了析构函数外，链表队列所有成员函数的复杂性均为$\theta(1)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Node&#123;</span><br><span class="line">    <span class="keyword">friend</span> LinkedQueue&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt;* link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedQueue&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* front;</span><br><span class="line">    Node&lt;T&gt;* rear;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedQueue()&#123; front = rear = <span class="number">0</span>; &#125;</span><br><span class="line">    ~LinkedQueue();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((front) ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">First</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Last</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    LinkedQueue&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    LinkedQueue&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后同样是给出添加和删除操作的实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedQueue&lt;T&gt;&amp; LinkedQueue&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 添加元素x</span></span><br><span class="line">    Node&lt;T&gt;* p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;link = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (front)</span><br><span class="line">        <span class="comment">// 队列不为空</span></span><br><span class="line">        rear-&gt;link = p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 队列为空</span></span><br><span class="line">        front = p;</span><br><span class="line">    rear = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedQueue&lt;T&gt;&amp; LinkedQueue&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除第一个元素，并放入x</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    x = front-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第一个节点</span></span><br><span class="line">    Node&lt;T&gt;* p = front;</span><br><span class="line">    front = front-&gt;link;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Queue/LinkedQueue.h" target="_blank" rel="external">链表实现的队列</a></strong>。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节主要是简单介绍了队列的定义以及使用数组和链表来实现的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第六章队列的内容。</p>
<blockquote>
<p>队列是一种特殊的线性表，其插入和删除操作分别在线性表的两端进行，因此，队列是一个<strong>先进先出(first-in-first-out,FIFO)的线]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆栈2-应用]]></title>
    <link href="http://ccc013.github.io/2016/07/21/%E5%A0%86%E6%A0%882-%E5%BA%94%E7%94%A81/"/>
    <id>http://ccc013.github.io/2016/07/21/堆栈2-应用1/</id>
    <published>2016-07-21T11:05:25.000Z</published>
    <updated>2016-10-21T14:23:16.058Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，继续第五章堆栈的内容，这节是最后关于应用方面的内容。这节会介绍括号的匹配，汉诺塔，火车车厢重排三个问题。</p>
<h3 id="u62EC_u53F7_u7684_u5339_u914D"><a href="#u62EC_u53F7_u7684_u5339_u914D" class="headerlink" title="括号的匹配"></a>括号的匹配</h3><p>  括号的匹配就是要匹配一个字符串中的左、右括号。目标是编写一个C++程序，其输入为一个字符串，输出为相互匹配的括号以及未能匹配的括号。注意，括号匹配问题可用来解决C++程序中的{和}的匹配问题。</p>
<p>  可以观察到，<strong>如果从左至右扫描一个字符串，那么最近每个右括号将于最近遇到的未匹配的左括号相匹配</strong>。因此，我们可以在从左至右的扫描过程中，把所遇到的左括号放到堆栈内，每当遇到一个右括号时，就将它与栈顶的左括号(如果存在)相匹配，同时从栈顶删除该左括号。</p>
<p>  下面给出括号匹配问题实现的代码，其时间复杂性是$\theta(n),其中n$是输入串的长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大的字符串长度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxLength = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatchedPairs</span><span class="params">(<span class="keyword">char</span>* expr)</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; s(MaxLength);</span><br><span class="line">    <span class="keyword">int</span> j, length = <span class="built_in">strlen</span>(expr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length; i++)&#123;</span><br><span class="line">        <span class="comment">// 从左到右扫描字符串</span></span><br><span class="line">        <span class="keyword">if</span> (expr[i - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">            <span class="comment">// 栈中添加左括号的位置索引值</span></span><br><span class="line">            s.Add(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i - <span class="number">1</span>] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                s.Delete(j);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No match for right parenthesis"</span> &lt;&lt; <span class="string">" at "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 堆栈中剩下的( 都是未匹配的</span></span><br><span class="line">    <span class="keyword">while</span> (!s.IsEmpty())&#123;</span><br><span class="line">        s.Delete(j);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No match for left parenthesis at "</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"xcept.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"Stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMathedParis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 测试括号匹配</span></span><br><span class="line">    <span class="keyword">char</span> expr[MaxLength];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type an expression of length at most "</span> &lt;&lt; MaxLength &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">cin</span>.getline(expr, MaxLength);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The pairs of matching parentheses in "</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">puts</span>(expr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"are"</span> &lt;&lt; endl;</span><br><span class="line">    PrintMatchedPairs(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    testMathedParis();</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%881.png" alt="此处输入图片的描述"></p>
<h3 id="u6C49_u8BFA_u5854"><a href="#u6C49_u8BFA_u5854" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><blockquote>
<p>在汉诺塔问题中，已知有n个碟子和3座塔。初始时所有的碟子按从大到小次序从塔1的底部堆放至顶部，我们需要把碟子都移动到塔2，每次移动一个碟子，而且任何时候都不能把大碟放在小碟子的上面。</p>
</blockquote>
<p>一个非常优雅的解决办法是使用<strong>递归</strong>。为了把最大的碟子移动到塔2，可以先将其余的n-1个碟子移动到塔3，然后把最大的碟子移动到塔2。接下来是把塔3上的n-1个碟子移动到塔2，因此要借用塔1和塔2，此时可以完全忽视塔2上已经有一个碟子的事实，因为这个碟子是所有碟子中最大的一个。</p>
<p>下面是按照递归方式实现的代码。初始调用的语句是<code>TowersOfHanoi(n,1,2,3)</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉诺塔问题,把n个碟子从塔x移动到塔y，可借助于塔z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TowersOfHanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, x, z, y);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move top disk from tower "</span> &lt;&lt; x &lt;&lt; <span class="string">" to top of tower "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, z, y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序所花费的时间正比于所输出的信息行数目，而信息行的数目等价于碟子移动的次数，其碟子移动次数<code>moves(n)</code>如下所示：<br>$$<br>moves(n)=<br>\begin{cases}<br>0 &amp; n=0 \\<br>2moves(n-1)+1 &amp; n&gt;0<br>\end{cases}<br>$$<br>也就是有$moves(n)=2^n-1$,所以上述函数的时间复杂性是$\theta(2^n)$。</p>
<p>上述函数只是输出把碟子从塔1移动到塔2所需要的碟子移动次序。假定希望给出每次移动之后三座塔的状态，即塔上的碟子及其次序，那么必须在内存中保留塔的状态，并在每次移动碟子之后，修改塔的状态。</p>
<p>由于从每个塔上移走碟子时是按照LIFO的方式进行，因此可以把每个塔表示成一个堆栈。三座塔在任何时候都总共拥有n个碟子，因此，如果使用链表形式的堆栈，只需申请n个元素所需要的空间。如果使用的是基于公式化描述的堆栈，则塔1和塔2的容量都必须是n，而塔3的容量必须为n-1，因而所需要的空间总数为3n-1。</p>
<p>前面的分析指出，汉诺塔问题的复杂性是以n为指数的函数，因此在可以接受的时间范围内，只能解决n值比较小(如$n\le 30$)的汉诺塔问题。而对于这些较小的n值，基于公式化描述和基于链表描述的堆栈在空间需求上的差别相当小，因此可以随意使用。</p>
<p>下面给出基于公式化描述的堆栈。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> HANOI_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> HANOI_H_</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"Stack.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Hanoi&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">useTowersOfHanoi</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TowersOfHanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; *S[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Hanoi::TowersOfHanoi(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)&#123;</span><br><span class="line">    <span class="comment">// 把n个碟子从塔x移动到塔y，可借助于塔z</span></span><br><span class="line">    <span class="comment">// 碟子编号</span></span><br><span class="line">    <span class="keyword">int</span> d; </span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, x, z, y);</span><br><span class="line">        <span class="comment">// 从x中移动走一个碟子</span></span><br><span class="line">        S[x]-&gt;Delete(d);</span><br><span class="line">        <span class="comment">// 放到y上</span></span><br><span class="line">        S[y]-&gt;Add(d);</span><br><span class="line">        ShowState();</span><br><span class="line">        TowersOfHanoi(n - <span class="number">1</span>, z, y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useTowersOfHanoi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 预处理程序</span></span><br><span class="line">    Hanoi X;</span><br><span class="line">    X.S[<span class="number">1</span>] = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    X.S[<span class="number">2</span>] = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    X.S[<span class="number">3</span>] = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = n; d &gt; <span class="number">0</span>; d--)</span><br><span class="line">        <span class="comment">// 将碟子放到塔1上</span></span><br><span class="line">        X.S[<span class="number">1</span>]-&gt;Add(d);</span><br><span class="line"></span><br><span class="line">    X.TowersOfHanoi(n, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>上述函数没有给出<code>ShowState()</code>方法的具体实现，这是由于该函数的实现取决于输出设备的性质（如计算机屏幕、打印机等）</p>
<h3 id="u706B_u8F66_u8F66_u53A2_u91CD_u6392"><a href="#u706B_u8F66_u8F66_u53A2_u91CD_u6392" class="headerlink" title="火车车厢重排"></a>火车车厢重排</h3><blockquote>
<p>一列货运列车共有n节车厢，每节车厢将停放在不同的车站。假定 n个车站的编号分别为1~n，货运列车按照第 n站至第1站的次序经过这些车站。车厢的编号与它们的目的地相同。为了便于从列车上卸掉相应的车厢，必须重新排列车厢，使各车厢从前至后按编号 1到n的次序排列。当所有的车厢都按照这种次序排列时，在每个车站只需卸掉最后一节车厢即可。</p>
</blockquote>
<p>这里可以在一个转轨站里完成车厢的重排工作，在转轨站中有一个入轨、一个出轨和k个缓冲铁轨（位于入轨和出轨之间），如下图所示，其中有k=3个缓冲铁轨H1，H2，和H3。下图a是一个初始的袋重排的车厢次序，而图b则是按照要求的次序重排后的结果。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%882.png" alt="此处输入图片的描述"></p>
<p>为了重排车厢，需从前至后依次检查入轨上的所有车厢。如果正在检查的车厢是下一个满足排列要求的车厢，可以直接把它放在出轨上。如果不是，则把它移动到缓冲铁轨上，直到按输出次序要求轮到它时才将它放到出轨上。缓冲铁轨是按照LIFO的方式使用的，因此车厢的进和出都是在缓存铁轨的顶部进行的。在重排车厢过程中，仅允许以下移动：</p>
<ul>
<li>车厢可以从入轨的前部（即右端）移动到一个缓冲铁轨的顶部或者出轨的左端</li>
<li>车厢可以从缓冲铁轨的顶部移动到出轨的左端</li>
</ul>
<p>考虑图a的情况，由于要求的次序是递增的方式，即1号是最先出轨，然后按顺序从2到9，因此在缓冲铁轨中也应该是从顶部到底部是递增的方式，即在顶部是编号小的，所以缓冲铁轨的中间状态如下所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%A0%86%E6%A0%883.png" alt="此处输入图片的描述"></p>
<p>接下来剩下三个车厢，输出顺序就变得明了了。在这个分配过程中，主要是遵循这样一条规则：<strong>新的车厢u应送入这样的缓冲铁轨：其顶部的车厢编号v满足$v \gt u$，且v是所有满足这种条件的缓冲铁轨顶部车厢编号中最小的一个编号。</strong></p>
<p>对于图a的例子，进行车厢重排的时候，只需要3个缓冲铁轨就足够了，但是对于其他的初始次序，可能需要更多的缓冲铁轨。</p>
<p>因此，这里使用k个链表形式的堆栈来描述k个缓冲铁轨。下列函数<strong>Railroad</strong>用于确定重排n个车厢，它最多可使用k个缓冲铁轨并假定车厢的次序为p[1:n]。如果不能成功重排，函数将返回false，否则返回true。具体实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 火车车厢重排</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Railroad</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// k个缓冲铁轨，车厢初始排序为p[1:n], 如果重排成功，返回true，否则返回false，如果内存不足，则引发异常NoMem</span></span><br><span class="line">    <span class="comment">// 创建于缓冲铁轨对应的堆栈</span></span><br><span class="line">    LinkedStack&lt;<span class="keyword">int</span>&gt; *H = <span class="keyword">new</span> LinkedStack&lt;<span class="keyword">int</span>&gt;[k+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 下一次要输出的车厢</span></span><br><span class="line">    <span class="keyword">int</span> NowOut = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 缓冲铁轨中编号最小的车厢</span></span><br><span class="line">    <span class="keyword">int</span> minH = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// minH号车厢对应的缓冲铁轨</span></span><br><span class="line">    <span class="keyword">int</span> minS;</span><br><span class="line">    <span class="comment">// 进行车厢重排</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == NowOut)&#123;</span><br><span class="line">            <span class="comment">// 直接输出</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"More car "</span> &lt;&lt; p[i] &lt;&lt; <span class="string">" from input to output"</span> &lt;&lt; endl;</span><br><span class="line">            NowOut++;</span><br><span class="line">            <span class="keyword">while</span> (minH == NowOut)&#123;</span><br><span class="line">                Output(minH, minS, H, k, n);</span><br><span class="line">                NowOut++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 将p[i]送入某个缓冲铁轨</span></span><br><span class="line">            <span class="keyword">if</span> (!Hold(p[i], minH, minS, H, k, n))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面则给出函数<strong>Railroad</strong>中使用的函数<strong>Output和Hold</strong>的代码实现，前者主要是用于将一节车厢从缓冲铁轨中输出到出轨处，同时修改minH和minS，而后者则是根据分配规则将车厢c送入某个缓冲铁轨，并在必要的时候修改minH和minS。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">int</span>&amp; minH, <span class="keyword">int</span>&amp; minS, LinkedStack&lt;<span class="keyword">int</span>&gt; H[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 把车厢从缓冲铁轨送至出轨处，同时修改minS和minH</span></span><br><span class="line">    <span class="comment">// 车厢索引</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="comment">// 从堆栈minS中删除编号最小的车厢minH</span></span><br><span class="line">    H[minS].Delete(c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"More car "</span> &lt;&lt; minH &lt;&lt; <span class="string">" from holding track "</span> &lt;&lt; minS &lt;&lt; <span class="string">" to output\n"</span>;</span><br><span class="line">    <span class="comment">// 通过检查所有的栈顶，搜索新的minH和minS</span></span><br><span class="line">    minH = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!H[i].IsEmpty() &amp;&amp; (c = H[i].Top()) &lt; minH)&#123;</span><br><span class="line">            minH = c;</span><br><span class="line">            minS = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Hold</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span>&amp; minH, <span class="keyword">int</span>&amp; minS, LinkedStack&lt;<span class="keyword">int</span>&gt; H[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在一个缓冲铁轨中放入车厢c,如果没有可用的缓冲铁轨，返回false，如果空间不足，则引发异常NoMem</span></span><br><span class="line">    <span class="comment">// 目前最优的铁轨</span></span><br><span class="line">    <span class="keyword">int</span> BestTrack = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最优铁轨上的头辆车厢号</span></span><br><span class="line">    <span class="keyword">int</span> BestTop = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 车厢索引</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="comment">// 扫描缓冲铁轨</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!H[i].IsEmpty())&#123;</span><br><span class="line">            x = H[i].Top();</span><br><span class="line">            <span class="keyword">if</span> (c &lt; x &amp;&amp; x &lt; BestTop)&#123;</span><br><span class="line">                BestTop = c;</span><br><span class="line">                BestTrack = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 铁轨是空</span></span><br><span class="line">            <span class="keyword">if</span> (!BestTrack)</span><br><span class="line">                BestTrack = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!BestTrack)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 把车厢c送入缓冲铁轨</span></span><br><span class="line">    H[BestTrack].Add(c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"More car "</span> &lt;&lt; c &lt;&lt; <span class="string">" from input to holding track "</span> &lt;&lt; BestTrack &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 必要时修改minH和minS</span></span><br><span class="line">    <span class="keyword">if</span> (c &lt; minH)&#123;</span><br><span class="line">        minH = c;</span><br><span class="line">        minS = BestTrack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个函数Output和Hold的时间复杂性都是$\theta(k)$。而在函数Railroad中的while循环最多可以输出n-1节车厢，else语句也是最多有n-1节车厢被送入缓冲铁轨，因此，这两个函数所消耗的总时间是$O(kn)$。而Railroad函数中for循环部分的其余部分耗时$\theta(n)$,因此该函数的时间复杂性是$O(kn)$。</p>
<p>这里如果使用一个平衡折半搜索树来存储缓冲铁轨顶部的车厢编号（在第11章介绍），程序的复杂性可由将至$O(nlogk)$。</p>
<p>更详细的内容可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/Stack/StackExamples.md" target="_blank" rel="external">我的Github</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节主要是介绍堆栈的三个应用，分别是括号的匹配，汉诺塔以及火车车厢重排问题，都是利用堆栈的LIFO性质。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，继续第五章堆栈的内容，这节是最后关于应用方面的内容。这节会介绍括号的匹配，汉诺塔，火车车厢重排三个问题。</p>
<h3 id="u62EC_u53F7_u7684_u5339_u914D"><a href="#u62EC]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[堆栈1--基本概念及实现方法]]></title>
    <link href="http://ccc013.github.io/2016/07/12/%E5%A0%86%E6%A0%881-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://ccc013.github.io/2016/07/12/堆栈1-基本概念及实现方法/</id>
    <published>2016-07-12T07:22:48.000Z</published>
    <updated>2016-10-21T13:04:56.885Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这次是新的一章内容，第五章堆栈。</p>
<blockquote>
<p>堆栈数据结构是通过对线性表的插入和删除操作进行限制而得到的，即插入和删除操作都必须在表的同一端完成，因此堆栈是一个<strong>后进先出(last-in-first-out,LIFO)</strong>的数据结构。</p>
</blockquote>
<p>由于堆栈是一种特殊的线性表，所以可以很自然地从相应的线性表类中派生出堆栈类，既可以从基于公式描述的类<strong>LinearList</strong>类派生，也可以从基于链表结构的类<strong>Chain</strong>派生出堆栈类。</p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>  这里给出堆栈的抽象数据类型描述<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型Stack&#123;</span><br><span class="line">实例</span><br><span class="line">    元素线性表，栈底，栈顶</span><br><span class="line">操作</span><br><span class="line">    Create(): 创建一个空的堆栈</span><br><span class="line">    IsEmpty(): 如果堆栈为空，则返回true，否则返回false</span><br><span class="line">    IsFull(): 如果堆栈满，则返回true，否则返回false</span><br><span class="line">    Top(): 返回栈顶元素</span><br><span class="line">    Add(x): 向堆栈中添加元素x</span><br><span class="line">    Delete(x): 删除栈顶元素，并将它传递给x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u6D3E_u751F_u7C7B_u548C_u7EE7_u627F"><a href="#u6D3E_u751F_u7C7B_u548C_u7EE7_u627F" class="headerlink" title="派生类和继承"></a>派生类和继承</h3><p>  若类B是类A的限制版本，那么可以从类A派生出类B。<strong>我们称类A是基类，类B是派生类。</strong>从类A派生出的类B继承了基类A的所有成员——共享成员、保护成员和私有成员。类型为B的每个对象都与A所有的数据成员和函数相关联。<strong>类B可以采用如下三种基本方式之一来继承类A的成员————共享成员、保护成员和私有成员。</strong>比如，对于共享成员方式，可以采用如下语法形式：<code>class B:public A</code></p>
<p>  <strong>一个类可以从多个类派生而来</strong>。比如，类B从A和C派生而来，并且以共享成员方式继承A的属性，以私有成员方法继承C的属性，相应的语法形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B:<span class="keyword">public</span> A, <span class="keyword">private</span> C</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在所有继承方式中，基类A的私有成员仍是A的私有成员，类B的成员不能够访问它们。不同的继承方式仅影响对基类的保护成员和共享成员的访问。</p>
<p>当B按照共享成员方式从A派生出来，A的保护成员成为B的保护成员，A的共享成员成为B的共享成员。</p>
<p>如果继承方式是保护成员，那么A的共享成员和保护成员均成为B的保护成员。</p>
<p>如果继承方式是私有成员，那么A的共享成员和保护成员均成为B的私有成员。</p>
</blockquote>
<h3 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h3><p>  由于堆栈是一个受限的线性表，因此可以参考<a href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据描述1-线性表</a>中的公式化描述，令栈顶元素存储在<code>element[length-1]</code>，栈底元素存储在<code>element[0]</code>中。下列程序定义的Stack类将使用私有成员方法继承<a href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据描述1-线性表</a>中定义的类LinearList。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> INHERITSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> INHERITSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Stack : <span class="keyword">private</span> LinearList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> MaxStackSize = <span class="number">10</span>) : LinearList&lt;T&gt;(MaxStackSize)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LinearList&lt;T&gt;::isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Length() == GetMaxSize());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">Top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Stack&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    Stack&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::Top() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    T x;</span><br><span class="line">    Find(Length(), x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    Insert(Length(), x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    LinearList&lt;T&gt;::Delete(Length(), x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::Output(<span class="built_in">std</span>::ostream&amp; out)<span class="keyword">const</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        out &lt;&lt; element[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    out &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;out, <span class="keyword">const</span> Stack&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里，Stack的构造函数简单调用线性表的构造函数，提供的参数为堆栈的大小<strong>MaxStackSize</strong>。这里使用操作符<strong>::</strong>来区分基类和派生类的同名成员。</p>
<p>在实现函数<strong>IsFull</strong>时，由于Stack的成员不能直接访问基类的私有成员，因此可以在基类LinearList中增加一个保护成员的函数<strong>GetMaxSize</strong>，其实现如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMaxSize</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MaxSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Stack_u7684_u6548_u7387"><a href="#Stack_u7684_u6548_u7387" class="headerlink" title="Stack的效率"></a>Stack的效率</h4><p>  当T是一个内部数据类型时，堆栈的构造函数和析构函数的复杂性均为$\theta(1)$,当T时用户自定义的类时，构造函数和析构函数的复杂性均为$O(MaxStackSize)$。其余每个堆栈操作的复杂性均为$\theta(1)$。</p>
<p>  这里通过从<code>LinearList</code>派生<code>Stack</code>，一方面大大减少了编码量，另一方面也使得程序的可靠性得到很大提高，因为<code>LinearList</code>经过测试被认为是正确的。</p>
<p>  当然，继承有利的一方面，也有弊端。代码编写的简化带来了运行效率的损失。比如，为了向堆栈中添加一个元素，首先要确定堆栈的长度<code>Length()</code>，然后调用函数<code>Insert()</code>。<code>Insert()</code>函数首先会判断插入操作是否会越界，然后需要付出一个for循环的开销来执行0个元素的移动。为了消除额外的开销，可以把<code>Stack</code>定义为一个基类，而不是一个派生类。</p>
<p>  另一个潜在问题是派生类<code>Stack</code>也会受到<code>LinearList</code>本身所受限制的影响。比如，必须为数据类型为T的成员定义操作符&lt;&lt;和==，因为前者用于对线性表操作&lt;&lt;的重载，后者用于对<code>LinearList::Search</code>的重载。</p>
<h4 id="u81EA_u5B9A_u4E49Stack"><a href="#u81EA_u5B9A_u4E49Stack" class="headerlink" title="自定义Stack"></a>自定义Stack</h4><p>  下面是自定义Stack的类定义实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Stack&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 栈顶</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="comment">// 最大的栈顶值</span></span><br><span class="line">    <span class="keyword">int</span> MaxTop;</span><br><span class="line">    <span class="comment">// 堆栈元素数组</span></span><br><span class="line">    T* <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> MaxStackSize = <span class="number">10</span>);</span><br><span class="line">    ~Stack()&#123; <span class="keyword">delete</span>[] <span class="built_in">stack</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> top == -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == MaxTop; &#125;</span><br><span class="line">    <span class="function">T <span class="title">Top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Stack&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    Stack&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Stack&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面是类成员函数的定义实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack(<span class="keyword">int</span> MaxStackSize)&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    MaxTop = MaxStackSize - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">stack</span> = <span class="keyword">new</span> T[MaxStackSize];</span><br><span class="line">    top = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::Top()<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull())</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="built_in">stack</span>[++top] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除栈顶元素，并将其传送入x</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    x = <span class="built_in">stack</span>[top--];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Stack&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = x.top;</span><br><span class="line">    <span class="keyword">if</span> (x.IsEmpty())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no elements in stack"</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x.<span class="built_in">stack</span>[pos] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        pos--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过测试，自定义Stack在添加和删除操作要比通过继承而得到的类Stack的相应操作要更快。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><p>  上一节给出用数组实现堆栈的方法即优雅又高效，但是若同时使用多个堆栈，这种方法将浪费大量的空间。</p>
<p>  这里可以使用链表描述，下面给出自定义链表类<code>LinkedStack</code>的类定义声明。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Node&#123;</span><br><span class="line">    <span class="keyword">friend</span> LinkedStack&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt;* link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkedStack&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedStack()&#123; top = <span class="number">0</span>; &#125;</span><br><span class="line">    ~LinkedStack();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> top == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Top</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">    LinkedStack&lt;T&gt;&amp; Add(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">    LinkedStack&lt;T&gt;&amp; Delete(T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(ostream&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>其类成员函数实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedStack&lt;T&gt;::~LinkedStack()&#123;</span><br><span class="line">    Node&lt;T&gt;* next;</span><br><span class="line">    <span class="keyword">while</span> (top)&#123;</span><br><span class="line">        next = top-&gt;link;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkedStack&lt;T&gt;::IsFull()<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Node&lt;T&gt;* p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoMem)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T LinkedStack&lt;T&gt;::Top()<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedStack&lt;T&gt;&amp; LinkedStack&lt;T&gt;::Add(<span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 添加元素x</span></span><br><span class="line">    Node&lt;T&gt;* p = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;link = top;</span><br><span class="line">    top = p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinkedStack&lt;T&gt;&amp; LinkedStack&lt;T&gt;::Delete(T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 删除元素，并传给x返回</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    x = top-&gt;data;</span><br><span class="line">    Node&lt;T&gt;* p = top;</span><br><span class="line">    top = top-&gt;link;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkedStack&lt;T&gt;::Output(ostream&amp; out)&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty())</span><br><span class="line">        out &lt;&lt; <span class="string">"There is no elements in LinkedStack"</span>;</span><br><span class="line">    Node&lt;T&gt;* p = top;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        out &lt;&lt; p-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,LinkedStack&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里仅给出自定义链栈<code>LinkedStack</code>，同样可以通过继承线性表的链表实现类来派生出链栈，但是<code>LinkedStack</code>在添加和删除操作上的效率要更加高点。</p>
<p>代码实现可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/Stack" target="_blank" rel="external">Github</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>本小节主要是介绍了堆栈的基本实现方法，分为数组实现和链表实现，实现的代码也是比较简单的。下面一节会介绍堆栈的一些应用，包括括号匹配，汉诺塔等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》的笔记，这次是新的一章内容，第五章堆栈。</p>
<blockquote>
<p>堆栈数据结构是通过对线性表的插入和删除操作进行限制而得到的，即插入和删除操作都必须在表的同一端完成，因此堆栈是一个<strong>后进先出(last]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵4-稀疏矩阵]]></title>
    <link href="http://ccc013.github.io/2016/07/07/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B54-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/07/07/数组和矩阵4-稀疏矩阵/</id>
    <published>2016-07-07T07:57:30.000Z</published>
    <updated>2016-10-24T12:08:02.522Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍稀疏矩阵的内容。这也是本章节最后一节内容。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>如果一个$m\times n$矩阵中有”许多”元素为0，则称该矩阵为<strong>稀疏矩阵(sparse)</strong></p>
</blockquote>
<p>对应的非稀疏的矩阵称为<strong>稠密矩阵(dense)</strong>。而实际上，稀疏矩阵和稠密矩阵之间并没有一个精确的界限。</p>
<p>$n\times n$的对角矩阵和三对角矩阵都是稀疏矩阵，二者都有$O(n)$个非0元素和$O(n^2)$个0元素。而对于一个$n\times n$的三角矩阵，它至少有$\frac{n(n-1)}{2}$个0元素，最多有$\frac{n(n+1)}{2}$个非0元素。在本节中，我们规定一个矩阵是稀疏矩阵，则其非0元素的数目应小于$n^2/3$,有些情况下应小于$n^2/5$,因此可以将三角矩阵视为稠密矩阵。</p>
<p>诸如对角矩阵和三对角矩阵这样的稀疏矩阵，其非0区域的结构很有规律，因此可以设计一个很简单的存储结构，该存储结构的大小就等于矩阵非0区域的大小，本小节主要考察具有不规则非0区域的稀疏矩阵。</p>
<h3 id="u6570_u7EC4_u63CF_u8FF0"><a href="#u6570_u7EC4_u63CF_u8FF0" class="headerlink" title="数组描述"></a>数组描述</h3><p>  对于下图a中的$4\times 8$矩阵可以按行主次序把非0元素映射到一维数组中，可到到:2,1,6,7,3,9,8,4,5。</p>
<p>  为了重建矩阵结构，必须记录每个非0元素所在的行号和列号，所以在把稀疏矩阵的非0元素映射到数组中时必须提供三个域:<strong>row(矩阵元素所在的行号)、col(矩阵元素所在列号)和value(矩阵元素的值)</strong>。为此定义了下列所示的模板类<strong>Term</strong>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Term&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果a是一个类型为Term的数组，那么下图a中的稀疏矩阵按行主次序存储到a中所得的结果就如图b所示。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B51.png" alt="此处输入图片的描述"></p>
<p>  除了存储数组a以外，还必须存储矩阵行数、矩阵列数和非0项的数目。所以存储上图a中的九个非0元素所需要的存储器字节数是<strong>21<em>sizeof(int)+9</em>sizeof(T)</strong>,这里每个非0元素都有两个int类型的行号和列号，然后加上总的矩阵行数，列数以及非0数目。</p>
<h4 id="u7C7BSparseMatrix"><a href="#u7C7BSparseMatrix" class="headerlink" title="类SparseMatrix"></a>类SparseMatrix</h4><p>  可以定义一个类SparseMatrix，如下所示，用来把稀疏矩阵按行主次序映射到一维数组中。在定义共享成员时，没有定义加法操作符+，因为它会创建一个临时结果，这个临时结果必须复制到所返回的环境才可以使用。由于SparseMatrix的复制构造函数将会复制每一个元素，因此操作符+中的复制代价太大，这里使用Add函数来避免这种情况的发生。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> SparseMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Append</span><span class="params">(<span class="keyword">const</span> Term&lt;T&gt;&amp; t)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="comment">// 非0元素的数目</span></span><br><span class="line">    <span class="keyword">int</span> terms;</span><br><span class="line">    <span class="comment">// 存储非0元素的数组</span></span><br><span class="line">    Term&lt;T&gt; *a;</span><br><span class="line">    <span class="comment">// 数组a的大小</span></span><br><span class="line">    <span class="keyword">int</span> MaxTerms;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SparseMatrix(<span class="keyword">int</span> maxTerms = <span class="number">0</span>);</span><br><span class="line">    ~SparseMatrix()&#123; <span class="keyword">delete</span>[] a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Transpose</span><span class="params">(SparseMatrix&lt;T&gt;&amp; b)</span>  <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> SparseMatrix&lt;T&gt; &amp;b, SparseMatrix&lt;T&gt;&amp;c)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> SparseMatrix&lt;T&gt;&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, SparseMatrix&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面给出构造函数，以及输入操作符和输出操作符，两者的时间复杂性都是$\theta(terms)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">SparseMatrix&lt;T&gt;::SparseMatrix(<span class="keyword">int</span> maxTerms)&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxTerms &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    MaxTerms = maxTerms;</span><br><span class="line">    a = <span class="keyword">new</span> Term&lt;T&gt;[maxTerms];</span><br><span class="line">    terms = rows = cols = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> SparseMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 输出矩阵的特征</span></span><br><span class="line">    out &lt;&lt; <span class="string">"rows = "</span> &lt;&lt; x.rows &lt;&lt; <span class="string">" columns = "</span> &lt;&lt; x.rows &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    out &lt;&lt; <span class="string">"nonzeros terms = "</span> &lt;&lt; x.terms &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="comment">// 输出非0元素，每行1个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.terms; i++)</span><br><span class="line">        out &lt;&lt; <span class="string">"a("</span> &lt;&lt; x.a[i].row &lt;&lt; <span class="string">", "</span> &lt;&lt; x.a[i].col &lt;&lt; <span class="string">") = "</span> &lt;&lt; x.a[i].value &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&gt;&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; in, SparseMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 输入矩阵的特征</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter number of rows, columns, and terms\n"</span>;</span><br><span class="line">    in &gt;&gt; x.rows &gt;&gt; x.cols &gt;&gt; x.terms;</span><br><span class="line">    <span class="keyword">if</span> (x.terms &gt; x.MaxTerms)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="comment">// 输入矩阵元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.terms; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter row, column, and value of term "</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        in &gt;&gt; x.a[i].row &gt;&gt; x.a[i].col &gt;&gt; x.a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在重载输入操作符&gt;&gt;的时候，如果输入的元素数目大于数组a的大小，则会引发一个异常。一种处理异常的方法是删除数组a，然后使用new重新分配一个更大的数组。</p>
<h4 id="u77E9_u9635_u8F6C_u7F6E"><a href="#u77E9_u9635_u8F6C_u7F6E" class="headerlink" title="矩阵转置"></a>矩阵转置</h4><p>  下面程序给出函数<strong>Tranpose</strong>的代码实现。转置后的矩阵被返回到b中。<br>  首先验证b中是否有足够的空间来存储被转置矩阵的非0元素。如果空间不足，要么重新分配一个更大的数组<strong>b.a</strong>,要么引发一个异常。在下面的程序中是选择引发异常。如果b中有足够的空间来容纳转置矩阵，则创建两个数组<strong>ColSize</strong>和<strong>RowNext</strong>。其中<code>ColSize[i]</code>是指矩阵第i列中的非0元素的数目，而<code>RowNext[i]</code>则是代表转置矩阵第i行的下一个非0元素在b中的位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SparseMatrix&lt;T&gt;::Transpose(SparseMatrix&lt;T&gt;&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 把*this的转置结果送入b中</span></span><br><span class="line">    <span class="comment">// 验证b有足够空间</span></span><br><span class="line">    <span class="keyword">if</span> (terms &gt; b.MaxTerms)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="comment">// 设置转置特征</span></span><br><span class="line">    b.cols = rows;</span><br><span class="line">    b.rows = cols;</span><br><span class="line">    b.terms = terms;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> *ColSize, *RowNext;</span><br><span class="line">    ColSize = <span class="keyword">new</span> <span class="keyword">int</span>[cols + <span class="number">1</span>];</span><br><span class="line">    RowNext = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cols; i++)</span><br><span class="line">        ColSize[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算*this每一列的非0元素数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; terms; i++)</span><br><span class="line">        ColSize[a[i].col]++;</span><br><span class="line">    <span class="comment">// 给出b中每一行的起始点</span></span><br><span class="line">    RowNext[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cols; i++)</span><br><span class="line">        RowNext[i] = RowNext[i - <span class="number">1</span>] + ColSize[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行转置操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; terms; i++)&#123;</span><br><span class="line">        <span class="comment">// 在b中的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = RowNext[a[i].col]++;</span><br><span class="line">        b.a[j].row = a[i].col;</span><br><span class="line">        b.a[j].col = a[i].row;</span><br><span class="line">        b.a[j].value = a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数Tranpose的时间复杂性是$O(cols+terms)$</p>
<h4 id="u77E9_u9635_u76F8_u52A0"><a href="#u77E9_u9635_u76F8_u52A0" class="headerlink" title="矩阵相加"></a>矩阵相加</h4><p>  在两个矩阵相加中使用了函数<code>Append</code>，它把一个非0项添加到一个稀疏矩阵的非0项数组的尾部，其时间复杂性是$\theta(1)$。实现代码如下，然后就是两个矩阵相加的实现函数Add，使用两个游标，分别是*this和矩阵b的游标，通过一个while循环来实现相加。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SparseMatrix&lt;T&gt;::Append(<span class="keyword">const</span> Term&lt;T&gt;&amp; t)&#123;</span><br><span class="line">    <span class="comment">// 把一个非0元素t添加到 *this之中</span></span><br><span class="line">    <span class="keyword">if</span> (terms &gt;= MaxTerms)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    a[terms] = t;</span><br><span class="line">    terms++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SparseMatrix&lt;T&gt;::Add(<span class="keyword">const</span> SparseMatrix&lt;T&gt;&amp; b, SparseMatrix&lt;T&gt;&amp; c)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 计算 c = (*this) + b</span></span><br><span class="line">    <span class="comment">// 验证可行性</span></span><br><span class="line">    <span class="keyword">if</span> (rows != b.rows || cols != b.cols)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    <span class="comment">// 设置结果矩阵c的特征</span></span><br><span class="line">    c.rows = rows;</span><br><span class="line">    c.cols = cols;</span><br><span class="line">    c.terms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义*this 和b 的游标</span></span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>, cb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ct &lt; terms &amp;&amp; cb &lt; b.terms)&#123;</span><br><span class="line">        <span class="comment">// 每一个元素的行主索引</span></span><br><span class="line">        <span class="keyword">int</span> indt = a[ct].row * cols + a[ct].col;</span><br><span class="line">        <span class="keyword">int</span> indb = b.a[cb].row * cols + b.a[cb].col;</span><br><span class="line">        <span class="keyword">if</span> (indt &lt; indb)&#123;</span><br><span class="line">            <span class="comment">// b的元素在后面</span></span><br><span class="line">            c.Append(a[ct]);</span><br><span class="line">            ct++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (indt == indb)&#123;</span><br><span class="line">                <span class="comment">// 位置相同</span></span><br><span class="line">                <span class="keyword">if</span> (a[ct].value + b.a[cb].value)&#123;</span><br><span class="line">                    <span class="comment">// 仅当和不为0时，才添加到c中</span></span><br><span class="line">                    Term&lt;T&gt; t;</span><br><span class="line">                    t.row = a[ct].row;</span><br><span class="line">                    t.col = a[ct].col;</span><br><span class="line">                    t.value = a[ct].value + b.a[cb].value;</span><br><span class="line">                    c.Append(t);</span><br><span class="line">                &#125;</span><br><span class="line">                ct++;</span><br><span class="line">                cb++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// b的元素在前面</span></span><br><span class="line">                c.Append(b.a[cb]);</span><br><span class="line">                cb++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制剩余元素</span></span><br><span class="line">    <span class="keyword">for</span> (; ct &lt; terms; ct++)</span><br><span class="line">        c.Append(a[ct]);</span><br><span class="line">    <span class="keyword">for</span> (; cb &lt; b.terms; cb++)</span><br><span class="line">        c.Append(b.a[cb]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数Add的时间复杂性是$O(terms+b.terms)$。而如果用二维数组来描述每个矩阵，则两个矩阵相加耗时$O(rows<em>cols)$，当<strong>terms+b.terms</strong>远小于**rows</em>cols**时，稀疏矩阵的加法执行效率将大大提高。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><p>  用一维数组来描述稀疏矩阵所存在的缺点是：<strong>当我们创建这个一维数组时，必须知道稀疏矩阵中的非0元素总数。</strong><br>  在我们自定义的类SparseMatrix中，当实际非0元素数目多于估计的初始化一维数组时设定的非0元素数目时，会引发一个异常。还有一种做法是可以分配一个更大的、新的数组，然后复制元素，并删除老的数组，但是这种做法会使得算法效率降低，并且也同样需要估计新数组需要多大的问题。</p>
<p>  因此，这里就如同线性表一样，除了使用数组描述，还有基于指针的描述，也就是<strong>链表描述</strong>。</p>
<h4 id="u63CF_u8FF0"><a href="#u63CF_u8FF0" class="headerlink" title="描述"></a>描述</h4><blockquote>
<p>链表描述的一种可行方案是把每行的非0元素串接在一起，构成一个链表，如下图所示。</p>
</blockquote>
<p>图中每个非阴影节点代表稀疏矩阵中的一个非0元素，它有三个域：col(非0元素所在列号)、value(非0元素的值)和link(指向下一个非阴影节点的指针)。仅当矩阵某行中至少包含一个非0元素才会为该行创建一个链表。在行链表中，每个节点按其col值得升序进行排序。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B52.png" alt="此处输入图片的描述"></p>
<p>  然后再用一个链表将所有的行链表，即图中阴影链表收集在一起。各个阴影节点按其row值得升序排列，每个阴影节点可以被视为一个行链表的头节点，因此阴影链表可以被视为头节点链表。</p>
<h4 id="u94FE_u8868_u8282_u70B9_u7C7B_u578B"><a href="#u94FE_u8868_u8282_u70B9_u7C7B_u578B" class="headerlink" title="链表节点类型"></a>链表节点类型</h4><p>  这里分别定义图中非阴影节点<strong>CNode</strong>和阴影节点<strong>HeadNode</strong>，其代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> LINKMATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LINKMATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"ChainList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> CNode&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> CNode&lt;T&gt;&amp; y)&#123;</span><br><span class="line">        <span class="keyword">return</span> (value != y.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"column = "</span> &lt;&lt; col &lt;&lt; <span class="string">", value= "</span> &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> CNode&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    out &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> HeadNode&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="comment">// 行链表</span></span><br><span class="line">    Chain&lt;CNode&lt;T&gt;&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> HeadNode&lt;T&gt;&amp; y)&#123;</span><br><span class="line">        <span class="keyword">return</span> (row != y.row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"row = "</span> &lt;&lt; row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> HeadNode&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    out &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="u7C7BLinkMatrix"><a href="#u7C7BLinkMatrix" class="headerlink" title="类LinkMatrix"></a>类LinkMatrix</h4><p>  接下来就是定义类LinkMatrix，如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinkMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="comment">// 头节点链表</span></span><br><span class="line">    Chain&lt;HeadNode&lt;T&gt;&gt; a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkMatrix()&#123;&#125;</span><br><span class="line">    ~LinkMatrix()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Transpose</span><span class="params">(LinkMatrix&lt;T&gt;&amp; b)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp; b, LinkMatrix&lt;T&gt;&amp; c)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp;);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="u91CD_u8F7D_26gt_3B_26gt_3B"><a href="#u91CD_u8F7D_26gt_3B_26gt_3B" class="headerlink" title="重载&gt;&gt;"></a>重载&gt;&gt;</h4><p>  重载输入操作符&gt;&gt;。首先是要求输入矩阵的维数以及非0元素的个数。然后输入各个非0元素并把它们收集到各行链表中。用变量H代表当前行链表的头节点，如果下一个非0元素不属于当前行链表，则将当前行链表添加到矩阵x的头节点x.a之中；接下来，H被设置为指向一个新的行链表，同时将刚才那个非0元素添加到这个新的行链表之中。如果新的非0元素属于当前行链表，则只需要简单地把它添加到链表H.a中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; in, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 从输入流中输入矩阵x</span></span><br><span class="line">    <span class="comment">// 删除x中所有节点</span></span><br><span class="line">    x.a.Erase();</span><br><span class="line">    <span class="comment">// 获取矩阵特征</span></span><br><span class="line">    <span class="keyword">int</span> terms;  <span class="comment">// 输入的元素数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter numbers of rows, columns, and terms\n"</span>;</span><br><span class="line">    in &gt;&gt; x.rows &gt;&gt; x.cols &gt;&gt; terms;</span><br><span class="line">    <span class="comment">// 虚设第0行</span></span><br><span class="line">    HeadNode&lt;T&gt; H;  <span class="comment">// 当前行的头节点</span></span><br><span class="line">    H.row = <span class="number">0</span>;              <span class="comment">// 当前行号</span></span><br><span class="line">    <span class="comment">// 输入x的非0元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= terms; i++)&#123;</span><br><span class="line">        <span class="comment">// 输入下一个元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter row, column, and value of term "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">int</span> row, col;</span><br><span class="line">        T value;</span><br><span class="line">        in &gt;&gt; row &gt;&gt; col &gt;&gt; value;</span><br><span class="line">        <span class="comment">// 检查新元素是否属于当前行</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt; H.row)&#123;</span><br><span class="line">            <span class="comment">// 如果不是第0行，则把当前行的头节点H 添加到头节点链表x.a之中</span></span><br><span class="line">            <span class="keyword">if</span> (H.row)</span><br><span class="line">                x.a.Append(H);</span><br><span class="line">            <span class="comment">// 为新的一行准备H</span></span><br><span class="line">            H.row = row;</span><br><span class="line">            <span class="comment">// 置链表头指针first=0</span></span><br><span class="line">            H.a.Zero(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加新元素</span></span><br><span class="line">        CNode&lt;T&gt; *c = <span class="keyword">new</span> CNode&lt;T&gt;;</span><br><span class="line">        c-&gt;col = col;</span><br><span class="line">        c-&gt;value = value;</span><br><span class="line">        H.a.Append(*c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意矩阵的最后一行</span></span><br><span class="line">    <span class="keyword">if</span> (H.row)</span><br><span class="line">        x.a.Append(H);</span><br><span class="line">    H.a.Zero();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u91CD_u8F7D_26lt_3B_26lt_3B"><a href="#u91CD_u8F7D_26lt_3B_26lt_3B" class="headerlink" title="重载&lt;&lt;"></a>重载&lt;&lt;</h4><p>  这里为了输出链表表示的稀疏矩阵，使用了一个链表遍历器依次检查头节点链表中的每个节点。代码的时间复杂性与非0元素的数目呈正比。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> LinkMatrix&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 把矩阵x送至输出流</span></span><br><span class="line">    ChainIterator&lt;HeadNode&lt;T&gt;&gt; p;   <span class="comment">// 头节点遍历器</span></span><br><span class="line">    <span class="comment">// 输出矩阵的维数</span></span><br><span class="line">    out &lt;&lt; <span class="string">"rows = "</span> &lt;&lt; x.rows &lt;&lt; <span class="string">",columns = "</span> &lt;&lt; x.cols &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="comment">// 将h指向第一个头节点</span></span><br><span class="line">    HeadNode&lt;T&gt; *h = p.Initialize(x.a);</span><br><span class="line">    <span class="keyword">if</span> (!h)&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"No non-zero terms\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次输出一行</span></span><br><span class="line">    <span class="keyword">while</span> (h)&#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"row = "</span> &lt;&lt; h-&gt;row &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        out &lt;&lt; h-&gt;a &lt;&lt; <span class="string">"\n"</span>;        <span class="comment">// 输出行链表；</span></span><br><span class="line">        <span class="comment">// 下一个头节点</span></span><br><span class="line">        h = p.Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u51FD_u6570Tranpose"><a href="#u51FD_u6570Tranpose" class="headerlink" title="函数Tranpose"></a>函数Tranpose</h4><p>  对于转置操作，可以采用箱子来从矩阵<em>this中收集位于同一行的非0元素。<em>*bin[i]</em></em>是结果矩阵b中第i行非0元素所对应的链表。其实现如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> LinkMatrix&lt;T&gt;::Transpose(LinkMatrix&lt;T&gt;&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 转置 *this，并把结果放入b</span></span><br><span class="line">    b.a.Erase();</span><br><span class="line">    <span class="comment">// 创建用来收集b中各行元素的箱子</span></span><br><span class="line">    Chain&lt;CNode&lt;T&gt;&gt; *bin;</span><br><span class="line">    bin = <span class="keyword">new</span> Chain&lt;CNode&lt;T&gt;&gt;[cols + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 头节点遍历器</span></span><br><span class="line">    ChainIterator&lt;HeadNode&lt;T&gt;&gt; p;</span><br><span class="line">    <span class="comment">// h 指向*this的第一个头节点</span></span><br><span class="line">    HeadNode&lt;T&gt; *h = p.Initialize(a);</span><br><span class="line">    <span class="comment">// 把*this的元素复制到箱子中</span></span><br><span class="line">    <span class="keyword">while</span> (h)&#123;</span><br><span class="line">        <span class="keyword">int</span> r = h-&gt;row;</span><br><span class="line">        <span class="comment">// 行链表遍历器</span></span><br><span class="line">        ChainIterator&lt;CNode&lt;T&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 将z指向行链表的第一个节点</span></span><br><span class="line">        CNode&lt;T&gt; *z = q.Initialize(h-&gt;a);</span><br><span class="line">        <span class="comment">// 临时节点</span></span><br><span class="line">        CNode&lt;T&gt; x;</span><br><span class="line">        <span class="comment">// *this第r行中的元素变成b中第r列的元素</span></span><br><span class="line">        x.col = r;</span><br><span class="line">        <span class="comment">// 检查*this第r行的所有非0元素</span></span><br><span class="line">        <span class="keyword">while</span> (z)&#123;</span><br><span class="line">            x.value = z-&gt;value;</span><br><span class="line">            bin[z-&gt;col].Append(x);</span><br><span class="line">            z = q.Next();</span><br><span class="line">        &#125;</span><br><span class="line">        h = p.Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置b的维数</span></span><br><span class="line">    b.rows = cols;</span><br><span class="line">    b.cols = rows;</span><br><span class="line">    <span class="comment">// 装配b的头节点链表</span></span><br><span class="line">    HeadNode&lt;T&gt; H;</span><br><span class="line">    <span class="comment">// 搜索箱子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cols; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!bin[i].isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 转置矩阵的第i行</span></span><br><span class="line">            H.row = i;</span><br><span class="line">            H.a = bin[i];</span><br><span class="line">            b.a.Append(H);</span><br><span class="line">            bin[i].Zero();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H.a.Zero();</span><br><span class="line">    <span class="keyword">delete</span>[] bin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中while循环所需要的时间与非0元素的数目呈线性关系，for循环所需要的时间则与输入矩阵的列数呈线性关系，因此总的时间与这两个量的和呈线性关系。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  到这里，第四章数组和矩阵的内容就结束了。本小节主要介绍稀疏矩阵的内容，暂时来说，对于数组描述的掌握是要更好于链表描述的，还需要好好琢磨琢磨，研究一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍稀疏矩阵的内容。这也是本章节最后一节内容。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" cla]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵3-特殊矩阵]]></title>
    <link href="http://ccc013.github.io/2016/07/05/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B53-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/07/05/数组和矩阵3-特殊矩阵/</id>
    <published>2016-07-05T12:06:20.000Z</published>
    <updated>2016-10-24T12:06:38.423Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍几种特殊矩阵的内容。</p>
<h3 id="u5B9A_u4E49_u548C_u5E94_u7528"><a href="#u5B9A_u4E49_u548C_u5E94_u7528" class="headerlink" title="定义和应用"></a>定义和应用</h3><blockquote>
<p>方阵是指具有相同行数和列数的矩阵。</p>
</blockquote>
<p>一些常用的特殊方阵如下：</p>
<blockquote>
<ul>
<li><strong>对角矩阵</strong> $M$是一个对角矩阵，当前仅当$i \neq j$时，有$M(i,j)=0$。如下图a所示</li>
<li><strong>三对角矩阵</strong> $M$是一个三对角矩阵，当前仅当$|i-j| \gt 1$时有$M(i,j)=0$。如下图b所示</li>
<li><strong>下三角矩阵</strong> $M$是一个下三角矩阵，当前仅当$i\lt j$时有$M(i,j)=0$。如下图c所示</li>
<li><strong>上三角矩阵</strong> $M$是一个上三角矩阵，当前仅当$i\gt j$时有$M(i,j)=0$。如下图d所示</li>
<li><strong>对称矩阵</strong> $M$是一个对称矩阵，当前仅当对于所有的$i 和 j$有$M(i,j)=M(j,i)$。如下图e所示</li>
</ul>
</blockquote>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%9F%A9%E9%98%B52.png" alt="此处输入图片的描述"></p>
<h3 id="u5BF9_u89D2_u77E9_u9635"><a href="#u5BF9_u89D2_u77E9_u9635" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>  可以采用<code>T d[n][n]</code>这样的二维数组来描述一个元素类型为T的$n \times n$对角矩阵D。<br>  使用数组元素<code>d[i-1][j-1]</code>来表示矩阵元素<strong>D(i,j)</strong>，这种描述形式所需要的存储空间为$n^2 * sizeof(T)$。</p>
<p>  由于一个对角矩阵最大包含n个非0元素，所以可以采用<code>T d[n]</code>一维数组来描述对角矩阵。其中使用<code>d[i-1]</code>表示矩阵元素<strong>D(i,i)</strong>，而根据对角矩阵的定义，所有未在一维数组中出现的矩阵元素均为0.</p>
<p>  这里使用如下自定义类<strong>DiagonalMatrix</strong>来实现这种描述。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> DIAGONALMATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DIAGONALMATRIX_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> DiagonalMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 矩阵维数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 存储对角元素的一维数组</span></span><br><span class="line">    T *d;       </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiagonalMatrix(<span class="keyword">int</span> size = <span class="number">10</span>): n(size)&#123;</span><br><span class="line">        d = <span class="keyword">new</span> T[n];</span><br><span class="line">    &#125;</span><br><span class="line">    ~DiagonalMatrix()&#123; <span class="keyword">delete</span>[] d; &#125;</span><br><span class="line">    DiagonalMatrix&lt;T&gt;&amp; Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="function">T <span class="title">Retrieve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">DiagonalMatrix&lt;T&gt;&amp; DiagonalMatrix&lt;T&gt;::Store(<span class="keyword">const</span> T&amp;x, <span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">    <span class="comment">// 将x存为D(i,j)</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">if</span> (i != j &amp;&amp; x != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 必须满足对角矩阵的条件：i != j 时，x必须为0</span></span><br><span class="line">        <span class="keyword">throw</span> MustBeZero();</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        d[i - <span class="number">1</span>] = x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T DiagonalMatrix&lt;T&gt;::Retrieve(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        <span class="keyword">return</span> d[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>对于存储和搜索操作，提供了两个不同的函数，而不是使用重载操作符()来完成。此外在存储一个值时，必须保证不会在非对角线位置放置一个非0值；而搜索一个值时，没有必要检查对角线以外的值，因此有必要对这两种情形区别对待。两个函数的复杂性均为$\theta(1)$。</p>
<h3 id="u4E09_u5BF9_u89D2_u77E9_u9635"><a href="#u4E09_u5BF9_u89D2_u77E9_u9635" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h3><p>  在一个$n \times n$三对角矩阵T中，非0元素排列在如下的三条对角线上：</p>
<ol>
<li>主对角线——<strong>i=j</strong></li>
<li>主对角线之下的对角线(称低对角线)——<strong>i=j+1</strong></li>
<li>主对角线之上的对角线(称高对角线)——<strong>i=j-1</strong></li>
</ol>
<p>这三条对角线上的元素总数为<strong>3n-2</strong>，故可以使用一个拥有3n-2个位置的一维数组来描述T。考察上述图b中所示的$4\times 4$三对角矩阵，三条对角线上总共10个元素。如果将其逐行映射到一维数组t中，则有<code>t[0:9]=[2,1,3,1,3,5,2,7,9,0]</code>;如果逐列映射到t中，则有<code>t=[2,3,1,1,5,3,2,9,7,0]</code>;如果按照对角线的次序，从最下面的对角线开始进行映射，则有<code>t=[3,5,9,2,1,2,0,1,3,7]</code>。所以这里有三种不同的方式来进行T到t的映射。<br>下面的程序定义了类<strong>TridiagonalMatrix</strong>,其中采用了对角线映射方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> TridiagonalMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    T *t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TridiagonalMatrix(<span class="keyword">int</span> size = <span class="number">10</span>) : n(size)&#123;</span><br><span class="line">        t = <span class="keyword">new</span> T[<span class="number">3</span> * n - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~TridiagonalMatrix()&#123;<span class="keyword">delete</span>[] t;&#125;</span><br><span class="line">    TridiagonalMatrix&lt;T&gt;&amp; Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="function">T <span class="title">Retrieve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">TridiagonalMatrix&lt;T&gt;&amp; TridiagonalMatrix&lt;T&gt;::Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">    <span class="comment">// 把x存为T(i,j)</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">switch</span> (i-j)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">// 低对角线</span></span><br><span class="line">            t[i - <span class="number">2</span>] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">// 主对角线</span></span><br><span class="line">            t[n - <span class="number">2</span> + i] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">            <span class="comment">// 高对角线</span></span><br><span class="line">            t[<span class="number">2</span> * n - <span class="number">2</span> + i] = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> MustBeZero();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T TridiagonalMatrix&lt;T&gt;::Retrieve(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">switch</span> (i - j)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 低对角线</span></span><br><span class="line">        <span class="keyword">return</span> t[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 主对角线</span></span><br><span class="line">        <span class="keyword">return</span> t[n - <span class="number">2</span> + i];</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 高对角线</span></span><br><span class="line">        <span class="keyword">return</span> t[<span class="number">2</span> * n - <span class="number">2</span> + i];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先是从最下面的对角线开始，也就是低对角线，那么T(i,j)对应的一维数组是t[i-2]，接着轮到主对角线的时候，只需要用i加上低对角线的元素总数，即n-2个，也就是对应数组t[n-2+i]，因为i是依次从1，按行逐渐增加；最后对于高对角线，也是同样的计算方法。</p>
<h3 id="u4E09_u89D2_u77E9_u9635"><a href="#u4E09_u89D2_u77E9_u9635" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>  在三角矩阵中，无论是上三角还是下三角矩阵，非0元素总数均为$\frac{n(n+1)}{2}$。</p>
<p>  两种三角矩阵都可以用一个大小为$\frac{n(n+1)}{2}$的一维数组进行描述。考虑把一个下三角矩阵映射到一个一维数组$l$，可以采用按行和按列两种不同的方式进行映射。如果按行映射，上图c中$4\times 4$下三角矩阵可以得到$l[0:9] = (2,5,1,0,3,1,4,2,7,0)$;若按列的方式，得到$l[0:9] =(2,5,0,4,1,3,2,1,7,0)$。</p>
<p>  所以对于下三角矩阵中的一个元素$L(i,j)$，如果$i\lt j$,则$L(i,j)=0$;如果$i\le j$，则$L(i,j)$位于非0元素区域，且其对应的一维数组是<strong>t[$\frac{i(i-1)}{2}+j-1$]</strong>，其映射规则是先统计前i-1行的非0元素数量然后加上当前元素所在第i行的所在列数j-1。下面给出自定义类<strong>LowerMatrix</strong>实现下三角矩阵,并且是按行来映射。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LowerMatrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 矩阵维数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 存储对角元素的一维数组</span></span><br><span class="line">    T *t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LowerMatrix(<span class="keyword">int</span> size = <span class="number">10</span>) : n(size)&#123;</span><br><span class="line">        t = <span class="keyword">new</span> T[n*(n+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~LowerMatrix()&#123; <span class="keyword">delete</span>[] t; &#125;</span><br><span class="line">    LowerMatrix&lt;T&gt;&amp; Store(<span class="keyword">const</span> T&amp; x, <span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="function">T <span class="title">Retrieve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LowerMatrix&lt;T&gt;&amp; LowerMatrix&lt;T&gt;::Store(<span class="keyword">const</span> T&amp;x, <span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">    <span class="comment">// 将x存为D(i,j)</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="comment">// 当前仅当 i &gt;= j时，(i,j)位于下三角</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">        t[i*(i - <span class="number">1</span>) / <span class="number">2</span> + j - <span class="number">1</span>] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> MustBeZero();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T LowerMatrix&lt;T&gt;::Retrieve(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span> || i&gt;n || j&gt;n)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">        <span class="keyword">return</span> t[i*(i - <span class="number">1</span>) / <span class="number">2</span> + j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上三角矩阵的实现方式也是相同的，只需要改变判断条件，将$i \ge j$变成$i \le j$即可。</p>
<h3 id="u5BF9_u79F0_u77E9_u9635"><a href="#u5BF9_u79F0_u77E9_u9635" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>  一个$n\times n$的对称矩阵可以用一个大小为$\frac{n(n+1)}{2}$的一维数组来描述，可参考三角矩阵的存储模式来存储矩阵的上三角或下三角，即可以根据已经存储的元素来推算出未存储的元素。即如果存储下三角的元素，当需要给出在上三角的元素，只需要将行和列对调，再来搜索即可得到需要的元素值，这样做可以更节省空间。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节主要是介绍几种特殊矩阵，都是属于方阵，分别是三角矩阵，三对角矩阵，上三角和下三角矩阵以及对称矩阵，并且都自定义类来实现这几种特殊的矩阵。</p>
<p>  更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍几种特殊矩阵的内容。</p>
<h3 id="u5B9A_u4E49_u548C_u5E94_u7528"><a href="#u5B9A_u4E49_u548C_u5E94_u7528" cl]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵2-矩阵]]></title>
    <link href="http://ccc013.github.io/2016/06/30/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B52-%E7%9F%A9%E9%98%B5/"/>
    <id>http://ccc013.github.io/2016/06/30/数组和矩阵2-矩阵/</id>
    <published>2016-06-30T11:29:36.000Z</published>
    <updated>2016-10-24T12:06:02.844Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍矩阵的基本概念以及自定义一个类Matrix实现基本的矩阵操作。</p>
<h3 id="u77E9_u9635"><a href="#u77E9_u9635" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="u5B9A_u4E49_u548C_u64CD_u4F5C"><a href="#u5B9A_u4E49_u548C_u64CD_u4F5C" class="headerlink" title="定义和操作"></a>定义和操作</h4><p>  一个$m\times n$的矩阵(matrix)是一个m行、n列的表，如下图所示，其中m和n是矩阵的维数。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%9F%A9%E9%98%B51.png" alt="此处输入图片的描述"></p>
<p>对于矩阵来说，最常见的操作就是矩阵转置、矩阵加和矩阵乘。</p>
<p>一个$m\times n$矩阵的转置矩阵是一个$n\times m$的矩阵$M^T$,它与$M$之间存在以下关系：<br>$$<br>M^T(i,j) = M(j,i)\quad 1\le i\le n,\; 1\le j\le m<br>$$</p>
<p>仅当两个矩阵的维数相同时，即具有相同的行数和列数，才可以对两个矩阵求和。两个$m\times n$矩阵$A和B$相加所得到的$m\times n$矩阵$C$如下：<br>$$<br>C(i,j) =A(i,j)+B(i,j)\quad 1\le i\le n,\; 1\le j\le m<br>$$</p>
<p>仅当一个$m\times n$矩阵$A$的列数与另一个$q\times p$矩阵$B$的行数相同，即<strong>n=q</strong>,才可以执行矩阵乘法$A<em>B$。其得到的$m\times p$矩阵$C$满足以下关系：<br>$$<br>C(i,j) = \sum_{k=1}^nA(i,k)\ </em>\ B(k,j)\quad 1\le i\le m,\; 1\le j\le p<br>$$</p>
<p>矩阵加的代码实现如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">( T **a, T **b, T **c, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 矩阵 a 和 b 相加得到矩阵 c .</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">             c[i][j] = a[i][j] + b[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵转置代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transpose</span><span class="params">(T **a, <span class="keyword">int</span> rows)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 对矩阵 a[0:rows-1][0:rows-1] 进行转置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; rows; j++)</span><br><span class="line">            Swap(a[i][j], a[j][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵乘法的代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mult</span><span class="params">(T **a, T **b, T **c, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// m x n 矩阵 a 与 n x p 矩阵 b相乘得到c</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++) &#123;</span><br><span class="line">            T sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                sum += a[i][k] * b[k][j];</span><br><span class="line">            c[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u7C7BMatrix"><a href="#u7C7BMatrix" class="headerlink" title="类Matrix"></a>类Matrix</h4><p>  这里自定义一个类Matrix来实现矩阵的功能，在该类中，使用<strong>()</strong>来指定每个元素，并且各行和各列的索引值都是从1开始的。<br>  其类定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> MATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MATRIX_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="comment">// 元素数组</span></span><br><span class="line">    T *element; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Matrix(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    Matrix(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m);</span><br><span class="line">    ~Matrix()&#123; <span class="keyword">delete</span>[] element; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rows</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> rows; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Columns</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> cols; &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>;</span><br><span class="line">    Matrix&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m);</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>+() <span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>;</span><br><span class="line">    Matrix&lt;T&gt;&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp; m);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>构造函数，复制构造函数以及赋值运算符的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;::Matrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    <span class="keyword">if</span> ((!r || !c) &amp;&amp; (r || c))</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    rows = r;</span><br><span class="line">    cols = c;</span><br><span class="line">    element = <span class="keyword">new</span> T[r*c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;::Matrix(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    rows = m.rows;</span><br><span class="line">    cols = m.cols;</span><br><span class="line">    element = <span class="keyword">new</span> T[rows*cols];</span><br><span class="line">    <span class="keyword">int</span> size = rows * cols;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        element[i] = m.element[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)&#123;</span><br><span class="line">    <span class="comment">// 重载赋值运算符=</span></span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span> != &amp;m)&#123;</span><br><span class="line">        rows = m.rows;</span><br><span class="line">        cols = m.cols;</span><br><span class="line">        <span class="keyword">delete</span>[] element;</span><br><span class="line">        element = <span class="keyword">new</span> T[rows*cols];</span><br><span class="line">        <span class="keyword">int</span> size = rows * cols;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            element[i] = m.element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了重载矩阵下标操作法(),使用了C++的函数操作符()，与数组的下标操作法[]不同的是，该操作符可以带任意数量的参数。对于一个矩阵来说，需要两个整数参数。如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T&amp; Matrix&lt;T&gt;::<span class="keyword">operator</span>()(<span class="keyword">int</span> i, <span class="keyword">int</span> j)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个指向元素(i,j)的引用</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;rows || j&lt;<span class="number">1</span> || j&gt;cols)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">return</span> element[(i - <span class="number">1</span>)*cols + j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二元减法的代码如下，矩阵加法操作符，一元减法操作符，增值操作符和输出操作符的代码都比较类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt; Matrix&lt;T&gt;::<span class="keyword">operator</span>-(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rows != m.rows || cols != m.cols)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    Matrix&lt;T&gt; w(rows, cols);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++)&#123;</span><br><span class="line">        w.element[i] = element[i] - m.element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵乘法实现如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt; Matrix&lt;T&gt;::<span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&lt;T&gt;&amp; m)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 矩阵乘法 返回w = (*this) * m</span></span><br><span class="line">    <span class="keyword">if</span> (cols != m.rows)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    Matrix&lt;T&gt; w(rows, m.cols);</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>, cm = <span class="number">0</span>, cw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++)&#123;</span><br><span class="line">        <span class="comment">// 计算出结果的第i行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m.cols; j++)&#123;</span><br><span class="line">            <span class="comment">// 计算w(i,j)的第一项</span></span><br><span class="line">            T sum = element[ct] * m.element[cm];</span><br><span class="line">            <span class="comment">// 累加其余项</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= cols; k++)&#123;</span><br><span class="line">                <span class="comment">// 指向*this第i行的下一个元素</span></span><br><span class="line">                ct++;</span><br><span class="line">                <span class="comment">// 指向m的第j列的下一项</span></span><br><span class="line">                cm += m.cols;</span><br><span class="line">                sum += element[ct] * m.element[cm];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存w(i,j)</span></span><br><span class="line">            w.element[cw++] = sum;</span><br><span class="line">            <span class="comment">// 重新调整至行首和下一列</span></span><br><span class="line">            ct -= cols - <span class="number">1</span>;</span><br><span class="line">            cm = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新调整至下一行的行首和第一列</span></span><br><span class="line">        ct += cols;</span><br><span class="line">        cm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a></p>
<h5 id="u590D_u6742_u6027"><a href="#u590D_u6742_u6027" class="headerlink" title="复杂性"></a>复杂性</h5><p>  当T是一个内部数据类型时，矩阵构造函数复杂性是$O(1)$，当T是一个用户自定义类时，构造函数的复杂性是$O(rows<em>cols)$，下标操作符的复杂性是$\theta(1)$,乘法操作符的复杂性是$O(rows</em>cols*m.cols)$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍矩阵的基本概念以及自定义一个类Matrix实现基本的矩阵操作。</p>
<h3 id="u77E9_u9635"><a href="#u77E9_u9635" class="headerlink]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组和矩阵1--数组]]></title>
    <link href="http://ccc013.github.io/2016/06/28/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B51-%E6%95%B0%E7%BB%84/"/>
    <id>http://ccc013.github.io/2016/06/28/数组和矩阵1-数组/</id>
    <published>2016-06-28T06:55:14.000Z</published>
    <updated>2016-10-24T12:04:16.134Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍数组的内容。</p>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><h4 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><blockquote>
<p>数据对象<strong>array</strong>的每个实例都是形如<strong>(index, value)</strong>的数据对集合，其中任意两对数据的<strong>index</strong>值都各不相同。</p>
</blockquote>
<p>数组的抽象数据类型描述如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 Array&#123;</span><br><span class="line">实例</span><br><span class="line">    形如 (index , value)的数据对集合，其中任意两对数据的 index 值都各不相同</span><br><span class="line">操作</span><br><span class="line">   Create()：创建一个空的数组</span><br><span class="line">   Store(index, value)：添加数据(index, value)，同时删除具有相同index值的数据对（如果存在）</span><br><span class="line">   Retrieve(index)：返回索引值为 index的数据对</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C++_u6570_u7EC4"><a href="#C++_u6570_u7EC4" class="headerlink" title="C++数组"></a>C++数组</h4><p> 在C++中数组是一个标准的数据结构，但C++数组的索引(也称为下标)必须采用如下形式：$[i_1][i_2][i_3]\ldots [i_k]$.<br> $i_j$是一个非负整数，如果k为1，则数组是一个一维数组，如果k是2，则是二维数组。$i_1$是索引的第一个坐标，$i_2$是第二个，$i_k$是第k个。在C++中，值为整数类型的k维数组<code>score</code>可用如下语句来创建：<br>$$<br>int\; \; score[u_1][u_2][u_2]\ldots [u_k]<br>$$<br>该数组最大可用容纳$n = u_1u_2u_2\ldots u_k$个值。由于数组是存储int类型的整数，所以每个元素需要<code>sizeof(int)</code>个字节，因此，整个数组所需要的存储空间为<strong>sizeof(score) = n * sizeof(int)</strong>个字节。C++编译器将为数组预留这么多空间。加入预留空间的起始地址为<code>start</code>，则该空间将延伸至<code>start+sizeof(score)-1</code>。</p>
<h4 id="u884C_u4E3B_u6620_u5C04_u548C_u5217_u4E3B_u6620_u5C04"><a href="#u884C_u4E3B_u6620_u5C04_u548C_u5217_u4E3B_u6620_u5C04" class="headerlink" title="行主映射和列主映射"></a>行主映射和列主映射</h4><p>为了实现与数组相关的函数<code>Store</code>和<code>Retrieve</code>，必须确定<strong>索引值</strong>在<strong>[start,start+sizeof(score)-1]</strong>中的相应位置。实际上就是把数组索引$[i_1][i_2][i_3]\ldots [i_k]$映射到<code>[0,n-1]</code>中的某个数$map(i_1,i_2,i_3,\ldots ,i_k)$,使得该索引所对应的元素值存储在以下位置$start+map(i_1,i_2,i_3,\ldots ,i_k)*sizeof(int)$。</p>
<p>当数组维数是1时，即k=1，使用以下函数：$map(i_1) = i_1$</p>
<p>当数组维数是2时，各索引可按下图所示的表格形式进行排列。第一个坐标相同的位于同一行，第二个坐标相同的索引位于同一列。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%841.png" alt="此处输入图片的描述"><br>对上图从第一行开始，依次对每一行中的每个索引从左至右进行连续编号，即可得到下图a所示的映射结果。<strong>这种把二维数组中的位置映射为[0,n-1]中某个数的方式被称为行主映射</strong>。C++中即采用了这种行主映射模式。而下图b则给出了另一种模式，称为列主映射。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%842.png" alt="此处输入图片的描述"></p>
<p>行主映射中所对应的映射函数为：$map(i_1,i_2) = i_1 * u_2 + i_2$</p>
<p>其中$u_2$是数组的列数。这里的$i_1,i_2$都是从0开始。</p>
<p>根据上述的行主映射模式可以得到二维以上的映射函数。比如对于三维数组，其行主映射函数为$map(i_1,i_2,i_3) = i_1u_2u_3+i_2u_3+i_3$</p>
<p>对于k维数组，其行主映射函数为$map(i_1,i_2,i_3,\ldots ,i_k) = i_1u_2u_3\ldots u_k + i_2u_3\ldots u<em>k+\dots+i</em>{k-1}u_k+i_k$</p>
<h4 id="u7C7BArray1D"><a href="#u7C7BArray1D" class="headerlink" title="类Array1D"></a>类Array1D</h4><p>C++中虽然支持一维数组，但是这种支持还不够，比如不能使用超出正常范围之外的索引值，如索引值必须都是正整数，不能使用负数。</p>
<p>为了克服这些不足，定义了类Array1D,代码如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> ARRAY1D_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ARRAY1D_H_</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Array1D&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    T *element;     <span class="comment">// 一维数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array1D(<span class="keyword">int</span> size = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    Array1D(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; x);   </span><br><span class="line">    ~Array1D()&#123; <span class="keyword">delete</span>[] element; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    Array1D&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v);</span><br><span class="line">    <span class="comment">// 一元加法操作符</span></span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>+()<span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// 一元减法操作法</span></span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array1D&lt;T&gt;&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>该类每个实例X都是一个一维数组。X的元素都存储在数组<code>X.element</code>中，第i个元素为于<code>X.element[i]</code>，$0 \le i \lt size$。</p>
<p>这个类的共享成员包括: 构造函数，复制构造函数，析构函数，下标操作法[]，返回数组大小的函数Size，算术操作符+、-、*和+=。下面首先是给出构造函数和复制构造函数的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;::Array1D(<span class="keyword">int</span> sz)&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    size = sz;</span><br><span class="line">    element = <span class="keyword">new</span> T[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;::Array1D(<span class="keyword">const</span> Array1D&lt;T&gt;&amp; v)&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    size = v.size;</span><br><span class="line">    element = <span class="keyword">new</span> T[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        element[i] = v.element[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出重载操作符[]的代码，该操作符用来返回指向第i个元素的引用，可以使存储和查询操作很自然干的方式进行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T&amp; Array1D&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回第i个元素的引用</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">return</span> element[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来给出赋值操作符的代码。首先需要避免进行自我赋值，然后需要先释放目标数组<code>*this</code>所占用的空间，然后再分配一个新的空间，并进行赋值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;&amp; Array1D&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array1D&lt;T&gt;&amp;ｖ)&#123;</span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;v)&#123;</span><br><span class="line">        <span class="comment">// 不是自我赋值</span></span><br><span class="line">        size = v.size;</span><br><span class="line">        <span class="keyword">delete</span>[] element;</span><br><span class="line">        element = <span class="keyword">new</span> T[size];</span><br><span class="line">        <span class="comment">// 复制元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            element[i] = v.element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当<code>T</code>是一个内部C++数据类型(如int，float和char)时，构造函数和析构函数的复杂性是$\theta(1)$,而当T是一个用户自定义的类时，构造函数和析构函数的复杂性是$O(size)$。存在这种差异的原因是：<strong>当T是一个用户自定义类时，在用new(delete)创建(删除)数组element的过程中，对于element的每个元素都要调用一次T的构造函数(析构函数)。</strong>下标操作法[]的复杂性是$\theta(1)$,其他操作符的复杂性均为$O(size)$（注意复杂性不会是$\theta(size)$，因为所有操作符的代码都可以引发一个异常并提前终止）。</p>
<p>下面给出测试的代码及结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testArray1D</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; b(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        a[i] = i * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a is \n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b=a, so b is \n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= a+b,so c :\n"</span>;</span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; c(<span class="number">10</span>);</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; d(<span class="number">10</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a*c = \n"</span>;</span><br><span class="line">    d = a*c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Array1D&lt;<span class="keyword">int</span>&gt; e(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c-b = \n"</span>;</span><br><span class="line">    e = c - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%95%B0%E7%BB%843.png" alt="此处输入图片的描述"></p>
<p>完整例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/ArrayAndMatrix" target="_blank" rel="external">Github</a>.</p>
<h4 id="u7C7BArray2D"><a href="#u7C7BArray2D" class="headerlink" title="类Array2D"></a>类Array2D</h4><p>对于二维数组，可以定义一个类Array2D。程序如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> ARRAY2D_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ARRAY2D_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Array2D&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols; <span class="comment">// 数组维数</span></span><br><span class="line">    Array1D&lt;T&gt; *row;        <span class="comment">// 一维数组的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array2D(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>);</span><br><span class="line">    Array2D(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; m);</span><br><span class="line">    ~Array2D() &#123; <span class="keyword">delete</span>[] row; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rows</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> rows; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Columns</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> cols; &#125;</span><br><span class="line">    Array1D&lt;T&gt; &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v);</span><br><span class="line">    <span class="comment">// 一元加法操作符</span></span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>+()<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// 一元减法操作法</span></span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>-() <span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; v)<span class="keyword">const</span>;</span><br><span class="line">    Array2D&lt;T&gt;&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp; x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>在定义中使用一维数组<code>row</code>来存储每个行数组。</p>
<p>下面给出构造函数实现的代码，其中的方法<code>Resize</code>是<code>Array1D</code>新增加的一个成员函数，其实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array1D&lt;T&gt;&amp; Array1D&lt;T&gt;::Resize(<span class="keyword">int</span> sz)&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] element;</span><br><span class="line">    size = sz;</span><br><span class="line">    element = <span class="keyword">new</span> T[sz];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array2D&lt;T&gt;::Array2D(<span class="keyword">int</span> r, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    <span class="keyword">if</span> ((!r || !c) &amp;&amp; (r || c))</span><br><span class="line">        <span class="keyword">throw</span> BadInitializers();</span><br><span class="line">    rows = r;</span><br><span class="line">    cols = c;</span><br><span class="line">    row = <span class="keyword">new</span> Array1D&lt;T&gt;[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        row[i].Resize(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面则是给出复制构造函数的实现，复制构造函数首先会创建一个具有给定位置数的数组<code>row</code>，然后利用一维数组的赋值操作符复制二维数组中的每一行数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array2D&lt;T&gt;::Array2D(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; m)&#123;</span><br><span class="line">    rows = m.rows;</span><br><span class="line">    cols = m.cols;</span><br><span class="line">    <span class="comment">// 分配指向一维数组的数组</span></span><br><span class="line">    row = <span class="keyword">new</span> Array1D&lt;T&gt;[rows];</span><br><span class="line">    <span class="comment">// 复制每一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        row[i] = m.row[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>乘法操作符的实现类似于矩阵乘，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵乘</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Array2D&lt;T&gt; Array2D&lt;T&gt;::<span class="keyword">operator</span>*(<span class="keyword">const</span> Array2D&lt;T&gt;&amp; m)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cols != m.cols)</span><br><span class="line">        <span class="keyword">throw</span> SizeMismatch();</span><br><span class="line">    Array2D&lt;T&gt; w(rows, m.cols);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m.cols; j++)&#123;</span><br><span class="line">                T sum = (*<span class="keyword">this</span>)[i][<span class="number">0</span>] * m[<span class="number">0</span>][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; cols; k++)</span><br><span class="line">                    sum += (*<span class="keyword">this</span>)[i][k] * m[k][j];</span><br><span class="line">                w[i][j] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节介绍了数组，并自定义了一个一维数组类<code>Array1D</code>以及二维数组类<code>Array2D</code>。</p>
<p>  虽然是增加了不少方法，但是感觉用起来是没有C++的数组那么方便。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》，第四章数组和矩阵的笔记。本小节介绍数组的内容。</p>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据描述3-间接寻址&模拟指针]]></title>
    <link href="http://ccc013.github.io/2016/06/16/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B03-%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80-%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%88/"/>
    <id>http://ccc013.github.io/2016/06/16/数据描述3-间接寻址-模拟指针/</id>
    <published>2016-06-16T12:15:33.000Z</published>
    <updated>2016-10-20T08:13:52.758Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节讲述间接寻址和模拟指针的内容。</p>
<h3 id="u95F4_u63A5_u5BFB_u5740"><a href="#u95F4_u63A5_u5BFB_u5740" class="headerlink" title="间接寻址"></a>间接寻址</h3><h4 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>间接寻址(indirect addressing)是公式化描述和链表描述的组合。</p>
</blockquote>
<p>采用这种描述方法，可以保留公式化描述的优点–<strong>可以根据索引在$\theta(1)$的时间内访问每个元素，可采用二叉搜索方法在对数时间内对一个有序表进行搜索等等</strong>。同时，也可以获得链表描述方法的重要特色–<strong>在诸如插入和删除操作期间不必对元素进行实际的移动</strong>，因此大多数间接寻址链表操作的时间复杂性都与元素的总数无关。<br>  间接寻址中，使用一个指针表来跟踪每个元素。元素本身可能存储在动态分配的节点或者节点数组之中。下图给出一个采用间接寻址表table描述的5元素线性表。其中table[i]是一个指针，它指向表中的第i+1个元素，length是表的长度。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%801.png" alt="此处输入图片的描述"></p>
<p>间接寻址方法和链表描述方法都使用了指针域。在链表方式中，指针位于每个节点中，而在间接寻址方式中，指针完全放在数组<code>table</code>中。<br>下面给出了类定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> INDRECTLIST_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> INDRECTLIST_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> IndrectList&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T **table;      <span class="comment">// 一维T类型指针数组</span></span><br><span class="line">    <span class="keyword">int</span> length, MaxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IndrectList(<span class="keyword">int</span> MaxListSize = <span class="number">10</span>);</span><br><span class="line">    ~IndrectList();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> length == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> k, T&amp;x)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span><span class="keyword">const</span></span>;</span><br><span class="line">    IndrectList&lt;T&gt;&amp; Delete(<span class="keyword">int</span> k, T&amp; x);</span><br><span class="line">    IndrectList&lt;T&gt;&amp; Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  下面给出构造函数和析构函数的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">IndrectList&lt;T&gt;::IndrectList(<span class="keyword">int</span> MaxListSize)&#123;</span><br><span class="line">    MaxSize = MaxListSize;</span><br><span class="line">    table = <span class="keyword">new</span> T *[MaxSize];</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">IndrectList&lt;T&gt;::~IndrectList()&#123;</span><br><span class="line">    <span class="comment">// 删除表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="keyword">delete</span> table[i];</span><br><span class="line">    <span class="keyword">delete</span>[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>Length</code>和<code>IsEmpty</code>都已经被定义为内联函数。假设$1\le k \le length$,第k个元素可以由<code>table[k-1]</code>之后的下一个指针指出，对<code>x</code>进行搜索可以通过依次检查指针<code>table[0]、table\[1]、...</code>所指向的元素。下面给出<code>Find和Search</code>函数的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> IndrectList&lt;T&gt;::Find(<span class="keyword">int</span> k, T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;<span class="number">1</span> || k&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = *table[k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> IndrectList&lt;T&gt;::Search(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回x所处位置，如果没有则返回0；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*table[i] == x)</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除操作需要移动要删除的元素后面的指针，相对于公式化操作中需要移动的是表中的元素。删除操作实现如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">IndrectList&lt;T&gt;&amp; IndrectList&lt;T&gt;::Delete(<span class="keyword">int</span> k, T&amp;x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (Find(k, x))&#123;</span><br><span class="line">        <span class="comment">// 向前移动指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; length; i++)</span><br><span class="line">            table[i - <span class="number">1</span>] = table[i];</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述实现中，首先是借助<code>Find</code>函数寻找到需要删除的第k个元素，然后将第k个元素开始的所有指针都往前移动一位。</p>
<p>插入操作和删除操作相反，需要将指针往后移动，实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">IndrectList&lt;T&gt;&amp; IndrectList&lt;T&gt;::Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;<span class="number">0</span> || k&gt;length)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="keyword">if</span> (length == MaxSize)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="comment">// 向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= k; i--)</span><br><span class="line">        table[i + <span class="number">1</span>] = table[i];</span><br><span class="line">    table[k] = <span class="keyword">new</span> T;</span><br><span class="line">    *table[k] = x;</span><br><span class="line">    length++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入操作在最坏情况下的时间复杂性是$O(length)$,而对于公式化操作，其最坏情况下的时间复杂性是$O(s<em>length)$,其中<em>*s</em></em>是一个T类型的元素的大小。</p>
<p>更完整的例子可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/IndirectList.h" target="_blank" rel="external">github</a></p>
<h3 id="u6A21_u62DF_u6307_u9488"><a href="#u6A21_u62DF_u6307_u9488" class="headerlink" title="模拟指针"></a>模拟指针</h3><p>  在大多数应用中，可以利用动态分配及C++指针来实现链表和间接寻址表。不过有时候，可以采用一个节点数组以及对该数组进行索引的模拟指针，可以使设计更方便、更高效。</p>
<p>  假设采用一个数组node，该数组的每个元素都包含两个域：<strong>data和link</strong>。数组中的节点分别是<code>node[0]、node[1]、...、node[NumberOfNodes - 1]</code>。下面用<strong>节点i</strong>来代表<strong>node[i]</strong>。如果一个单向链表<strong>c</strong>由节点10，5和24按顺序构成，那么将得到<strong>c=10</strong>（指向链表<strong>c</strong>的第一个节点的指针是整数类型)，<code>node[10].link = 5</code>（指向第二个节点的指针），<code>node[5].link = 24，node[24].link=-1(表示节点24是链表中的最后一个节点)</code>。该链表如下图所示：<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%881.png" alt="此处输入图片的描述"></p>
<p>  为了实现指针的模拟，需要设计一个过程来分配和释放一个节点。当前未被使用的节点将被放入一个存储池之中。开始时，存储池中包含了所有节点<code>node[0:NumberOfNodes-1]</code>。<strong>Allocate</strong>从存储池中取出节点，每次取出一个。而<strong>Deallocate</strong>则将节点放入存储池中，每次放入一个。因此<strong>Allocate和Deallocate</strong>分别对存储池执行插入和删除操作，等价于C++函数的new和delete。如果存储池是一个节点链表，如下所示，这两个函数就可以高效地执行。用作存储池的链表被称之为<strong>可用空间表</strong>，其中包含了当前未使用的所有节点。<strong>first</strong>是一个类型为int的变量，它指向可用空间表的第一个节点，添加和删除操作都是在可用空间表的前部进行的。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%882.png" alt="此处输入图片的描述"></p>
<p>  代码实现如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> SIMPOINTER_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SIMPOINTER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> SimNode&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">int</span> link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> SimSpace&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> NumberOfNodes, first;</span><br><span class="line">    SimNode&lt;T&gt;*node;    <span class="comment">// 节点数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SimSpace(<span class="keyword">int</span> MaxSpaceSize = <span class="number">100</span>);</span><br><span class="line">    ~SimSpace()&#123; <span class="keyword">delete</span>[] node; &#125;</span><br><span class="line">    <span class="comment">// 分配一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Allocate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 释放节点i</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deallocate</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>  上述就是节点数组以及可用空间表的代码实现。</p>
<h4 id="SimSpace_u7684_u64CD_u4F5C"><a href="#SimSpace_u7684_u64CD_u4F5C" class="headerlink" title="SimSpace的操作"></a>SimSpace的操作</h4><p>  由于所有节点初始时都是自由的，因此在刚被创建的时候，可用空间表中包含<code>NumberOfNodes</code>个节点。代码实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">SimSpace&lt;T&gt;::SimSpace(<span class="keyword">int</span> MaxSpaceSize)&#123;</span><br><span class="line">    NumberOfNodes = MaxSpaceSize;</span><br><span class="line">    node = <span class="keyword">new</span> SimNode&lt;T&gt;[NumberOfNodes];</span><br><span class="line">    <span class="comment">// 初始化可用空间表，创建一个节点链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfNodes-<span class="number">1</span>; i++)</span><br><span class="line">        node[i].link = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 链表的最后一个节点</span></span><br><span class="line">    node[NumberOfNodes - <span class="number">1</span>].link = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 链表的第一个节点</span></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> SimSpace&lt;T&gt;::Allocate()&#123;</span><br><span class="line">    <span class="comment">// 分配一个自由节点</span></span><br><span class="line">    <span class="keyword">if</span> (first == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="keyword">int</span> i = first;</span><br><span class="line">    first = node[i].link;    <span class="comment">// first 指向下一个自由节点</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SimSpace&lt;T&gt;::Deallocate(<span class="keyword">int</span> &amp; i)&#123;</span><br><span class="line">    <span class="comment">// 释放节点</span></span><br><span class="line">    <span class="comment">// 使i成为可用空间表的第一个节点</span></span><br><span class="line">    node[i].link = first;</span><br><span class="line">    first = i;</span><br><span class="line">    i = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面三个函数的时间复杂性分别是$\theta(NumberOfNodes),\theta(1),\theta(1)$。</p>
<p>通过使用两个可用空间表，可用减少构造函数的运行时间，其中第一个表包含所有尚未被使用的自由节点，第二个表包含所有已被至少使用过一次的自由节点。每当一个节点被释放时，就被放入第二个表中。当需要一个新节点时，如果第二个表非空，则从该表中取出一个节点，否则从第一个表中取出一个节点。令<strong>first1</strong>和<strong>first2</strong>分别指向第一个表和第二个表的首节点。<br>基于上述分配节点的方式，第一个表中的元素是<code>node[i]</code>，其中$first1 \le i \lt NumberOfNodes$。释放节点的代码与上述代码中<code>Deallocate</code>方法的唯一区别是所有<strong>first</strong>变量均替换成<strong>first2</strong>。新的构造函数和分配函数如下所示。为了使新函数能正常工作，需要把整型变量<strong>first1</strong>和<strong>first2</strong>设置为<strong>SimSpace</strong>的私有成员变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">SimSpace&lt;T&gt;::SimSpace(<span class="keyword">int</span> MaxSpaceSize)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 使用两个可用空间表的构造函数</span></span><br><span class="line">    NumberOfNodes = MaxSpaceSize;</span><br><span class="line">    node = <span class="keyword">new</span> SimNode&lt;T&gt; [NumberOfNodes];</span><br><span class="line">    <span class="comment">// 初始化可用空间表</span></span><br><span class="line">    firstl = <span class="number">0</span>;</span><br><span class="line">    first2 = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> SimSpace&lt;T&gt;::Allocate()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 分配一个自由节点</span></span><br><span class="line">    <span class="keyword">if</span> (first2 == -<span class="number">1</span>) &#123;<span class="comment">// 第2个表为空</span></span><br><span class="line">    <span class="keyword">if</span> (firstl == NumberOfNodes) <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="keyword">return</span> firstl++;&#125;</span><br><span class="line">    <span class="comment">// 分配链表中的第一个节点</span></span><br><span class="line">    <span class="keyword">int</span> i = first2;</span><br><span class="line">    first2 = node[i].link;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83"><a href="#u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83" class="headerlink" title="描述方法的比较"></a>描述方法的比较</h3><p>  下图给出了本章四种数据描述方法执行各种链表操作所需要的时间复杂性。表中，<strong>s</strong>和<strong>n</strong>分别表示<strong>sizeof(T)</strong>和链表长度。由于采用C++指针和采用模拟指针完成这些操作所需要的时间复杂性完全相同，因此表中把这两种情形的时间复杂性合并在一行中进行描述。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%883.png" alt="此处输入图片的描述"></p>
<p>  有上述表格以及前面所学的知识可以得到以下结论：</p>
<ol>
<li>使用间接寻址与使用链表描述所需要的空间大致相同，二者都比使用公式化描述所需要的空间更多。</li>
<li>链表描述和间接寻址，在执行链表的插入和删除操作所需要的时间复杂性都与链表元素本身的大小无关；相反，使用公式化描述时，插入和删除操作的复杂性与元素的本身大小呈<strong>线性关系</strong>。</li>
<li>公式化描述和间接寻址，在确定表的长度以及访问表中第k个元素所需要的时间复杂性均为$\theta(1)$;而使用链表描述，这两种操作的时间复杂性分别是$\theta(length)$和$O(k)$。</li>
<li>间接寻址比较适合这样的应用：表元素本身很大，较频繁地进行插入、删除操作以及确定表的长度、访问第k个元素。</li>
<li>如果线性表本身已经按序排列，那么使用公式化描述或间接寻址进行搜索所需要时间均为$O(logn)$,而使用链表描述时，所需要的时间是$O(n)$.</li>
</ol>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本小节介绍了间接寻址和模拟指针两种实现线性表的方法。间接寻址还是可以理解的，实际上就是综合了公式化描述和链表描述的特点，指向数据元素的指针使用一个数组(实现代码中是命名为<strong>table</strong>)来存放，数据元素放在动态分配的节点数组中。这样数组的顺序也就是每个元素存放的顺序，这样有利于快速访问第k个元素，同时在插入和删除操作方面需要移动的是指针在数组的位置，而不是元素本身，速度也是相对更快。</p>
<p>  对于模拟指针，由于还是首次接触，所以还是不太熟悉，有不少地方是还没怎么弄懂的，要好好再看看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节讲述间接寻址和模拟指针的内容。</p>
<h3 id="u95F4_u63A5_u5BFB_u5740"><a href="#u95F4_u63A5_u5BFB_u5740" class="header]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据描述2--单向链表]]></title>
    <link href="http://ccc013.github.io/2016/06/09/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B02-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/06/09/数据描述2-单向链表/</id>
    <published>2016-06-09T10:07:41.000Z</published>
    <updated>2016-10-20T07:37:04.607Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节主要介绍链表，以及单向链表和单向循环链表，双向链表的介绍。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><h4 id="u7C7BChainNode_u548CNode"><a href="#u7C7BChainNode_u548CNode" class="headerlink" title="类ChainNode和Node"></a>类ChainNode和Node</h4><blockquote>
<p>链表描述中，数据对象实例的每个元素都放在单元或节点中进行描述，不过每个节点不必是一个数组元素，但都包含了与该节点相关的其他节点的位置信息，这种关于其他节点的位置信息被称为链(link)或指针(pointer)。</p>
</blockquote>
<p>令$L=(e_1,e_2,\ldots,e_n)$是一个线性表，其链表描述如下图所示，每个节点都包含一个链接域，用以指向表中的下一个元素。所以节点$e_i$的指针将指向$e_{i+1}$，其中$1\le i \lt n$。节点$e_n$没有下一个节点，所以它的链接域是<strong>NULL(或0)</strong>。指针变量<code>first</code>指向描述中的第一个节点。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A81.png" alt="此处输入图片的描述"></p>
<p>上图中每个节点都正好有一个链接域，所以该图的链表结构被称之为<strong>单向链表</strong>，此外，这种结构由于是每个节点的指针都指向下一个节点，然后最后一个节点的链接域是NULL，故也称为<strong>链(chain)</strong>。<strong>这里定义的<code>Chain&lt;T&gt;</code>是<code>ChainNode&lt;T&gt;</code>的一个友类，即<code>Chain&lt;T&gt;</code>可以访问<code>ChainNode&lt;T&gt;</code>的所有成员(尤其是私有成员)。</strong>其类定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须先声明，否则友元模板类之间无法直接访问，会出现未定义的错误。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Chain;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> ChainNode&#123;</span><br><span class="line">    <span class="keyword">friend</span> Chain&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    ChainNode&lt;T&gt; * link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Chain&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向第一个节点的指针</span></span><br><span class="line">    ChainNode&lt;T&gt; *first;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Chain()&#123; first = <span class="number">0</span>; &#125;</span><br><span class="line">    ~Chain();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> first == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> k, T&amp; x)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span><span class="keyword">const</span></span>;</span><br><span class="line">    Chain&lt;T&gt;&amp; Delete(<span class="keyword">int</span> k, T&amp; x);</span><br><span class="line">    Chain&lt;T&gt;&amp; Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp;x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  下面给出析构函数，<code>Length,Find,Search,Output</code>函数的代码实现，其中析构函数的复杂性是$\theta(n)$,n是链表的长度，而<code>Length</code>的复杂性是$\theta(n)$,<code>Find</code>的复杂性$O(k)$,函数<code>Search</code>的复杂性是$O(n)$,<code>Output</code>的复杂性是$\theta(n)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Chain&lt;T&gt;::~Chain()&#123;</span><br><span class="line">    <span class="comment">// 删除链表中的所有节点</span></span><br><span class="line">    ChainNode&lt;T&gt; *next;</span><br><span class="line">    <span class="keyword">while</span> (first)&#123;</span><br><span class="line">        next = first-&gt;link;</span><br><span class="line">        <span class="keyword">delete</span> first;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Chain&lt;T&gt;::Length() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回链表中的元素总数</span></span><br><span class="line">    ChainNode&lt;T&gt; *current = first;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        current = current-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Chain&lt;T&gt;::Find(<span class="keyword">int</span> k, T&amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 寻找链表中的第k个元素，并将其传送者x</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ChainNode&lt;T&gt; *current = first;</span><br><span class="line">    <span class="comment">// current的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (index &lt; k &amp;&amp; current)&#123;</span><br><span class="line">        current = current-&gt;link;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current)&#123;</span><br><span class="line">        x = current-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在第k个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Chain&lt;T&gt;::Search(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 寻找x，如果发现x，则返回x的位置</span></span><br><span class="line">    ChainNode&lt;T&gt; *current = first;</span><br><span class="line">    <span class="comment">// current的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;data != x)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        current = current-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current)</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Chain&lt;T&gt;::Output(<span class="built_in">std</span>::ostream&amp; out)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">//  将链表元素送至输出流</span></span><br><span class="line">    ChainNode&lt;T&gt; *current;</span><br><span class="line">    <span class="keyword">for</span> (current = first; current; current = current-&gt;link)&#123;</span><br><span class="line">        out &lt;&lt; current-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载 &lt;&lt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Chain&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="u5220_u9664_u64CD_u4F5C"><a href="#u5220_u9664_u64CD_u4F5C" class="headerlink" title="删除操作"></a>删除操作</h5><p>  假如要从下图中删除第四个元素，需要进行如下操作：</p>
<ol>
<li>找到第三和第四个节点；</li>
<li>使第三个节点指向第五个节点；</li>
<li>释放第四个节点所占空间，以便于重用。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A82.png" alt="此处输入图片的描述"><br>代码实现如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Chain&lt;T&gt;&amp; Chain&lt;T&gt;::Delete(<span class="keyword">int</span> k, T&amp;x)&#123;</span><br><span class="line">    <span class="comment">// 把第k个元素取至x，然后删除第k个元素</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span> || !first)</span><br><span class="line">        <span class="comment">// 不存在第k个元素</span></span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="comment">// p最终指向第k个节点</span></span><br><span class="line">    ChainNode&lt;T&gt; *p = first;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// p已经指向第k个元素</span></span><br><span class="line">        first = first-&gt;link;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// q用于移动到第k-1个节点</span></span><br><span class="line">        ChainNode&lt;T&gt;*q = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; k - <span class="number">1</span> &amp;&amp; q; index++)</span><br><span class="line">            q = q-&gt;link;</span><br><span class="line">        <span class="keyword">if</span> (!q || !q-&gt;link)</span><br><span class="line">            <span class="comment">// 不存在第k个元素</span></span><br><span class="line">            <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">        <span class="comment">// 存在第k个元素</span></span><br><span class="line">        p = q-&gt;link;</span><br><span class="line">        <span class="comment">// 让上一个节点指向待删除节点后面的节点</span></span><br><span class="line">        q-&gt;link = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存第k个元素的值，然后释放节点</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里有三种情形要考虑，分别如下：</p>
<ul>
<li>k小于1或链表为空；</li>
<li>第一个元素将被删除且链表不为空；</li>
<li>从一个非空的链表中删除非首元素的元素。</li>
</ul>
<p>程序中首先就处理第一种情形，即引发<code>OutOfBounds</code>异常。然后声明一个指针变量<code>p</code>用于最终指向第k个元素，对于第二种情形，语句<code>first = first-&gt;link;</code>就可以用来删除第一个元素；对于第三种情形，首先是定义了新的指针变量<code>q</code>，然后通过一个for循环让q定位到第k-1个元素，此时如果链表的节点数少于k-1，则q为0，也是引发<code>OutOfBounds</code>异常，否则就让p指向第k个元素，并保存其值，然后释放该节点。</p>
<h5 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h5><p>  插入操作和删除操作很相似，要在链表第k个元素之后插入一个新的元素，需要首先找到第k个元素，然后在该节点后面插入新的节点。程序实现如下所示，其时间复杂性是$O(k)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Chain&lt;T&gt;&amp; Chain&lt;T&gt;::Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="comment">// 在第k个元素后面插入x</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    ChainNode&lt;T&gt; *p = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; k &amp;&amp; p; index++)</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    <span class="keyword">if</span> (k&gt;<span class="number">0</span> &amp;&amp; !p)</span><br><span class="line">        <span class="comment">// 不存在第k个元素</span></span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    ChainNode&lt;T&gt; *newNode = <span class="keyword">new</span> ChainNode&lt;T&gt;;</span><br><span class="line">    newNode-&gt;data = x;</span><br><span class="line">    <span class="keyword">if</span> (k)&#123;</span><br><span class="line">        newNode-&gt;link = p-&gt;link;</span><br><span class="line">        p-&gt;link = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// k=0,即作为第一个元素插入</span></span><br><span class="line">        newNode-&gt;link = first;</span><br><span class="line">        first = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样在插入操作中需要注意的是$k=0$和$k \neq 0$两种情形下的插入操作，前者是作为第一个元素插入，需要使用到指向第一个节点的指针<code>first</code>。</p>
<h4 id="u6269_u5145_u7C7BChain"><a href="#u6269_u5145_u7C7BChain" class="headerlink" title="扩充类Chain"></a>扩充类Chain</h4><p>  这里会在之前的抽象数据类型<code>LinearList</code>中的操作上增加一些新的方法，比如<code>Erase</code>（删除链表中的所有节点)、<code>Zero</code>(将first指针置为0，但并不删除任何节点)、<code>Append</code>(在链表的尾部添加一个元素)。<br>  对于函数<code>Erase</code>，其等价于类的析构函数，实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表中的所有节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Chain&lt;T&gt;::Erase()&#123;</span><br><span class="line">    ChainNode&lt;T&gt; *next;</span><br><span class="line">    <span class="keyword">while</span> (first)&#123;</span><br><span class="line">        next = first-&gt;link;</span><br><span class="line">        <span class="keyword">delete</span> first;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而函数<code>Zero</code>则可以定义为如下的内联函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zero</span><span class="params">()</span> </span>&#123; first = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于函数<code>Append</code>，为了在$\theta(1)$的时间内添加一个元素，需要在类中添加一个新的类型是<code>ChainNode&lt;T&gt; *</code>的私有成员<code>last</code>来跟踪链表的最后一个元素。同时需要在插入和删除操作中各自添加一条语句，即在<code>Delete</code>函数中的语句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在第k个元素</span></span><br><span class="line">p = q-&gt;link;</span><br></pre></td></tr></table></figure></p>
<p>后面增加下列语句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果刚好是第k个节点是最后一个节点</span></span><br><span class="line"><span class="keyword">if</span> (p == last)</span><br><span class="line">    last = q;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Insert</code>操作中的语句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></p>
<p>前面添加下面的语句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果新插入的节点是最后一个节点</span></span><br><span class="line"><span class="keyword">if</span> (!newNode-&gt;link)</span><br><span class="line">    last = y;</span><br></pre></td></tr></table></figure></p>
<p>最后，<code>Append</code>函数的代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表末尾右端添加一个元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Chain&lt;T&gt;&amp; Chain&lt;T&gt;::Append(<span class="keyword">const</span> T&amp;x)&#123;</span><br><span class="line">    ChainNode&lt;T&gt; *newNode;</span><br><span class="line">    newNode = <span class="keyword">new</span> ChainNode&lt;T&gt;;</span><br><span class="line">    newNode-&gt;data = x;</span><br><span class="line">    newNode-&gt;link = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (first)&#123;</span><br><span class="line">        <span class="comment">// 链表非空</span></span><br><span class="line">        last-&gt;link = newNode;</span><br><span class="line">        last = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        first = last = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要判断链表是否为空的问题，如果是空，则令<code>first = last = newNode</code>;</p>
<h4 id="u94FE_u8868_u904D_u5386_u5668_u7C7B"><a href="#u94FE_u8868_u904D_u5386_u5668_u7C7B" class="headerlink" title="链表遍历器类"></a>链表遍历器类</h4><p>  这里使用一个链表遍历器，遍历器的功能是记录当前位置并每次向前移动一个位置。在如下实现的遍历器程序中，有两个共享成员<strong>Initialize</strong>和<strong>Next</strong>。<br>  <strong>Initialize</strong>返回一个指针，其指向第一个链表节点中包含的数据，同时把私有变量<strong>location</strong>设置为指向链表的第一个节点，该变量用来跟踪我们在链表中所处的位置。而成员<strong>Next</strong>用来调整<strong>location</strong>，使其指向链表中的下一个节点，并返回指向该节点数据域的指针。由于遍历器类访问了<strong>Chain</strong>类的私有成员，所以应把它定义为<strong>Chain</strong>的友类(实际上应该还需要定义为<strong>ChainNode</strong>的友类，因为也是访问了其私有成员<strong>data</strong>)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表遍历器类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> ChainIterator&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ChainNode&lt;T&gt; *location;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">Initialize</span><span class="params">(<span class="keyword">const</span> Chain&lt;T&gt;&amp; c)</span></span>&#123;</span><br><span class="line">        location = c.first;</span><br><span class="line">        <span class="keyword">if</span> (location)</span><br><span class="line">            <span class="keyword">return</span> &amp;location-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">Next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!location)</span><br><span class="line">            <span class="comment">// 链表为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        location = location-&gt;link;</span><br><span class="line">        <span class="keyword">if</span> (location)</span><br><span class="line">            <span class="keyword">return</span> &amp;location-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其使用例子如下,此时<strong>Output</strong>函数不是<strong>Chain</strong>类的成员函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">const</span> Chain&lt;T&gt;&amp; X)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x;</span><br><span class="line">    ChainIterator&lt;T&gt; c;</span><br><span class="line">    x = c.Initialize(X);</span><br><span class="line">    <span class="keyword">while</span> (x)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        x = c.Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用遍历器可以实现在线性时间内输出链表，如上述程序所示。</p>
<p>更完整的例子可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/ChainList.h" target="_blank" rel="external">ChainList</a></strong>。</p>
<h4 id="u5FAA_u73AF_u94FE_u8868"><a href="#u5FAA_u73AF_u94FE_u8868" class="headerlink" title="循环链表"></a>循环链表</h4><p>  我们可以采纳下面一条或两条措施使得链表的应用代码可以更加简洁和高效：</p>
<ol>
<li>把线性表描述成一个<strong>单向循环链表</strong>，或简称<strong>循环链表</strong>；</li>
<li>在链表的前部增加一个附加的节点，称之为<strong>头节点</strong>。</li>
</ol>
<p>通过把单向链表最后一个节点的链接指针改为指向第一个节点，就可以把一个单向链表改造成循环链表，如下图(a)所示，而图(b)给出了一个带有头指针的非空的循环链表，图(c)给出了一个带有头指针的空的循环链表。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A83.png" alt="此处输入图片的描述"><br><code>CircularList</code>类的定义与<code>Chain</code>类定义相似。尽管链表搜索的复杂性仍然保持为$O(n)$，但代码本身要稍微简单一些，如下所示，程序在for循环的每次循环中执行的比较次数较少，因此会比<code>Chain</code>类中的搜索运行得更快一些。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> CircularList&lt;T&gt;::Search(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 在带有头节点的循环链表中查找x</span></span><br><span class="line">    ChainNode&lt;T&gt;* current = first-&gt;link;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    first-&gt;data = x;    <span class="comment">// 把x放入头节点</span></span><br><span class="line">    <span class="keyword">while</span> (current-&gt;data != x)&#123;</span><br><span class="line">        current = current-&gt;link;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是链表头节点</span></span><br><span class="line">    <span class="keyword">return</span> ((current == first) ? <span class="number">0</span> : index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更完整的<code>CircularList</code>可以查看我的<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/LinearList" target="_blank" rel="external">github</a></p>
<h4 id="u4E0E_u516C_u5F0F_u5316_u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83"><a href="#u4E0E_u516C_u5F0F_u5316_u63CF_u8FF0_u65B9_u6CD5_u7684_u6BD4_u8F83" class="headerlink" title="与公式化描述方法的比较"></a>与公式化描述方法的比较</h4><p>  使用公式化描述方法的线性表仅需要能够保持所有元素的空间以及保存表长的空间，而链表和循环链表描述还需要额外的空间，用来保存链接指针。<strong>采用链表描述所实现的插入和删除操作要比公式化描述时执行得更快，当每个元素都很长时(字节数多)，尤其如此。</strong></p>
<p>  还可以使用链接模式来描述很多表，这样做不会降低空间利用率，也不会降低执行效率；而对于公式化描述，为了提高空间利用率，不得不把所有的表都放在一个数组中，并使用了另外两个数组来对这个数组进行索引，更有甚者，与一个表对应一个数组的情形相比，插入和删除操作变得更加复杂，而且存在一个很显著的最坏运行时间。<br>  采用公式化描述，可以在$\theta(1)$的时间内访问第k个元素，而这种操作在链表中是需要$O(k)$。</p>
<h4 id="u53CC_u5411_u94FE_u8868"><a href="#u53CC_u5411_u94FE_u8868" class="headerlink" title="双向链表"></a>双向链表</h4><blockquote>
<p>双向链表就是每个链表元素既有指向下一个元素的指针，又有指向前一个元素的指针。</p>
</blockquote>
<p>下图是一个双向链表表示。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A84.png" alt="此处输入图片的描述"></p>
<p>双向链表的类定义如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> DoubleNode&#123;</span><br><span class="line">    T data;</span><br><span class="line">    DoubleNode&lt;T&gt;*left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> DoubleChainList&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DoubleNode&lt;T&gt;* LeftEnd, *RightEnd;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DoubleChainList()&#123; LeftEnd = RightEnd = <span class="number">0</span> &#125;;</span><br><span class="line">    ~DoubleChainList();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> k, T&amp; x)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span><span class="keyword">const</span></span>;</span><br><span class="line">    DoubleChainList&lt;T&gt;&amp; Delete(<span class="keyword">int</span> k, T&amp; x);</span><br><span class="line">    DoubleChainList&lt;T&gt;&amp; Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream &amp; out)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此外在双向链表的左部和/或右部添加头节点，并且把链表变成循环的链表，可以提高双向链表的性能。在一个非空的双向链表中，<code>LeftEnd-&gt;left</code>是一个指向最右边结点的指针(即<code>RightEnd</code>),<code>RightEnd-&gt;right</code>是一个指向最左边节点的指针，这样可以省去<code>RightEnd</code>，只需要简单地使用变量<code>LeftEnd</code>来跟踪链表。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节主要介绍链表，以及单向链表和单向循环链表，双向链表的介绍。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0"]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据描述1--线性表]]></title>
    <link href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/06/08/数据描述1-线性表/</id>
    <published>2016-06-08T04:49:32.000Z</published>
    <updated>2016-10-31T14:03:07.994Z</updated>
    <content type="html"><![CDATA[<p>《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。</p>
<p>本章的重点是介绍线性表，但一个主要目标是让大家明白–<strong>数据可以用不同的形式进行描述或存储在计算机存储器中。</strong>最常见的数据描述方法有：<strong>公式化描述、链接描述、间接寻址和模拟指针。</strong></p>
<p><strong>公式化描述</strong></p>
<blockquote>
<p>公式化描述借助数学公式来确定元素表中的每个元素分别存储在何处(如存储器地址)。最简单的情形就是把所有元素依次连续存储在一片连续的存储空间中，这就是通常 所说的连续线性表。</p>
</blockquote>
<p><strong>链接描述</strong></p>
<blockquote>
<p>链接描述中，元素表中的每个元素可以存储在存储器的不同区域汇总，每个元素都包含指向下一个元素的指针。</p>
</blockquote>
<p><strong>间接寻址</strong></p>
<blockquote>
<p>间接寻址中，元素表的每个元素也是可以存储在存储器的不同区域中，但与链接描述不同的是，此时必须保存一张表，该表的第i项指向元素表中的第i个元素，所以这张表是一个用来保存元素地址的表。</p>
</blockquote>
<p><strong>模拟指针</strong></p>
<blockquote>
<p>模拟指针非常类似于链接描述，区别在于它用整数代替了C++指针，整数所扮演的角色与指针所扮演的角色完全相同。</p>
</blockquote>
<p><strong>数据对象</strong>是一组实例或值，比如布尔值，整数，浮点数，字符串等。数据结构包括数据对象和实例以及构成实例的每个元素之间所存在的各种关系，这些关系可由相关的函数来实现。</p>
<h3 id="u7EBF_u6027_u8868_u7B80_u4ECB"><a href="#u7EBF_u6027_u8868_u7B80_u4ECB" class="headerlink" title="线性表简介"></a>线性表简介</h3><blockquote>
<p>定义：线性表示这样的数据对象，其实例形式为：$(e_1,e_2,\ldots,e_n)$,其中n是有穷自然数。</p>
</blockquote>
<p>当n=0时，表为空；当$n\gt 0$,$e_1$是第一个元素，$e_n$是最后一个元素，可以认为$e_1$优先于$e_2$,$e_2$优先于$e_3$,如此等等。除了这种优先关系外，在线性表中不再有其他的结构。我们可用<strong>s</strong>来表示每个元素$e_i$所需要的字节数，即<strong>s</strong>是一个元素的大小。</p>
<p>以下是一些线性表的例子：</p>
<ul>
<li>一个班级学生姓名按字母顺序排列的列表；</li>
<li>按递增次序排列的考试分数表；</li>
<li>按字母依次排列的会议列表。</li>
</ul>
<p>根据这些例子可以知道对于线性表有必要执行下列操作：</p>
<ul>
<li>创建一个线性表；</li>
<li>确定线性表是否为空；</li>
<li>确定线性表的长度；</li>
<li>查找第k个元素；</li>
<li>查找指定的元素；</li>
<li>删除第k个元素；</li>
<li>在第k个元素之后插入一个新的元素。</li>
</ul>
<p>下面用一个抽象数据类型(abstract data type, ADT)来说明线性表，它给出了实例以及相关操作的描述。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 LinearList &#123;</span><br><span class="line">实例</span><br><span class="line">	<span class="number">0</span>或多个元素的有序集合</span><br><span class="line">操作</span><br><span class="line">	Create(): 创建一个空线性表</span><br><span class="line">	Destroy(): 删除表</span><br><span class="line">	IsEmpty(): 如果表为空则返回true，否则返回false</span><br><span class="line">	Length(): 返回表的大小 (即表中元素个数)</span><br><span class="line">	Find(k,x): 寻找表中第k 个元素，并把它保存到 x 中；如果不存在，则返回false</span><br><span class="line">	Search(x): 返回元素x在表中的位置；如果x 不在表中，则返回<span class="number">0</span></span><br><span class="line">	Delete(k,x): 删除表中第k个元素，并把它保存到 x 中；函数返回修改后的线性表</span><br><span class="line">	Insert(k,x): 在第k个元素之后插入x；函数返回修改后的线性表</span><br><span class="line">	Output(out): 把线性表放入输出流 out 之中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h3><h4 id="u57FA_u672C_u63CF_u8FF0"><a href="#u57FA_u672C_u63CF_u8FF0" class="headerlink" title="基本描述"></a>基本描述</h4><blockquote>
<p>公式化描述采用<strong>数组</strong>来表示一个对象的实例，数组中的每个位置被称之为单元(cell)或节点(node)，每个数组单元应该足够大，以便能够容纳数据对象实例中的任意一个元素。</p>
</blockquote>
<p>实例中每个元素在数组中的位置可以用一个数学公式来指明，一个简单的映射公式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location(i) = i - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上述公式指明表中第<code>i</code>个元素(如果存在)位于数组中<code>i-1</code>位置处。</p>
<p>下面的程序给出了相应的C++类定义。由于表元素的数据类型随着应用的变化而变化，所以定义了一个模板类，在该模板类中，用户指定元素的数据类型是T。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> LINEARLIST_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LINEARLIST_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> LinearList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    T *element;</span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">// 当前线性表的长度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinearList(<span class="keyword">int</span> MaxListSize = <span class="number">10</span>);</span><br><span class="line">    ~LinearList()&#123; <span class="keyword">delete</span>[] element; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> length == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="comment">// 返回第k个元素至x中</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> k, T&amp;x)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 返回x所在的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 删除第k个元素并将它返回至x中</span></span><br><span class="line">    LinearList&lt;T&gt;&amp; Delete(<span class="keyword">int</span> k, T&amp;x);</span><br><span class="line">    <span class="comment">// 在第k个元素之后插入x</span></span><br><span class="line">    LinearList&lt;T&gt;&amp; Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="u5F02_u5E38_u7C7BNoMem"><a href="#u5F02_u5E38_u7C7BNoMem" class="headerlink" title="异常类NoMem"></a>异常类NoMem</h4><p>  如果分配内存失败，那么我们希望可以引发一个异常，有时，异常可能由<code>new</code>引起，有时则需要我们自己来引发。而我们希望在所有情形下都能引发同一个异常，因此，定义了一个异常类NoMem,如下面程序所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">class</span> NoMem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NoMem()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使new引发NoMem异常而不是xalloc异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_new_handler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> NoMem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_handler Old_Handler_ = <span class="built_in">std</span>::set_new_handler(my_new_handler);</span><br></pre></td></tr></table></figure></p>
<p>在上述程序中，函数<code>my_new_handler</code>简单地引发了一个类型为<code>NoMem</code>的异常，然后在程序最后一行调用了C++函数<code>set_new_handler</code>，每当分配内存失败时，该函数就让操作符<code>new</code>调用函数<code>my_new_handler</code>，所以<code>new</code>引发的异常是<code>NoMem</code>而不是<code>xalloc</code>。每当分配内存失败时，<code>set_new_handler</code>将返回一个指针，指向由<code>new</code>此前所调用的那个函数，该指针保存在变量<code>Old_Handler_</code>中。为了恢复<code>new</code>的元素行为，可以如此调用:<code>set_new_handler(Old_Handler_)</code>;</p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  在抽象数据类型中的操作<code>Create</code>和<code>Destroy</code>分别被作为类的构造函数和析构函数加以实现。基本操作实现的程序如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"LinearList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinearList&lt;T&gt;::LinearList(<span class="keyword">int</span> MaxListSize)&#123;</span><br><span class="line">    MaxSize = MaxListSize;</span><br><span class="line">    element = <span class="keyword">new</span> T[MaxSize];</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第k个元素至x中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> LinearList&lt;T&gt;::Find(<span class="keyword">int</span> k, T&amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;<span class="number">1</span> || k&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = element[k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x所在的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinearList&lt;T&gt;::Search(<span class="keyword">const</span> T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (element[i] == x)</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上述程序可知，函数<code>IsEmpty,Length,Find</code>三个函数的复杂性是$\theta(1)$,而<code>Search</code>的复杂性是$O(length)$。</p>
<h5 id="u5220_u9664_u5143_u7D20"><a href="#u5220_u9664_u5143_u7D20" class="headerlink" title="删除元素"></a>删除元素</h5><p>程序如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第k个元素并将它返回至x中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinearList&lt;T&gt;&amp; LinearList&lt;T&gt;::Delete(<span class="keyword">int</span> k, T&amp;x)&#123;</span><br><span class="line">    <span class="comment">// 如果不存在第k个元素，则引发异常OutOfBounds</span></span><br><span class="line">    <span class="keyword">if</span> (Find(k, x))&#123;</span><br><span class="line">        <span class="comment">// 将第k个元素后的元素向前移动一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; length; i++)</span><br><span class="line">            element[i - <span class="number">1</span>] = element[i];</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数首先要判断表中是否存在第<code>k</code>个元素，然后再删除元素。如果不存在，则出现一个异常，这里是引发一个类型为<code>OutOfBounds</code>的异常。每当正在执行的函数中任一参数超出所期望的范围时，就引发这种类型的异常。<br>如果存在第<code>k</code>个元素，则可以将元素$k+1，k+2，…,length$依次向前移动一个位置，并将<code>length</code>减一，从而删除第<code>k</code>个元素。<br><code>Delete</code>函数在不存在第<code>k</code>个元素时，所需要的时间是$\theta(1)$;如果存在，则需要移动<code>length-k</code>个元素，需要耗时$\theta((length-k)s)$,其中<strong>s</strong>是每个元素的大小。此外，被删除的元素被移动至<code>x</code>，因此，总的时间复杂性是$O((length-k)s)$。</p>
<h5 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h5><p> 程序如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 在第k个元素之后插入x</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">LinearList&lt;T&gt;&amp; LinearList&lt;T&gt;::Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp;x)&#123;</span><br><span class="line">    <span class="comment">// 如果不存在第k个元素，则引发异常OutOfBounds</span></span><br><span class="line">    <span class="keyword">if</span> (k&lt;<span class="number">0</span> || k&gt;lenth)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="comment">// 如果表已满，则引发异常NoMem</span></span><br><span class="line">    <span class="keyword">if</span> (length == MaxSize)</span><br><span class="line">        <span class="keyword">throw</span> NoMem();</span><br><span class="line">    <span class="comment">// 向后移动一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= k; i--)</span><br><span class="line">        element[i + <span class="number">1</span>] = element[i];</span><br><span class="line">    element[k] = x;</span><br><span class="line">    length++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了在第<code>k</code>个元素之后插入一个元素，首先需要把第<code>k+1</code>至<code>length</code>元素向后移动一个位置，然后将新元素插入到<code>k+1</code>位置处。</p>
<p><code>Insert</code>函数的时间复杂性是$O((length-k)s)$。</p>
<h5 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h5><p>  下面程序是用来测试类<code>LinearList</code>的例子，其中头文件<code>llist.h</code>包含了类声明以及定义，<code>xcept.h</code>则是异常类的定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"llist.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"xcept.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        LinearList&lt;<span class="keyword">int</span>&gt; L(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Length = "</span> &lt;&lt; L.Length() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"IsEmpty = "</span> &lt;&lt; L.isEmpty() &lt;&lt; endl;</span><br><span class="line">        L.Insert(<span class="number">0</span>, <span class="number">2</span>).Insert(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"List is "</span> &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        L.Find(<span class="number">1</span>, z);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"First element is "</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Length = "</span> &lt;&lt; L.Length() &lt;&lt; endl;</span><br><span class="line">        L.Delete(<span class="number">1</span>, z);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleted element is "</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"List is "</span> &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"An exception has occured"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B5%8B%E8%AF%951.png" alt="此处输入图片的描述"></p>
<p>完整的例子放在了我的Github中–<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/LinearList" target="_blank" rel="external">LinearList</a></p>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>​    对这种公式化描述方法，首先是分析这种方法的优缺点，首先这种方法的确是可以用非常简单的C++函数来实现各种操作，执行查找、删除和插入的函数都有一个最差的、与表大小呈线性关系的时间复杂性。但一个缺点是空间的低效利用。</p>
<p>​    因此其实可以对原来的类<code>LinearList</code>做出一点修改，增加一个可以调整数组大小的函数<code>Resize</code>，在初始创建线性表时，置<code>MaxSize =1</code>;然后，执行插入操作期间，当线性表的元素个数等于<code>MaxSize</code>,就调用<code>Resize</code>函数，增加两倍的容量；在删除操作期间，当元素个数减少到容量的<strong>1/4</strong>时，就调用<code>Resize</code>函数，将容量减少到当前的<strong>1/2</strong>。<br>具体实现的操作如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> ResizeLinearList&lt;T&gt;::Resize(<span class="keyword">int</span> resizeCount)&#123;</span><br><span class="line">    <span class="comment">// 新数组的大小必须大于现有的数组元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (resizeCount &lt;= length)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"should give a larger numbers than current array numbers\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新数组的容量</span></span><br><span class="line">    MaxSize = resizeCount;</span><br><span class="line">    T * newElement = <span class="keyword">new</span> T[resizeCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        newElement[i] = element[i];</span><br><span class="line">    <span class="keyword">delete</span>[] element;</span><br><span class="line">    element = newElement;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除第k个元素并将它返回至x中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">ResizeLinearList&lt;T&gt;&amp; ResizeLinearList&lt;T&gt;::Delete(<span class="keyword">int</span> k, T&amp;x)&#123;</span><br><span class="line">    <span class="comment">// 如果不存在第k个元素，则引发异常OutOfBounds</span></span><br><span class="line">    <span class="keyword">if</span> (Find(k, x))&#123;</span><br><span class="line">        <span class="comment">// 将第k个元素后的元素向前移动一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; length; i++)</span><br><span class="line">            element[i - <span class="number">1</span>] = element[i];</span><br><span class="line">        length--;</span><br><span class="line">        <span class="comment">// 如果当前元素数量等于1/4的容量，则将最大容量缩小一半</span></span><br><span class="line">        <span class="keyword">if</span> (length == (<span class="keyword">int</span>)MaxSize * <span class="number">0.25</span>)</span><br><span class="line">            Resize((<span class="keyword">int</span>)<span class="number">0.5</span> * MaxSize);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第k个元素之后插入x</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">ResizeLinearList&lt;T&gt;&amp; ResizeLinearList&lt;T&gt;::Insert(<span class="keyword">int</span> k, <span class="keyword">const</span> T&amp;x)&#123;</span><br><span class="line">    <span class="comment">// 如果不存在第k个元素，则引发异常OutOfBounds</span></span><br><span class="line">    <span class="keyword">if</span> (k&lt;<span class="number">0</span> || k&gt;length)</span><br><span class="line">        <span class="keyword">throw</span> OutOfBounds();</span><br><span class="line">    <span class="comment">// 如果表已满，则增加2倍容量</span></span><br><span class="line">    <span class="keyword">if</span> (length == MaxSize)</span><br><span class="line">        Resize(<span class="number">2</span>*MaxSize);</span><br><span class="line">    <span class="comment">// 向后移动一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= k; i--)</span><br><span class="line">        element[i + <span class="number">1</span>] = element[i];</span><br><span class="line">    element[k] = x;</span><br><span class="line">    length++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的例子在<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/ResizeLinearList.h" target="_blank" rel="external">ResizeLinearList</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。</p>
<p>本章的重点是介绍线性表，但一个主要目标是让大家明白–<strong>数据可以用不同的形式进行描述或存储在计算机存储器中。</strong>最常见的数据描述方法有：<strong>公式化描述、链接描述]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
