<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Cai's blog]]></title>
  <subtitle><![CDATA[Stay hungry, stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ccc013.github.io/"/>
  <updated>2016-06-09T10:08:32.346Z</updated>
  <id>http://ccc013.github.io/</id>
  
  <author>
    <name><![CDATA[cai]]></name>
    <email><![CDATA[429546420@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[数据描述2--单向链表]]></title>
    <link href="http://ccc013.github.io/2016/06/09/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B02-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/06/09/数据描述2-单向链表/</id>
    <published>2016-06-09T10:07:41.000Z</published>
    <updated>2016-06-09T10:08:32.346Z</updated>
    <content type="html"><![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节主要介绍链表，以及单向链表的代码实现。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h3><h4 id="u7C7BChainNode_u548CNode"><a href="#u7C7BChainNode_u548CNode" class="headerlink" title="类ChainNode和Node"></a>类ChainNode和Node</h4><blockquote>
<p>链表描述中，数据对象实例的每个元素都放在单元或节点中进行描述，不过每个节点不必是一个数组元素，但都包含了与该节点相关的其他节点的位置信息，这种关于其他节点的位置信息被称为链(link)或指针(pointer)。</p>
</blockquote>
<p>令$L=(e_1,e_2,\ldots,e_n)$是一个线性表，其链表描述如下图所示，每个节点都包含一个链接域，用以指向表中的下一个元素。所以节点$e<em>i$的指针将指向$e</em>{i+1}$，其中$1\le i \lt n$。节点$e_n$没有下一个节点，所以它的链接域是NULL(或0)。指针变量<code>first</code>指向描述中的第一个节点。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A81.png" alt="此处输入图片的描述"></p>
<p>上图中每个节点都正好有一个链接域，所以该图的链表结构被称之为<strong>单向链表</strong>，此外，这种结构由于是每个节点的指针都指向下一个节点，然后最后一个节点的链接域是NULL，故也称为<strong>链(chain)</strong>。<strong>这里定义的<code>Chain&lt;T&gt;</code>是<code>ChainNode&lt;T&gt;</code>的一个友类，即<code>Chain&lt;T&gt;</code>可以访问<code>ChainNode&lt;T&gt;</code>的所有成员(尤其是私有成员)。</strong>其类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;&#10;// &#24517;&#39035;&#20808;&#22768;&#26126;&#65292;&#21542;&#21017;&#21451;&#20803;&#27169;&#26495;&#31867;&#20043;&#38388;&#26080;&#27861;&#30452;&#25509;&#35775;&#38382;&#65292;&#20250;&#20986;&#29616;&#26410;&#23450;&#20041;&#30340;&#38169;&#35823;&#12290;&#10;template&#60;class T&#62;&#10;class Chain;&#10;&#10;&#10;template&#60;class T&#62;&#10;class ChainNode&#123;&#10;    friend Chain&#60;T&#62;;&#10;private:&#10;    T data;&#10;    ChainNode&#60;T&#62; * link;&#10;&#125;;&#10;&#10;template&#60;class T&#62;&#10;class Chain&#123;&#10;private:&#10;    // &#25351;&#21521;&#31532;&#19968;&#20010;&#33410;&#28857;&#30340;&#25351;&#38024;&#10;    ChainNode&#60;T&#62; *first;&#10;public:&#10;    Chain()&#123; first = 0; &#125;&#10;    ~Chain();&#10;    bool isEmpty() const&#123; return first == 0; &#125;&#10;    int Length() const;&#10;    bool Find(int k, T&#38; x)const;&#10;    int Search(const T&#38; x)const;&#10;    Chain&#60;T&#62;&#38; Delete(int k, T&#38; x);&#10;    Chain&#60;T&#62;&#38; Insert(int k, const T&#38;x);&#10;    void Output(std::ostream&#38; out)const;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  下面给出析构函数，<code>Length,Find,Search,Output</code>函数的代码实现，其中析构函数的复杂性是$\theta(n)$,n是链表的长度，而<code>Length</code>的复杂性是$\theta(n)$,<code>Find</code>的复杂性$O(k)$,函数<code>Search</code>的复杂性是$O(n)$,<code>Output</code>的复杂性是$\theta(n)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Chain&#60;T&#62;::~Chain()&#123;&#10;    // &#21024;&#38500;&#38142;&#34920;&#20013;&#30340;&#25152;&#26377;&#33410;&#28857;&#10;    ChainNode&#60;T&#62; *next;&#10;    while (first)&#123;&#10;        next = first-&#62;link;&#10;        delete first;&#10;        first = next;&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;int Chain&#60;T&#62;::Length() const&#123;&#10;    // &#36820;&#22238;&#38142;&#34920;&#20013;&#30340;&#20803;&#32032;&#24635;&#25968;&#10;    ChainNode&#60;T&#62; *current = first;&#10;    int len = 0;&#10;    while (current)&#123;&#10;        len++;&#10;        current = current-&#62;link;&#10;    &#125;&#10;    return len;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;bool Chain&#60;T&#62;::Find(int k, T&#38;x)const&#123;&#10;    // &#23547;&#25214;&#38142;&#34920;&#20013;&#30340;&#31532;k&#20010;&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#20256;&#36865;&#32773;x&#10;    if (k &#60; 1)&#10;        return false;&#10;    ChainNode&#60;T&#62; *current = first;&#10;    // current&#30340;&#32034;&#24341;&#10;    int index = 1;  &#10;    while (index &#60; k &#38;&#38; current)&#123;&#10;        current = current-&#62;link;&#10;        index++;&#10;    &#125;&#10;    if (current)&#123;&#10;        x = current-&#62;data;&#10;        return true;&#10;    &#125;&#10;    // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;    return false;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;int Chain&#60;T&#62;::Search(const T&#38; x)const&#123;&#10;    // &#23547;&#25214;x&#65292;&#22914;&#26524;&#21457;&#29616;x&#65292;&#21017;&#36820;&#22238;x&#30340;&#20301;&#32622;&#10;    ChainNode&#60;T&#62; *current = first;&#10;    // current&#30340;&#32034;&#24341;&#10;    int index = 1;&#10;    while (current &#38;&#38; current-&#62;data != x)&#123;&#10;        index++;&#10;        current = current-&#62;link;&#10;    &#125;&#10;    if (current)&#10;        return index;&#10;    return 0;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void Chain&#60;T&#62;::Output(std::ostream&#38; out)const&#123;&#10;    //  &#23558;&#38142;&#34920;&#20803;&#32032;&#36865;&#33267;&#36755;&#20986;&#27969;&#10;    ChainNode&#60;T&#62; *current;&#10;    for (current = first; current; current = current-&#62;link)&#123;&#10;        out &#60;&#60; current-&#62;data &#60;&#60; &#34; &#34;;&#10;    &#125;&#10;&#125;&#10;// &#37325;&#36733; &#60;&#60;&#10;template&#60;class T&#62;&#10;std::ostream&#38; operator&#60;&#60;(std::ostream&#38; out, const Chain&#60;T&#62;&#38; x)&#123;&#10;    x.Output(out);&#10;    return out;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="u5220_u9664_u64CD_u4F5C"><a href="#u5220_u9664_u64CD_u4F5C" class="headerlink" title="删除操作"></a>删除操作</h5><p>  假如要从下图中删除第四个元素，需要进行如下操作：</p>
<ol>
<li>找到第三和第四个节点；</li>
<li>使第三个节点指向第五个节点；</li>
<li>释放第四个节点所占空间，以便于重用。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A82.png" alt="此处输入图片的描述"><br>代码实现如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Chain&#60;T&#62;&#38; Chain&#60;T&#62;::Delete(int k, T&#38;x)&#123;&#10;    // &#25226;&#31532;k&#20010;&#20803;&#32032;&#21462;&#33267;x&#65292;&#28982;&#21518;&#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#10;    if (k &#60; 1 || !first)&#10;        // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;        throw OutOfBounds();&#10;    // p&#26368;&#32456;&#25351;&#21521;&#31532;k&#20010;&#33410;&#28857;&#10;    ChainNode&#60;T&#62; *p = first;&#10;    if (k == 1)&#10;        // p&#24050;&#32463;&#25351;&#21521;&#31532;k&#20010;&#20803;&#32032;&#10;        first = first-&#62;link;&#10;    else&#123;&#10;        // q&#29992;&#20110;&#31227;&#21160;&#21040;&#31532;k-1&#20010;&#33410;&#28857;&#10;        ChainNode&#60;T&#62;*q = first;&#10;        for (int index = 1; index &#60; k - 1 &#38;&#38; q; index++)&#10;            q = q-&#62;link;&#10;        if (!q || !q-&#62;link)&#10;            // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;            throw OutOfBounds();&#10;        // &#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;        p = q-&#62;link;&#10;        // &#35753;&#19978;&#19968;&#20010;&#33410;&#28857;&#25351;&#21521;&#24453;&#21024;&#38500;&#33410;&#28857;&#21518;&#38754;&#30340;&#33410;&#28857;&#10;        q-&#62;link = p-&#62;link;&#10;    &#125;&#10;    // &#20445;&#23384;&#31532;k&#20010;&#20803;&#32032;&#30340;&#20540;&#65292;&#28982;&#21518;&#37322;&#25918;&#33410;&#28857;&#10;    x = p-&#62;data;&#10;    delete p;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里有三种情形要考虑，分别如下：</p>
<ul>
<li>k小于1或链表为空；</li>
<li>第一个元素将被删除且链表不为空；</li>
<li>从一个非空的链表中删除非首元素的元素。<br>程序中首先就处理第一种情形，即引发<code>OutOfBounds</code>异常。然后声明一个指针变量<code>p</code>用于最终指向第k个元素，对于第二种情形，语句<code>first = first-&gt;link;</code>就可以用来删除第一个元素；对于第三种情形，首先是定义了新的指针变量<code>q</code>，然后通过一个for循环让q定位到第k-1个元素，此时如果链表的节点数少于k-1，则q为0，也是引发<code>OutOfBounds</code>异常，否则就让p指向第k个元素，并保存其值，然后释放该节点。</li>
</ul>
<h5 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h5><p>  插入操作和删除操作很相似，要在链表第k个元素之后插入一个新的元素，需要首先找到第k个元素，然后在该节点后面插入新的节点。程序实现如下所示，其时间复杂性是$O(k)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;Chain&#60;T&#62;&#38; Chain&#60;T&#62;::Insert(int k, const T&#38; x)&#123;&#10;    // &#22312;&#31532;k&#20010;&#20803;&#32032;&#21518;&#38754;&#25554;&#20837;x&#10;    if (k &#60; 0)&#10;        throw OutOfBounds();&#10;    ChainNode&#60;T&#62; *p = first;&#10;    for (int index = 1; index &#60; k &#38;&#38; p; index++)&#10;        p = p-&#62;link;&#10;    if (k&#62;0 &#38;&#38; !p)&#10;        // &#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;        throw OutOfBounds();&#10;    ChainNode&#60;T&#62; *newNode = new ChainNode&#60;T&#62;;&#10;    newNode-&#62;data = x;&#10;    if (k)&#123;&#10;        newNode-&#62;link = p-&#62;link;&#10;        p-&#62;link = newNode;&#10;    &#125;&#10;    else&#123;&#10;        // k=0,&#21363;&#20316;&#20026;&#31532;&#19968;&#20010;&#20803;&#32032;&#25554;&#20837;&#10;        newNode-&#62;link = first;&#10;        first = newNode;&#10;    &#125;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样在插入操作中需要注意的是$k=0$和$k \neq 0$两种情形下的插入操作，前者是作为第一个元素插入，需要使用到指向第一个节点的指针<code>first</code>。</p>
<h4 id="u6269_u5145_u7C7BChain"><a href="#u6269_u5145_u7C7BChain" class="headerlink" title="扩充类Chain"></a>扩充类Chain</h4><p>  这里会在之前的抽象数据类型<code>LinearList</code>中的操作上增加一些新的方法，比如<code>Erase</code>（删除链表中的所有节点)、<code>Zero</code>(将first指针置为0，但并不删除任何节点)、<code>Append</code>(在链表的尾部添加一个元素)。<br>  对于函数<code>Erase</code>，其等价于类的析构函数，实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21024;&#38500;&#38142;&#34920;&#20013;&#30340;&#25152;&#26377;&#33410;&#28857;&#10;template&#60;class T&#62;&#10;void Chain&#60;T&#62;::Erase()&#123;&#10;    ChainNode&#60;T&#62; *next;&#10;    while (first)&#123;&#10;        next = first-&#62;link;&#10;        delete first;&#10;        first = next;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而函数<code>Zero</code>则可以定义为如下的内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Zero() &#123; first = 0; &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于函数<code>Append</code>，为了在$\theta(1)$的时间内添加一个元素，需要在类中添加一个新的类型是<code>ChainNode&lt;T&gt; *</code>的私有成员<code>last</code>来跟踪链表的最后一个元素。同时需要在插入和删除操作中各自添加一条语句，即在<code>Delete</code>函数中的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#10;p = q-&#62;link;</span><br></pre></td></tr></table></figure></p>
<p>后面增加下列语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22914;&#26524;&#21018;&#22909;&#26159;&#31532;k&#20010;&#33410;&#28857;&#26159;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#10;if (p == last)&#10;    last = q;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Insert</code>操作中的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return *this;</span><br></pre></td></tr></table></figure></p>
<p>前面添加下面的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22914;&#26524;&#26032;&#25554;&#20837;&#30340;&#33410;&#28857;&#26159;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#10;if (!newNode-&#62;link)&#10;    last = y;</span><br></pre></td></tr></table></figure></p>
<p>最后，<code>Append</code>函数的代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22312;&#38142;&#34920;&#26411;&#23614;&#21491;&#31471;&#28155;&#21152;&#19968;&#20010;&#20803;&#32032;&#10;template&#60;class T&#62;&#10;Chain&#60;T&#62;&#38; Chain&#60;T&#62;::Append(const T&#38;x)&#123;&#10;    ChainNode&#60;T&#62; *newNode;&#10;    newNode = new ChainNode&#60;T&#62;;&#10;    newNode-&#62;data = x;&#10;    newNode-&#62;link = 0;&#10;    if (first)&#123;&#10;        // &#38142;&#34920;&#38750;&#31354;&#10;        last-&#62;link = newNode;&#10;        last = newNode;&#10;    &#125;&#10;    else&#123;&#10;        first = last = newNode;&#10;    &#125;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要判断链表是否为空的问题，如果是空，则令<code>first = last = newNode</code>;</p>
<h4 id="u94FE_u8868_u904D_u5386_u5668_u7C7B"><a href="#u94FE_u8868_u904D_u5386_u5668_u7C7B" class="headerlink" title="链表遍历器类"></a>链表遍历器类</h4><p>  这里使用一个链表遍历器，遍历器的功能是记录当前位置并每次向前移动一个位置。在如下实现的遍历器程序中，有两个共享成员<strong>Initialize</strong>和<strong>Next</strong>。<br>  <strong>Initialize</strong>返回一个指针，其指向第一个链表节点中包含的数据，同时把私有变量<strong>location</strong>设置为指向链表的第一个节点，该变量用来跟踪我们在链表中所处的位置。而成员<strong>Next</strong>用来调整<strong>location</strong>，使其指向链表中的下一个节点，并返回指向该节点数据域的指针。由于遍历器类访问了<strong>Chain</strong>类的私有成员，所以应把它定义为<strong>Chain</strong>的友类(实际上应该还需要定义为<strong>ChainNode</strong>的友类，因为也是访问了其私有成员<strong>data</strong>)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#38142;&#34920;&#36941;&#21382;&#22120;&#31867;&#10;template&#60;class T&#62;&#10;class ChainIterator&#123;&#10;private:&#10;    ChainNode&#60;T&#62; *location;&#10;public:&#10;    T* Initialize(const Chain&#60;T&#62;&#38; c)&#123;&#10;        location = c.first;&#10;        if (location)&#10;            return &#38;location-&#62;data;&#10;        return 0;&#10;    &#125;&#10;    T* Next()&#123;&#10;        if (!location)&#10;            // &#38142;&#34920;&#20026;&#31354;&#10;            return 0;&#10;        location = location-&#62;link;&#10;        if (location)&#10;            return &#38;location-&#62;data;&#10;        return 0;&#10;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其使用例子如下,此时<strong>Output</strong>函数不是<strong>Chain</strong>类的成员函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Output(const Chain&#60;T&#62;&#38; X)&#123;&#10;    int *x;&#10;    ChainIterator&#60;T&#62; c;&#10;    x = c.Initialize(X);&#10;    while (x)&#123;&#10;        cout &#60;&#60; *x &#60;&#60; &#39; &#39;;&#10;        x = c.Next();&#10;    &#125;&#10;    cout &#60;&#60; endl;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用遍历器可以实现在线性时间内输出链表，如上述程序所示。</p>
<p>更完整的例子可以查看<strong><a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/ChainList.h" target="_blank" rel="external">ChainList</a></strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续是《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。本小节主要介绍链表，以及单向链表的代码实现。</p>
<h3 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="he]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据描述1--线性表]]></title>
    <link href="http://ccc013.github.io/2016/06/08/%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B01-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://ccc013.github.io/2016/06/08/数据描述1-线性表/</id>
    <published>2016-06-08T04:49:32.000Z</published>
    <updated>2016-06-08T04:53:11.929Z</updated>
    <content type="html"><![CDATA[<p>《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。</p>
<p>本章的重点是介绍线性表，但一个主要目标是让大家明白–<strong>数据可以用不同的形式进行描述或存储在计算机存储器中。</strong>最常见的数据买欧式方法有：<strong>公式化描述、链接描述、间接寻址和模拟指针。</strong></p>
<p><strong>公式化描述</strong></p>
<blockquote>
<p>公式化描述借助数学公式来确定元素表中的每个元素分别存储在何处(如存储器地址)。最简单的情形就是把所有元素依次连续存储在一片连续的存储空间中，这就是通常 所说的连续线性表。</p>
</blockquote>
<p><strong>链接描述</strong></p>
<blockquote>
<p>链接描述中，元素表中的每个元素可以存储在存储器的不同区域汇总，每个元素都包含指向下一个元素的指针。</p>
</blockquote>
<p><strong>间接寻址</strong></p>
<blockquote>
<p>间接寻址中，元素表的每个元素也是可以存储在存储器的不同区域中，但与链接描述不同的是，此时必须保存一张表，该表的第i项指向元素表中的第i个元素，所以这张表是一个用来保存元素地址的表。</p>
</blockquote>
<p><strong>模拟指针</strong></p>
<blockquote>
<p>模拟指针非常类似于链接描述，区别在于它用整数代替了C++指针，整数所扮演的角色与指针所扮演的角色完全相同。</p>
</blockquote>
<p><strong>数据对象</strong>是一组实例或值，比如布尔值，整数，浮点数，字符串等。数据结构包括数据对象和实例以及构成实例的每个元素之间所存在的各种关系，这些关系可由相关的函数来实现。</p>
<h3 id="u7EBF_u6027_u8868_u7B80_u4ECB"><a href="#u7EBF_u6027_u8868_u7B80_u4ECB" class="headerlink" title="线性表简介"></a>线性表简介</h3><blockquote>
<p>定义：线性表示这样的数据对象，其实例形式为：$(e_1,e_2,\ldots,e_n)$,其中n是有穷自然数。</p>
</blockquote>
<p>当n=0时，表为空；当$n\gt 0$,$e_1$是第一个元素，$e_n$是最后一个元素，可以认为$e_1$优先于$e_2$,$e_2$优先于$e_3$,如此等等。除了这种优先关系外，在线性表中不再有其他的结构。我们可用<strong>s</strong>来表示每个元素$e_i$所需要的字节数，即<strong>s</strong>是一个元素的大小。</p>
<p>以下是一些线性表的例子：</p>
<ul>
<li>一个班级学生姓名按字母顺序排列的列表；</li>
<li>按递增次序排列的考试分数表；</li>
<li>按字母依次排列的会议列表。</li>
</ul>
<p>根据这些例子可以知道对于线性表有必要执行下列操作：</p>
<ul>
<li>创建一个线性表；</li>
<li>确定线性表是否为空；</li>
<li>确定线性表的长度；</li>
<li>查找第k个元素；</li>
<li>查找指定的元素；</li>
<li>删除第k个元素；</li>
<li>在第k个元素之后插入一个新的元素。</li>
</ul>
<p>下面用一个抽象数据类型(abstract data type, ADT)来说明线性表，它给出了实例以及相关操作的描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411;LinearList &#123;&#10;&#23454;&#20363;&#10;0&#25110;&#22810;&#20010;&#20803;&#32032;&#30340;&#26377;&#24207;&#38598;&#21512;&#10;&#25805;&#20316;&#10;Create(): &#21019;&#24314;&#19968;&#20010;&#31354;&#32447;&#24615;&#34920;&#10;Destroy(): &#21024;&#38500;&#34920;&#10;IsEmpty(): &#22914;&#26524;&#34920;&#20026;&#31354;&#21017;&#36820;&#22238;true&#65292;&#21542;&#21017;&#36820;&#22238;false&#10;Length(): &#36820;&#22238;&#34920;&#30340;&#22823;&#23567; (&#21363;&#34920;&#20013;&#20803;&#32032;&#20010;&#25968;)&#10;Find(k,x): &#23547;&#25214;&#34920;&#20013;&#31532;k &#20010;&#20803;&#32032;&#65292;&#24182;&#25226;&#23427;&#20445;&#23384;&#21040; x &#20013;&#65307;&#22914;&#26524;&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238;false&#10;Search(x): &#36820;&#22238;&#20803;&#32032;x&#22312;&#34920;&#20013;&#30340;&#20301;&#32622;&#65307;&#22914;&#26524;x &#19981;&#22312;&#34920;&#20013;&#65292;&#21017;&#36820;&#22238;0&#10;Delete(k,x): &#21024;&#38500;&#34920;&#20013;&#31532;k&#20010;&#20803;&#32032;&#65292;&#24182;&#25226;&#23427;&#20445;&#23384;&#21040; x &#20013;&#65307;&#20989;&#25968;&#36820;&#22238;&#20462;&#25913;&#21518;&#30340;&#32447;&#24615;&#34920;&#10;Insert(k,x): &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#65307;&#20989;&#25968;&#36820;&#22238;&#20462;&#25913;&#21518;&#30340;&#32447;&#24615;&#34920;&#10;Output(out): &#25226;&#32447;&#24615;&#34920;&#25918;&#20837;&#36755;&#20986;&#27969; out &#20043;&#20013;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h3><h4 id="u57FA_u672C_u63CF_u8FF0"><a href="#u57FA_u672C_u63CF_u8FF0" class="headerlink" title="基本描述"></a>基本描述</h4><blockquote>
<p>公式化描述采用<strong>数组</strong>来表示一个对象的实例，数组中的每个位置被称之为单元(cell)或节点(node)，每个数组单元应该足够大，以便能够容纳数据对象实例中的任意一个元素。</p>
</blockquote>
<p>实例中每个元素在数组中的位置可以用一个数学公式来指明，一个简单的映射公式如下：</p>
<pre><code>location(i) = i - 1
</code></pre><p>上述公式指明表中第i个元素(如果存在)位于数组中i-1位置处。</p>
<p>下面的程序给出了相应的C++类定义。由于表元素的数据类型随着应用的变化而变化，所以定义了一个模板类，在该模板类中，用户指定元素的数据类型是T。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LINEARLIST_H_&#10;#define LINEARLIST_H_&#10;#include&#60;iostream&#62;&#10;&#10;template&#60;class T&#62;&#10;class LinearList&#10;&#123;&#10;private:&#10;    int MaxSize;&#10;    T *element;&#10;    int length;     // &#24403;&#21069;&#32447;&#24615;&#34920;&#30340;&#38271;&#24230;&#10;public:&#10;    LinearList(int MaxListSize = 10);&#10;    ~LinearList()&#123; delete[] element; &#125;&#10;    bool isEmpty() const&#123; return length == 0; &#125;&#10;    int Length() const &#123; return length; &#125;&#10;    // &#36820;&#22238;&#31532;k&#20010;&#20803;&#32032;&#33267;x&#20013;&#10;    bool Find(int k, T&#38;x)const;&#10;    // &#36820;&#22238;x&#25152;&#22312;&#30340;&#20301;&#32622;&#10;    int Search(const T&#38; x) const;&#10;    // &#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#24182;&#23558;&#23427;&#36820;&#22238;&#33267;x&#20013;&#10;    LinearList&#60;T&#62;&#38; Delete(int k, T&#38;x);&#10;    // &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#10;    LinearList&#60;T&#62;&#38; Insert(int k, const T&#38; x);&#10;    void Output(std::ostream &#38;out) const;&#10;&#125;;&#10;&#10;#endif</span><br></pre></td></tr></table></figure></p>
<h4 id="u5F02_u5E38_u7C7BNoMem"><a href="#u5F02_u5E38_u7C7BNoMem" class="headerlink" title="异常类NoMem"></a>异常类NoMem</h4><p>  如果分配内存失败，那么我们希望可以引发一个异常，有时，异常可能由<code>new</code>引起，有时则需要我们自己来引发。而我们希望在所有情形下都能引发同一个异常，因此，定义了一个异常类NoMem,如下面程序所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;&#10;// &#20869;&#23384;&#19981;&#36275;&#10;class NoMem&#123;&#10;public:&#10;    NoMem()&#123;&#125;&#10;&#125;;&#10;&#10;// &#20351;new&#24341;&#21457;NoMem&#24322;&#24120;&#32780;&#19981;&#26159;xalloc&#24322;&#24120;&#10;void my_new_handler()&#123;&#10;    throw NoMem();&#10;&#125;&#10;&#10;new_handler Old_Handler_ = std::set_new_handler(my_new_handler);</span><br></pre></td></tr></table></figure></p>
<p>在上述程序中，函数<code>my_new_handler</code>简单地引发了一个类型为<code>NoMem</code>的异常，然后在程序最后一行调用了C++函数<code>set_new_handler</code>，每当分配内存失败时，该函数就让操作符<code>new</code>调用函数<code>my_new_handler</code>，所以<code>new</code>引发的异常是<code>NoMem</code>而不是<code>xalloc</code>。每当分配内存失败时，<code>set_new_handler</code>将返回一个指针，指向由<code>new</code>此前所调用的那个函数，该指针保存在变量<code>Old_Handler_</code>中。为了恢复<code>new</code>的元素行为，可以如此调用:<code>set_new_handler(Old_Handler_)</code>;</p>
<h4 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h4><p>  在抽象数据类型中的操作<code>Create</code>和<code>Destroy</code>分别被作为类的构造函数和析构函数加以实现。基本操作实现的程序如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#34;LinearList.h&#34;&#10;&#10;template&#60;class T&#62;&#10;LinearList&#60;T&#62;::LinearList(int MaxListSize)&#123;&#10;    MaxSize = MaxListSize;&#10;    element = new T[MaxSize];&#10;    length = 0;&#10;&#125;&#10;&#10;// &#36820;&#22238;&#31532;k&#20010;&#20803;&#32032;&#33267;x&#20013;&#10;template&#60;class T&#62;&#10;bool LinearList&#60;T&#62;::Find(int k, T&#38;x)const&#123;&#10;    if (k &#60;1 || k&#62;length)&#10;        return false;&#10;    x = element[k - 1];&#10;    return true;&#10;&#125;&#10;&#10;// &#36820;&#22238;x&#25152;&#22312;&#30340;&#20301;&#32622;&#10;template&#60;class T&#62;&#10;int LinearList&#60;T&#62;::Search(const T&#38; x)const&#123;&#10;    for (int i = 0; i &#60; length; i++)&#123;&#10;        if (element[i] == x)&#10;            return ++i;&#10;    &#125;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上述程序可知，函数<code>IsEmpty,Length,Find</code>三个函数的复杂性是$\theta(1)$,而<code>Search</code>的复杂性是$O(length)$。</p>
<h5 id="u5220_u9664_u5143_u7D20"><a href="#u5220_u9664_u5143_u7D20" class="headerlink" title="删除元素"></a>删除元素</h5><p>程序如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#24182;&#23558;&#23427;&#36820;&#22238;&#33267;x&#20013;&#10;template&#60;class T&#62;&#10;LinearList&#60;T&#62;&#38; LinearList&#60;T&#62;::Delete(int k, T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (Find(k, x))&#123;&#10;        // &#23558;&#31532;k&#20010;&#20803;&#32032;&#21518;&#30340;&#20803;&#32032;&#21521;&#21069;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;        for (int i = k; i &#60; length; i++)&#10;            element[i - 1] = element[i];&#10;        length--;&#10;        return *this;&#10;    &#125;&#10;    else&#10;        throw OutOfBounds();&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数首先要判断表中是否存在第k个元素，然后再删除元素。如果不存在，则出现一个异常，这里是引发一个类型为<code>OutOfBounds</code>的异常。每当正在执行的函数中任一参数超出所期望的范围时，就引发这种类型的异常。<br>如果存在第k个元素，则可以将元素$k+1，k+2，…,length$依次向前移动一个位置，并将length减一，从而删除第k个元素。<br><code>Delete</code>函数在不存在第k个元素时，所需要的时间是$\theta(1)$;如果存在，则需要移动<code>length-k</code>个元素，需要耗时$\theta((length-k)s)$,其中<strong>s</strong>是每个元素的大小。此外，被删除的元素被移动至x，因此，总的时间复杂性是$O((length-k)s)$。</p>
<h5 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h5><p> 程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> // &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#10;template&#60;class T&#62;&#10;LinearList&#60;T&#62;&#38; LinearList&#60;T&#62;::Insert(int k, const T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (k&#60;0 || k&#62;lenth)&#10;        throw OutOfBounds();&#10;    // &#22914;&#26524;&#34920;&#24050;&#28385;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;NoMem&#10;    if (length == MaxSize)&#10;        throw NoMem();&#10;    // &#21521;&#21518;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;    for (int i = length - 1; i &#62;= k; i--)&#10;        element[i + 1] = element[i];&#10;    element[k] = x;&#10;    length++;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了在第k个元素之后插入一个元素，首先需要把第k+1至length元素向后移动一个位置，然后将新元素插入到k+1位置处。</p>
<p><code>Insert</code>函数的时间复杂性是$$O((length-k)s)$。</p>
<h5 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h5><p>  下面程序是用来测试类<code>LinearList</code>的例子，其中头文件<code>llist.h</code>包含了类声明以及定义，<code>xcept.h</code>则是异常类的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#34;llist.h&#34;&#10;#include&#34;xcept.h&#34;&#10;&#10;&#10;int main()&#123;&#10;    using std::cout;&#10;    using std::endl;&#10;    using std::cin;&#10;&#10;    try&#123;&#10;        LinearList&#60;int&#62; L(5);&#10;        cout &#60;&#60; &#34;Length = &#34; &#60;&#60; L.Length() &#60;&#60; endl;&#10;        cout &#60;&#60; &#34;IsEmpty = &#34; &#60;&#60; L.isEmpty() &#60;&#60; endl;&#10;        L.Insert(0, 2).Insert(1, 6);&#10;        cout &#60;&#60; &#34;List is &#34; &#60;&#60; L &#60;&#60; endl;&#10;        int z;&#10;        L.Find(1, z);&#10;        cout &#60;&#60; &#34;First element is &#34; &#60;&#60; z &#60;&#60; endl;&#10;        cout &#60;&#60; &#34;Length = &#34; &#60;&#60; L.Length() &#60;&#60; endl;&#10;        L.Delete(1, z);&#10;        cout &#60;&#60; &#34;Deleted element is &#34; &#60;&#60; z &#60;&#60; endl;&#10;        cout &#60;&#60; &#34;List is &#34; &#60;&#60; L &#60;&#60; endl;&#10;    &#125;&#10;    catch (...)&#123;&#10;        std::cerr &#60;&#60; &#34;An exception has occured&#34; &#60;&#60; endl;&#10;    &#125;&#10;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B5%8B%E8%AF%951.png" alt="此处输入图片的描述"></p>
<p>完整的例子放在了我的Github中–<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/LinearList" target="_blank" rel="external">LinearList</a></p>
<h4 id="u8BC4_u4EF7"><a href="#u8BC4_u4EF7" class="headerlink" title="评价"></a>评价</h4><p>  对这种公式化描述方法，首先是分析这种方法的优缺点，首先这种方法的确是可以用非常简单的C++函数来实现各种操作，执行查找、删除和插入的函数都有一个最差的、与表大小呈线性关系的时间复杂性。<br>  但一个缺点是空间的低效利用。</p>
<p>  因此其实可以对原来的类<code>LinearList</code>做出一点修改，增加一个可以调整数组大小的函数<code>Resize</code>，在初始创建线性表时，置<code>MaxSize =1</code>;然后，执行插入操作期间，当线性表的元素个数等于<code>MaxSize</code>,就调用<code>Resize</code>函数，增加两倍的容量；在删除操作期间，当元素个数减少到容量的<strong>1/4</strong>时，就调用<code>Resize</code>函数，将容量减少到当前的<strong>1/2</strong>。<br>具体实现的操作如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;bool ResizeLinearList&#60;T&#62;::Resize(int resizeCount)&#123;&#10;    // &#26032;&#25968;&#32452;&#30340;&#22823;&#23567;&#24517;&#39035;&#22823;&#20110;&#29616;&#26377;&#30340;&#25968;&#32452;&#20803;&#32032;&#20010;&#25968;&#10;    if (resizeCount &#60;= length)&#123;&#10;        std::cerr &#60;&#60; &#34;should give a larger numbers than current array numbers\n&#34;;&#10;        return false;&#10;    &#125;&#10;    // &#26356;&#26032;&#25968;&#32452;&#30340;&#23481;&#37327;&#10;    MaxSize = resizeCount;&#10;    T * newElement = new T[resizeCount];&#10;    for (int i = 0; i &#60; length; i++)&#10;        newElement[i] = element[i];&#10;    delete[] element;&#10;    element = newElement;&#10;    return true;&#10;&#125;&#10;// &#21024;&#38500;&#31532;k&#20010;&#20803;&#32032;&#24182;&#23558;&#23427;&#36820;&#22238;&#33267;x&#20013;&#10;template&#60;class T&#62;&#10;ResizeLinearList&#60;T&#62;&#38; ResizeLinearList&#60;T&#62;::Delete(int k, T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (Find(k, x))&#123;&#10;        // &#23558;&#31532;k&#20010;&#20803;&#32032;&#21518;&#30340;&#20803;&#32032;&#21521;&#21069;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;        for (int i = k; i &#60; length; i++)&#10;            element[i - 1] = element[i];&#10;        length--;&#10;        // &#22914;&#26524;&#24403;&#21069;&#20803;&#32032;&#25968;&#37327;&#31561;&#20110;1/4&#30340;&#23481;&#37327;&#65292;&#21017;&#23558;&#26368;&#22823;&#23481;&#37327;&#32553;&#23567;&#19968;&#21322;&#10;        if (length == (int)MaxSize * 0.25)&#10;            Resize((int)0.5 * MaxSize);&#10;        return *this;&#10;    &#125;&#10;    else&#10;        throw OutOfBounds();&#10;&#125;&#10;&#10;// &#22312;&#31532;k&#20010;&#20803;&#32032;&#20043;&#21518;&#25554;&#20837;x&#10;template&#60;class T&#62;&#10;ResizeLinearList&#60;T&#62;&#38; ResizeLinearList&#60;T&#62;::Insert(int k, const T&#38;x)&#123;&#10;    // &#22914;&#26524;&#19981;&#23384;&#22312;&#31532;k&#20010;&#20803;&#32032;&#65292;&#21017;&#24341;&#21457;&#24322;&#24120;OutOfBounds&#10;    if (k&#60;0 || k&#62;length)&#10;        throw OutOfBounds();&#10;    // &#22914;&#26524;&#34920;&#24050;&#28385;&#65292;&#21017;&#22686;&#21152;2&#20493;&#23481;&#37327;&#10;    if (length == MaxSize)&#10;        Resize(2*MaxSize);&#10;    // &#21521;&#21518;&#31227;&#21160;&#19968;&#20010;&#20301;&#32622;&#10;    for (int i = length - 1; i &#62;= k; i--)&#10;        element[i + 1] = element[i];&#10;    element[k] = x;&#10;    length++;&#10;    return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的例子在<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/blob/master/LinearList/ResizeLinearList.h" target="_blank" rel="external">ResizeLinearList</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《数据结构算法与应用：C++语言描述》第3章数据描述的笔记。</p>
<p>本章的重点是介绍线性表，但一个主要目标是让大家明白–<strong>数据可以用不同的形式进行描述或存储在计算机存储器中。</strong>最常见的数据买欧式方法有：<strong>公式化描述、链接描]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序性能3--渐进符号]]></title>
    <link href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/"/>
    <id>http://ccc013.github.io/2016/06/07/程序性能3-渐进符号/</id>
    <published>2016-06-07T01:25:59.000Z</published>
    <updated>2016-06-07T01:42:52.018Z</updated>
    <content type="html"><![CDATA[<p>继续上一节的笔记。前2节的笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能1–空间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能2–时间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/">程序性能3–渐进符号</a></li>
</ol>
<h3 id="u6E10_u8FDB_u7B26_u53F7_28O_2C_24_5Ctheta_2Co_2C_5COmega_24_29"><a href="#u6E10_u8FDB_u7B26_u53F7_28O_2C_24_5Ctheta_2Co_2C_5COmega_24_29" class="headerlink" title="渐进符号(O,$\theta,o,\Omega$)"></a>渐进符号(O,$\theta,o,\Omega$)</h3><p>  确定程序的操作计数和执行步数的两个重要原因如下：</p>
<ol>
<li>为了比较两个完成同一功能的程序的时间复杂性；</li>
<li><p>为了预测随着实例特征的变化，程序运行时间的变化量。</p>
<p>但上述两个方法都各有其缺点，使用操作计数会集中在某些”关键”的操作，而忽略了所有其他操作。使用执行步数则试图通过关注所有的操作以便克服操作技术方法的不足，但是，”执行步”的概念本身就不精确，如指令<code>x = y</code>和<code>x = y+z+(x/y)</code>都可以被称为一步。因此由于执行步数的不精确性，所以不便用来进行比较。</p>
<p>因此，这里引入新的符号(或记号)，利用新符号可以写出关于程序时间和空间复杂性的具体公式(尽管不够精确)。这种符号称为<strong>渐进符号</strong>，它可以描述大型实例特征下时间或空间复杂性的具体表现。</p>
<p>在接下来的讨论中，$f(n)$表示一个程序的时间或空间复杂性，它是实例特征n的函数，由于一个程序的时间和空间需求是一个非负值，所以可以假定对于n的所有取值，函数$f$的值非负。由于n表示一个实例特征，所以可以进一步假定$n\ge 0$。即将讨论的渐进符号允许我们对于足够大的n值，给出$f$的上限值和/或下限值。</p>
</li>
</ol>
<h4 id="u5927_u5199O_u7B26_u53F7"><a href="#u5927_u5199O_u7B26_u53F7" class="headerlink" title="大写O符号"></a>大写O符号</h4><p>  大写O符号给出了函数$f$的一个上限。</p>
<blockquote>
<p>$f(n) = O(g(n))$ 当且仅当存在正的常数$c$和$n_0$，使得对于所有的$n\ge n_0$,有$f(n)\le cg(n)$。</p>
</blockquote>
<p>上述定义表明，函数f多是函数g的c倍，除非n小于$n_0$。因此对于足够大的n(如$n\ge n_0$)，g是f的一个上限。在为函数f提供一个上限函数g时，通常使用比较简单的函数形式，比较典型的形式是含有n的单个项(带一个常数系数)。下图列出了一些常用的g函数及其名称。下图中的对数函数$log n$，没有给出对数基，原因是对于任何大于1的常数a和b都有$log_a n = {log_b n / log_b a}$,所以$log_an$和$log_bn$都有一个相对的乘法系数$1 / log_b a$,其中a是一个常量。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B8%90%E8%BF%9B%E5%87%BD%E6%95%B0.png" alt="此处输入图片的描述"></p>
<h5 id="u4E3E_u4F8B_u8BF4_u660E"><a href="#u4E3E_u4F8B_u8BF4_u660E" class="headerlink" title="举例说明"></a>举例说明</h5><blockquote>
<p>[线性函数]考察函数$f(n) = 3n + 2$</p>
</blockquote>
<p>  当$n\ge 2$时，有$3n+2\ge 3n+n=4n$，所以有$f(n) = O(n)$,$f(n)$是一个线性变换的函数。当采用其他方式也可以得到同样的结论，例如,对于$n\gt 0$,有$3n+2\le 10n$,可以通过选择c=10以及$n_0\gt 0$来满足大O定义。</p>
<p>  对于其他线性的函数，如3n+3,100n+6，都满足n的大O定义。</p>
<blockquote>
<p>[平方函数]考察函数$f(n) = 10n^2 + 4n + 2$</p>
</blockquote>
<p>  对于$n\ge 2$,有$f(n)\le 10n^2+5n$,而又当$n\ge 5$,有$5n\le n^2$,因此对于$n\ge n_0 = 5,f(n) \le 10n^2+n^2 = 11n^2,所以f(n) = O(n^2)$。</p>
<blockquote>
<p>[指数函数] 考察函数$f(n) = 6*2^n+n^2$</p>
</blockquote>
<p>  对于$n\ge 4,有n^2 \le 2^n，所以对于n \ge 4,有f(n) \le 6<em>2^n + 2^n = 7</em>2^n,因此6*2^n + n^2 = O(2^n)$。</p>
<h5 id="u677E_u6563_u754C_u9650"><a href="#u677E_u6563_u754C_u9650" class="headerlink" title="松散界限"></a>松散界限</h5><p>  在上述例子中，如$n\ge 2,有3n+3\le 3n^2,所以3n+3=O(n^2),虽然n^2是3n+3$的一个上限，但不是最小上限，因为可以找到一个更小的函数来满足大O定义。</p>
<p>  同样地，对于其他例子也是可以有找到其他g(n)函数来满足大O定义，但是我们需要寻找的是<strong>最小上限</strong>，这也是为了让语句$f(n) = O(g(n))$有实际意义。</p>
<p>  对于一些错误界限，如$3n+2 \neq O(1)$,可以使用反证法来证明。</p>
<p>下面一个定理给出了一个非常有用的结论，利用该结论可以获取f(n)的序(即$f(n) = O(g(n))$中的g(n))，这里，f(n)是一个关于n的多项式。</p>
<blockquote>
<p>如果$f(n) = a_m n^m + … + a_1n+a_0,且a_m\gt 0,则f(n) = O(n^m)。$</p>
<p>证明： 对于所有的$n\ge 1$,有：<br>$$<br>f(n)  \le \sum_{i=0}^m | a_i| n^i \<br>     \hspace{45pt} \le n^m\sum_0^m |a_i| n^{i-m}\<br>     \hspace{30pt} \le n^m\sum_0^m |a_i|<br>$$</p>
</blockquote>
<p>这里可以使用该定理来应用到前面的例子中，可以得到同样的结果。</p>
<blockquote>
<p>[大O比率定理]对于函数$f(n)和g(n),若\lim<em>{n\to \infty}f(n)/g(n)存在$，则$f(n)=O(g(n))$当且仅当存在确定的常数c，有 $\lim</em>{n\to \infty}f(n)/g(n)\le c$。</p>
</blockquote>
<h4 id="24_5COmega_24_u7B26_u53F7"><a href="#24_5COmega_24_u7B26_u53F7" class="headerlink" title="$\Omega$符号"></a>$\Omega$符号</h4><p>  $\Omega$符号与大O符号类型，它用来估算函数f的下限。</p>
<blockquote>
<p>$f(n) = \Omega (g(n))$当且仅当存在正的常数$c和n_0$,使得对于所有的$n\ge n_0,有f(n) \ge cg(n)$。</p>
</blockquote>
<p>上述定义表明了在$n\ge n_0$的前提下，函数f至少是函数g的c倍。与大O定义的应用一样，<strong>通常仅使用单项形式的g函数。</strong>同时，它也具有以下定理来求g函数。</p>
<blockquote>
<p>如果$f(n) = a_m n^m + … + a_1n+a_0,且a_m\gt 0,则f(n) = \Omega (n^m)。$</p>
</blockquote>
<p>  根据这个定理可知，$3n+2 = \Omega(n)$,$10n^2+4n+2 = \Omega(n^2)$,$100n^4+3500n^2+82n+8=\Omega(n^4)$。</p>
<blockquote>
<p>[$\Omega$比率定理]对于函数$f(n)和g(n),若\lim<em>{n\to \infty}f(n)/g(n)存在$，则$f(n)=\Omega(g(n))$当且仅当存在确定的常数c，有 $\lim</em>{n\to \infty}f(n)/g(n)\le c$。   </p>
</blockquote>
<h4 id="24_5Ctheta_24__u7B26_u53F7"><a href="#24_5Ctheta_24__u7B26_u53F7" class="headerlink" title="$\theta$ 符号"></a>$\theta$ 符号</h4><p>  $\theta$ 符号适用于同一个函数g既可以作为f的上限也可以作为f的下限的情形。</p>
<blockquote>
<p>定义：$f(n) = \theta (g(n))$当且仅当存在正常数$c_1,c_2和某个n_0$,使得对于所有的$n\ge n_0$,有$c_1g(n)\le f(n) \le c_2g(n)$。</p>
</blockquote>
<p>  上述定义表明了在$n\ge n_0$的情况下，函数f介于函数g的$c_1倍和c_2倍$之间。它通常仅使用单项形式的g函数。</p>
<p>同样地，也具有下面两个定理</p>
<blockquote>
<p>如果$f(n) = a_m n^m + … + a_1n+a_0,且a_m\gt 0,则f(n) = \theta (n^m)。$</p>
</blockquote>
<p>  根据这个定理，可知$3n+2 = \theta(n)$,$10n^2+4n+2 = \theta(n^2)$,$100n^4+3500n^2+82n+8=\theta(n^4)$。</p>
<blockquote>
<p>[$\theta$比率定理]对于函数$f(n)和g(n),若\lim<em>{n\to \infty}f(n)/g(n)存在$，则$f(n)=\theta(g(n))$当且仅当存在确定的常数c，有 $\lim</em>{n\to \infty}f(n)/g(n)\le c$及$\lim_{n\to \infty}g(n)/f(n)\le c$。</p>
</blockquote>
<h4 id="u5C0F_u5199o_u7B26_u53F7"><a href="#u5C0F_u5199o_u7B26_u53F7" class="headerlink" title="小写o符号"></a>小写o符号</h4><blockquote>
<p>定义：$f(n) = o(g(n))$当且仅当$f(n) = O(g(n)),且f(n) \neq \Omega (g(n))$。</p>
</blockquote>
<p>例如，因为$3n+2 = O(n^2)$,且$3n+2\neq \Omega(n^2)$,所有$3n+2 = o(n^2)$,但$3n+2\neq o(n)$。</p>
<p>（那么其实就是可以理解为：如果$f(n) = \theta (g(n))$,则有$f(n) \neq o(g(n))$。）</p>
<h4 id="u7279_u6027"><a href="#u7279_u6027" class="headerlink" title="特性"></a>特性</h4><blockquote>
<p>定理：对于任一个实数$x \gt 0$和任一个实数$\epsilon \gt 0$,下面的结论都是正确的：<br>1) 存在某个$n_0$使得对于任何$n\gt n_0$,有$(logn)^x\lt(logn)^{x+\epsilon}$.<br>2)存在某个$n_0$使得对于任何$n\gt n_0$,有$(logn)^x\lt n$.<br>3)存在某个$n_0$使得对于任何$n\gt n_0$,有$n^x \lt n^{x+\epsilon}$.<br>4)对于任意实数y，存在某个$n_0$使得对于任何$n\gt n_0$,有$n^x(logn)^y \lt n^{x+\epsilon}$.<br>5)存在某个$n_0$使得对于任何$n\gt n_0$,有$n^x \lt 2^n$。</p>
</blockquote>
<p>根据上述定理，可以有如下结论：$n^3 + n^2 logn = \theta(n^3)$(因为$n^3 \le n^3 + n^2 logn \le 2n^3$);</p>
<p>下面两张图，第一张图中列出了一些常用的有关$O,\Omega,\theta$的标记，在该表中除n以外所有符号均为正常数。第二张图给出了一些关于和与积的有用的引用规则，其中$\oplus 可以是O,\Omega,\theta$之一。<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E6%A0%87%E8%AE%B0.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E8%A7%84%E5%88%99.png" alt="此处输入图片的描述"></p>
<h4 id="u590D_u6742_u6027_u5206_u6790_u4E3E_u4F8B"><a href="#u590D_u6742_u6027_u5206_u6790_u4E3E_u4F8B" class="headerlink" title="复杂性分析举例"></a>复杂性分析举例</h4><p>  根据渐进符号，这里重新检查下上一节分析的时间复杂性，对于函数<code>Sum</code>,分析如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A71.png" alt="此处输入图片的描述"><br>同理对于其他函数也有这样的分析，如下图所示：<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A72.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A73.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A74.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A75.png" alt="此处输入图片的描述"><br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E6%80%A76.png" alt="此处输入图片的描述"><br>当按照执行步数来分析上述函数的时候，可以把$t_p(n) = \theta (g(n))$,$t_p(n) = O(g(n))或t_p(n) = \Omega (g(n))$看成一条程序P的语句(用于计算时间),因为每一步仅需要$\theta(1)$的执行时间。<br>接下来就是从全局角度来考察程序的渐进复杂性的需要，下面会举例来阐述这种方法。</p>
<blockquote>
<p>[折半搜索]下列程序是一个用在有序数组a[0:n-1]中查找元素x的函数。变量left和right是用来记录查找的起始点和结束点。开始时，将在0到n-1之间进行查找，所以left和right的初值分别是0和n-1。遵循的规律是当前仅当x是a[left:right]中的元素时，x是a[0:n-1]中的元素。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#25240;&#21322;&#25628;&#32034;*/&#10;template&#60;class T&#62;&#10;int BinarySearch(T a[], const T&#38; x, int n)&#123;&#10;    int left = 0, right = n - 1;&#10;    while (left &#60;= right)&#123;&#10;        int middle = (left + right) / 2;&#10;        if (x == a[middle])&#10;            return middle;&#10;        if (x &#62; a[middle])&#10;            left = middle + 1;&#10;        else&#10;            right = middle - 1;&#10;    &#125;&#10;    // &#26410;&#25214;&#21040;x&#10;    return -1;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在折半搜索中，While的循环(最后一次除外)都将以减半的比例缩小搜索的范围，所以该循环在最坏情况下虚执行$\theta(logn)$次，由于每次循环需要耗时$\theta(1)$，因此在最坏的情况下，总的时间复杂性是$\theta(logn)$。</p>
<p>第二个例子是<a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%282%29-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">上一节</a>中的插入排序例子中，对于每个i值，最内部的循环在最坏情况下时间复杂性是$\theta(1)$,因此在最坏情况下，该例子的时间复杂性是$\theta(n^2)$,而最好的情况是$\theta(n)$。程序的渐进复杂性可由$\Omega(n) 和O(n^2)$给出。</p>
<p>小写o符号通常用于执行步数的分析。执行步数$3n+O(n)$表示3n加上上限是n的项。在进行这种分析时，可以忽略步数少于$\theta(n)$的程序部分。<br>还可以扩充渐进符号的定义，采用具有多个变量的函数。例如，$f(n,m)=O(g(n,m))$当且仅当存在正常量$c,n_0,m_0$,使得对于所有的$n\ge n_0和所有的m\ge m_0$，有$f(n,m)\le cg(n,m)$。</p>
<h3 id="u5B9E_u9645_u590D_u6742_u6027"><a href="#u5B9E_u9645_u590D_u6742_u6027" class="headerlink" title="实际复杂性"></a>实际复杂性</h3><p>  根据前面几节内容，我们知道一个程序的时间复杂性通常是其实例特征的函数，在确定程序的时间需求是如何随着实例特征的变化而变化时，这种函数将非常有用。<br>  下面两张图给出各种函数是如何随着n的增长而变化的。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%AE%9E%E9%99%85%E5%A4%8D%E6%9D%82%E6%80%A71.png" alt="此处输入图片的描述"><br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%AE%9E%E9%99%85%E5%A4%8D%E6%9D%82%E6%80%A72.png" alt="此处输入图片的描述"><br>由图中可以看出随着n的增长，$2^n$的增长极快，如果需要执行$2^n$执行步，那么n=40时，执行步数将大约$1.1<em>10^{12}$，在一台每秒执行$10^9$步的计算机中，该程序大约需要执行18.3分钟；而如果n=50，则需要执行13天，n=60时，需要执行310.56年。因此，*</em>具有指数复杂性的程序仅适合于小的n(典型地取$n\le 40$)。<br>  此外，具有高次多项式复杂性的函数也必须限制使用，比如对于需要执行$n^{10}$执行步的程序，当n=10时，同样是每秒执行$10^9$步的计算机中，需要10秒，但是n=100，这个时间就是3171年了。<br>  下面一张图很好地给出了在每秒执行$10^9$条指令的计算机上执行复杂性是$f(n)$所需要的时间。<br>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%AE%9E%E9%99%85%E5%A4%8D%E6%9D%82%E6%80%A73.png" alt="此处输入图片的描述"></p>
<h3 id="u6027_u80FD_u6D4B_u91CF"><a href="#u6027_u80FD_u6D4B_u91CF" class="headerlink" title="性能测量"></a>性能测量</h3><blockquote>
<p>性能测量主要关注于得到一个程序实际需要的空间和时间。</p>
</blockquote>
<p>我们忽略编译所需要的时间和空间是因为每个程序仅需要编译一次(当然是在调试完成之后)，而可以运行无数次。不过，如果测试的次数要比运行最终代码的次数多，则在程序测试期间，编译所需要的时间和空间也是很重要的。<br>而基于以下原因，我们不能精确地测量一个程序运行时所需要的时间和空间:</p>
<ul>
<li>指令空间和数据空间的大小是由编译器在编译时确定的，所以不必要测量这些数据。</li>
<li>根据前几节介绍的方法，可以很准确地估算递归栈空间和变量动态分配所需要的空间。</li>
</ul>
<p>而为了得到程序的执行时间，需要一个定时机制。在C++中包含一个头文件是<code>time.h</code>，定义了一个<code>clock()</code>的函数，它可以返回自程序启动以来所流逝的“滴答”数，然后再将流逝的“滴答”数除以常量<code>CLK_TCK</code>,就可以得到流逝的秒数。</p>
<p>接下来，我们选择作为实验的程序是<a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%282%29-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">上一节</a>中的插入排序<code>InsertionSort</code>函数。而要测量该函数在最坏情况下所需要的时间，首先需要：</p>
<ol>
<li>确定需要测定执行时间的n值；</li>
<li>对于上面的每个n，给出能导致最坏复杂性的测试数据。</li>
</ol>
<h4 id="u9009_u62E9_u5B9E_u4F8B_u7684_u5927_u5C0F"><a href="#u9009_u62E9_u5B9E_u4F8B_u7684_u5927_u5C0F" class="headerlink" title="选择实例的大小"></a>选择实例的大小</h4><p>  可以根据以下两个因素来确定使用哪些n值：</p>
<ul>
<li>程序执行的时间</li>
<li>程序执行的次数</li>
</ul>
<p>在之前的分析中可以知道在最坏的情况下，插入排序的复杂性是$\theta(n^2)$。实践过程中，通常需要3个以上的n值，其原因如下：</p>
<ol>
<li>渐进分析仅给出了对于足够大的n值时程序的复杂性。对于小的n值，程序的运行时间可能并满足渐近曲线。为了确定渐近曲线以外的点，需要使用多个n值。</li>
<li>即使在满足渐近曲线的区间内，程序实际运行时间也可能不满足预定的渐近曲线，原因是在进行渐进分析时，忽略了许多低层次的时间需求。例如，一个程序的渐进复杂性是$\theta(n^2)$，而它的实际复杂性可以是$c_1n^2+c_2nlogn+c_3n+c_4$,或其他任何最高项是$c_1n^2$的函数，其中$c_1$是常数且大于0。</li>
</ol>
<p>而在我们用来实验的插入排序程序，我们期望获得$n\lt 100$的渐进复杂性，所以对于$n\gt 100$的情况，可能只需奥很少量的估算值，一个合理的选择是$n=200,300,400,\ldots,1000$。</p>
<h4 id="u8BBE_u8BA1_u6D4B_u91CF_u6570_u636E"><a href="#u8BBE_u8BA1_u6D4B_u91CF_u6570_u636E" class="headerlink" title="设计测量数据"></a>设计测量数据</h4><p>  对于许多程序，可以手工或者用计算机来产生能导致最好和最后复杂性的测试数据。然而，对于平均的复杂性，通常很难设计相应的数据。如对于我们要用来实验的<code>InsertionSort</code>函数来说，对任何n来说，能导致最坏复杂性的测试数据应是一个递减的序列，如$n,n-1,n-2,\ldots,1$;导致最好复杂性的测试数据应是一个递增的序列，如$0,1,2,\ldots,n-1$。我们很难提供一组测试数据使得<code>InsertionSort</code>函数表现出平均的复杂性。</p>
<h4 id="u8FDB_u884C_u5B9E_u9A8C"><a href="#u8FDB_u884C_u5B9E_u9A8C" class="headerlink" title="进行实验"></a>进行实验</h4><p>  当确定了实例大小，并给出了测试数据，就可以开始进行实验了。<br>  实验运行的代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#60;string&#62;&#10;#include&#60;time.h&#62;&#10;&#10;/*&#21521;&#19968;&#20010;&#26377;&#24207;&#25968;&#32452;&#20013;&#25554;&#20837;&#20803;&#32032;,&#20551;&#23450;a&#30340;&#22823;&#23567;&#36229;&#36807;n*/&#10;template&#60;class T&#62;&#10;void Insert(T a[], int&#38; n, const T&#38; x)&#123;&#10;    int i;&#10;    for (i = n - 1; i &#62;= 0 &#38;&#38; x &#60; a[i]; i--)&#10;        a[i + 1] = a[i];&#10;    a[i + 1] = x;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InsertionSort(T a[], int n)&#123;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        T t = a[i];&#10;        Insert(a, i, t);&#10;    &#125;&#10;&#125;&#10;&#10;int main()&#123;&#10;    using std::cout;&#10;    using std::endl;&#10;    using std::cin;&#10;&#10;    int a[1000], step = 10;&#10;    clock_t start, finish;&#10;    for (int n = 0; n &#60;= 1000; n += step) &#123;&#10;        for (int i = 0; i &#60; n; i++)&#10;            a[i] = n - i; // &#21021;&#22987;&#21270;&#10;        start = clock();&#10;        InsertionSort(a, n);&#10;        finish = clock();&#10;        cout &#60;&#60; n &#60;&#60; &#39; &#39; &#60;&#60;(float)(finish - start) / CLK_TCK &#60;&#60; endl;&#10;        if (n == 100) &#10;            step = 100;&#10;    &#125;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果如下图所示<br><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%AB%A02%E5%AE%9E%E9%AA%8C%E5%9B%BE1.png" alt="此处输入图片的描述"><br>由上图可以得出这样的结论，排序300个元素以内的数组不需要时间，而排序400-800个元素的数组所花费的时间是一样的。但这个结论并不正确，主要是因为对于计时函数<code>clock()</code>来说，所需要的运行时间太小了。而且，所有测量的精确度均为一个时钟“滴答”。书本中使用的计算机的<code>CLK_TCK=18.2</code>,不过我使用的是<code>Visual Studio</code>中<code>CLK_TCK=1000</code>,即这里测量的误差范围是一个“滴答”时间<code>1/1000 = 0.001</code>秒。<br>而为了提高测量的精确度，对于每个n值，可以重复排序若干次。这里限定的条件是10个时钟“滴答”时间。代码及实验结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#60;string&#62;&#10;#include&#60;time.h&#62;&#10;&#10;/*&#21521;&#19968;&#20010;&#26377;&#24207;&#25968;&#32452;&#20013;&#25554;&#20837;&#20803;&#32032;,&#20551;&#23450;a&#30340;&#22823;&#23567;&#36229;&#36807;n*/&#10;template&#60;class T&#62;&#10;void Insert(T a[], int&#38; n, const T&#38; x)&#123;&#10;    int i;&#10;    for (i = n - 1; i &#62;= 0 &#38;&#38; x &#60; a[i]; i--)&#10;        a[i + 1] = a[i];&#10;    a[i + 1] = x;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InsertionSort(T a[], int n)&#123;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        T t = a[i];&#10;        Insert(a, i, t);&#10;    &#125;&#10;&#125;&#10;&#10;int main()&#123;&#10;    using std::cout;&#10;    using std::endl;&#10;    using std::cin;&#10;&#10;    int a[1000],n,i, step = 10;&#10;    long counter;&#10;    float seconds;&#10;    clock_t start, finish;&#10;    for (int n = 0; n &#60;= 1000; n += step)&#123;&#10;        // &#33719;&#24471;&#23545;&#24212;&#20110;n&#20540;&#30340;&#26102;&#38388;&#10;        start = clock();&#10;        counter = 0;&#10;        while (clock() - start &#60; 10)&#123;&#10;            counter++;&#10;            for (i = 0; i &#60; n; i++)&#10;                a[i] = n - i;&#10;            InsertionSort(a, n);&#10;        &#125;&#10;        finish = clock();&#10;        seconds = (float)(finish - start) / CLK_TCK;&#10;        cout &#60;&#60; n &#60;&#60; &#39; &#39; &#60;&#60; counter&#60;&#60;&#39; &#39; &#60;&#60; seconds&#60;&#60;&#39; &#39;&#60;&#60; seconds/counter&#60;&#60; endl;&#10;        if (n == 100)&#10;            step = 100;&#10;    &#125;&#10;    system(&#34;pause&#34;);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E7%AB%A02%E5%AE%9E%E9%AA%8C%E5%9B%BE2.png" alt="此处输入图片的描述"><br>上图中每行数据分别是n值，重复次数，总时间以及每次排序时间。</p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  第二章有关程序性能的笔记就记录到这里了。本章主要是介绍了算法的基础，对于程序的空间和时间复杂性的介绍，还介绍了4种渐进符号，然后就是给出了一个例子来测量运行时间。<br>  本章是一个学习数据结构和算法的基础，因为我还是初学者，所以笔记主要是记录书中的要点，比较少有写上自己的理解，不过，相信随着练习，会慢慢掌握数据结构和算法的知识点的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>继续上一节的笔记。前2节的笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序性能2--时间复杂性]]></title>
    <link href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    <id>http://ccc013.github.io/2016/06/04/程序性能2-时间复杂性/</id>
    <published>2016-06-04T05:32:07.000Z</published>
    <updated>2016-06-07T01:42:35.303Z</updated>
    <content type="html"><![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能1–空间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能2–时间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/">程序性能3–渐进符号</a></li>
</ol>
<h3 id="u65F6_u95F4_u590D_u6742_u6027"><a href="#u65F6_u95F4_u590D_u6742_u6027" class="headerlink" title="时间复杂性"></a>时间复杂性</h3><h4 id="u65F6_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210"><a href="#u65F6_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210" class="headerlink" title="时间复杂性的组成"></a>时间复杂性的组成</h4><blockquote>
<p>影响一个程序空间复杂性的因素也能影响程序的时间复杂性。</p>
<p>一个程序P所占用的时间T(P) = 编译时间 + 运行时间。编译时间与实例的特征无关。另外，可以假定一个编译过的程序可以运行若干次而不需要重新编译。因此我们将主要关注程序的运行时间，运行时间通常用”$t_p$(实例特征)”来表示。</p>
</blockquote>
<p>存在这一个事实：<strong>一个算术操作所需要的时间取决于操作数的类型(int,float,double等),这个事实增加了获得一个精确的计算公式的烦琐程度。所以必须按照数据类型对操作进行分类。</strong></p>
<p>有两个更可行的方法可用来估算运行时间：</p>
<ol>
<li>找出一个或更多的操作，确定这些关键操作所需要的执行时间；</li>
<li>确定程序总的执行步数。</li>
</ol>
<h4 id="u64CD_u4F5C_u8BA1_u6570"><a href="#u64CD_u4F5C_u8BA1_u6570" class="headerlink" title="操作计数"></a>操作计数</h4><p>估算一个程序或函数的时间复杂性的一种方式就是首先选择一种或多种操作(如加、乘和比较等),然后确定这种(些)操作分别执行了多少次。这种方法是否成功取决于识别关键操作的能力，这些关键操作对时间复杂性的影响最大。下面的几个例子都采用了这种方法。</p>
<h5 id="u4F8B1__u591A_u9879_u5F0F_u6C42_u503C"><a href="#u4F8B1__u591A_u9879_u5F0F_u6C42_u503C" class="headerlink" title="例1 多项式求值"></a>例1 多项式求值</h5><blockquote>
<p> 考察多项式$P(x) = \sum_{i=0}^n c_i x^n$。如果$c_n \neq 0$,则P是一个n维多项式。</p>
</blockquote>
<p>下列程序实现了多项式求值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#22810;&#39033;&#24335;&#27714;&#20540;*/&#10;template&#60;class T&#62;&#10;T PolyEval(T coeff[], int n, const T&#38;x)&#123;&#10;    // &#35745;&#31639;n&#27425;&#22810;&#39033;&#24335;&#30340;&#20540;&#65292;coeff[0:n]&#20026;&#22810;&#39033;&#24335;&#30340;&#31995;&#25968;&#10;    T y = 1, value = coeff[0];&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        y *= x;&#10;        value += y*coeff[i];&#10;    &#125;&#10;    return value;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的for循环中的循环条件，书中代码是有点错误的，应该是<code>i&lt;n</code>,不能带上等于。</p>
<p>在这个例子中，假定根据for循环内部所执行的加和乘的次数来估算时间复杂性。可以使用维数n作为实例特征。进入for循环的总次数为n，每次循环执行1次加法和乘法(这种操作计数不包含循环控制变量i每次递增所执行的加法)。加法的次数为n，乘法的次数为2n。</p>
<p>第二种求解多项式的方法是使用<strong>Horner</strong>法则，它是采用如下的分解式计算一个多项式：<br>$$<br>  P(x) = (\ldots(c<em>n*x+c</em>{n-1})<em>x+c_{n-2})</em>x+c_{n-3})<em>x+\ldots)</em>x+c_0<br>$$<br>代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#20351;&#29992;Horner&#27861;&#21017;&#27714;&#35299;&#22810;&#39033;&#24335;*/&#10;template&#60;class T&#62;&#10;T Horner(T coeff[], int n, const T&#38;x)&#123;&#10;    T value = coeff[n-1];&#10;    for (int i = 2; i &#60;= n; i++)&#123;&#10;        value = value*x + coeff[n - i];&#10;    &#125;&#10;    return value;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>书中的代码也是有些问题，n应该代表的是<code>coeff</code>这个数组的大小，所以首先是<code>T value = coeff[n-1];</code>这句代码，书中是直接等于<code>coeff[n]</code>，这里应该是<code>coeff[n-1]</code>,然后就是for循环的初始条件，是<code>i=2</code>，而不是<code>i=1</code>。</p>
<p>使用<strong>Horner</strong>后，加法还是需要n次，但是乘法也只需要n次即可。因此，使用这个函数会比<code>PolyEval</code>函数更快。</p>
<h5 id="u4F8B2__u8BA1_u6570_u6392_u5E8F"><a href="#u4F8B2__u8BA1_u6570_u6392_u5E8F" class="headerlink" title="例2 计数排序"></a>例2 计数排序</h5><p>这里通过两段代码实现计数排序的方法。</p>
<blockquote>
<p>元素在队列中的名次（ r a n k）可定义为队列中所有比它小的元素数目加上在它左边出现的与它相同的元素数目。<br>例如，给定一个数组 a=[4, 3, 9, 3, 7]作为队列，则各元素<br>的名次为r =[2, 0, 4, 1, 3]</p>
</blockquote>
<p>这里我的实现的代码方法跟书本有所不一样，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Rank(T a[], int n, int r[])&#123;&#10;    // &#35745;&#31639;a[0:n-1]&#20013;n&#20010;&#20803;&#32032;&#30340;&#25490;&#21517;&#10;    for (int i = 0; i &#60; n; i++)&#10;        r[i] = 0;       // &#21021;&#22987;&#21270;&#25490;&#21517;&#25968;&#32452;&#10;    // &#36880;&#23545;&#27604;&#36739;&#25152;&#26377;&#30340;&#20803;&#32032;&#10;    for (int i = 0; i &#60; n; i++)&#123;&#10;        for (int j = i+1; j &#60; n; j++)&#123;&#10;            if (a[i] &#60;= a[j])&#10;                r[j]++;&#10;            else&#10;                r[i]++;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>书中给出的代码，其比较次数是1+2+3+···+n-1 = $(n-1)n\over 2$<br>而我给出的代码实现，其比较总次数也是相同的，$(n-1)n\over 2$,差别应该是在比较是<code>(n-1)+(n-2)+···+2+1</code>.</p>
<blockquote>
<p>根据例2中计算出数组中每个元素的名次，就可以利用元素名次按照递增的次序对数组中的元素进行重新排列，使得$a[0]\le a[1]\le \ldots \le a[n-1]$</p>
</blockquote>
<p>下面代码是使用了一个附加的数组u实现按名次排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#21033;&#29992;Rank&#20989;&#25968;&#20013;&#24471;&#21040;&#30340;&#27599;&#20010;&#20803;&#32032;&#30340;&#21517;&#27425;&#65292;&#23545;&#25968;&#32452;&#37325;&#26032;&#25490;&#24207;*/&#10;template&#60;class T&#62;&#10;void Rearrange(T a[], int n, int r[])&#123;&#10;    // &#25353;&#39034;&#24207;&#37325;&#25490;&#25968;&#32452;a&#20013;&#30340;&#20803;&#32032;&#65292;&#20351;&#29992;&#38468;&#21152;&#25968;&#32452;u&#10;    T *u = new T[n];&#10;    // &#22312;u&#20013;&#31227;&#21160;&#21040;&#27491;&#30830;&#30340;&#20301;&#32622;&#10;    for (int i = 0; i &#60; n; i++)&#10;        u[r[i]] = a[i];&#10;    // &#31227;&#22238;&#21040;a&#20013;&#10;    for (int i = 0; i &#60; n; i++)&#10;        a[i] = u[i];&#10;    delete[] u;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是书中给出的实现方法，这个方法需要移动元素<code>2n</code>次，因此，加上例2中的实现，整个排序需要执行，$(n-1)n\over 2$次比较操作和<code>2n</code>次移动操作，这种排序方法被称为<strong>计数排序</strong>。</p>
<p>另一种方法是原地重排数组元素，不需要一个附加数组，实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Rearrange2(T a[], int n, int r[])&#10;&#123;// &#21407;&#22320;&#37325;&#25490;&#25968;&#32452;&#20803;&#32032;&#10;    for (int i = 0; i &#60; n; i++)&#10;        // &#33719;&#21462;&#24212;&#35813;&#25490;&#22312; a [ i ]&#22788;&#30340;&#20803;&#32032;&#10;    while (r[i] != i) &#123;&#10;        int t = r[i];&#10;        Swap(a[i], a[t]);&#10;        Swap(r[i], r[t]);&#10;    &#125;&#10;&#125;&#10;&#10;/*&#20132;&#25442;&#20004;&#20010;&#25968;&#32452;&#20803;&#32032;*/&#10;template&#60;class T&#62;&#10;void Swap(T&#38; a, T&#38;  b)&#123;&#10;    T temp = a;&#10;    a = b;&#10;    b = temp;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>新的程序需要执行的最少交换次数是0(初始数组已经是按序排列)，最大的交换次数是2(n-1)。注意每次交换操作至少把一个元素移动到正确位置(如a[i])，所以在n-1次交换之后，所有的n个元素已全部按序排列。</p>
<h5 id="u4F8B3__u9009_u62E9_u6392_u5E8F"><a href="#u4F8B3__u9009_u62E9_u6392_u5E8F" class="headerlink" title="例3 选择排序"></a>例3 选择排序</h5><blockquote>
<p>选择排序：首先找出最大的元素，把它移动到 a [ n-1 ]，然后在余下的 n-1个元素中寻找最大的元素并把它移动到a [ n-2 ]，如此进行下去，</p>
</blockquote>
<p>这是按照递增次序重排数组，也可以按照递减次序排序，就是每次找最小的元素，然后依次与数组的第一个元素交换。</p>
<p>代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#36873;&#25321;&#25490;&#24207;&#65292;&#25353;&#29031;&#36882;&#22686;&#27425;&#24207;&#25490;&#21015;*/&#10;template&#60;class T&#62;&#10;void selectionSort(T a[], int n)&#123;&#10;    for (int size = n; size &#62; 1; size--)&#123;&#10;        int max = Max(a, size);&#10;        Swap(a[max], a[size - 1]);&#10;    &#125;&#10;&#125;&#10;&#10;/*&#23547;&#25214;&#25968;&#32452;&#20013;&#26368;&#22823;&#20803;&#32032;*/&#10;template&#60;class T&#62;&#10;int Max(T a[], int n)&#123;&#10;    int pos = 0;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        if (a[pos] &#60; a[i])&#10;            pos = i;&#10;    &#125;&#10;    return pos;&#10;&#125;&#10;/*&#20132;&#25442;&#20004;&#20010;&#25968;&#32452;&#20803;&#32032;*/&#10;template&#60;class T&#62;&#10;void Swap(T&#38; a, T&#38;  b)&#123;&#10;    T temp = a;&#10;    a = b;&#10;    b = temp;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述函数中，Max函数会进行$(n-1)n\over 2$次比较操作，而Swap函数会进行<code>3(n-1)</code>次移动操作。</p>
<p>这种实现方式的选择排序的一个缺点是：<strong>即使元素已经按序排列，程序仍然继续运行</strong>。</p>
<p>因此为了终止不必要的循环，可以在查找最大元素期间检查数组是否已经按序排列，实现方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#21450;&#26102;&#32456;&#27490;&#30340;&#36873;&#25321;&#25490;&#24207;*/&#10;template&#60;class T&#62;&#10;void selectionSort2(T a[], int n)&#123;&#10;    bool isSorted = false;      // &#21152;&#20837;&#32456;&#27490;&#24490;&#29615;&#30340;&#26465;&#20214;&#10;    for (int size = n; !isSorted &#38;&#38; (size &#62; 1); size--)&#123;&#10;        int pos = 0;&#10;        isSorted = true;&#10;        // &#25214;&#26368;&#22823;&#20803;&#32032;&#10;        for (int i = 1; i &#60; size; i++)&#123;&#10;            if (a[pos] &#60;= a[i])&#10;                pos = i;&#10;            else&#10;                // &#27809;&#26377;&#25353;&#24207;&#25490;&#21015;&#10;                isSorted = false;&#10;        &#125;&#10;        Swap(a[pos], a[size - 1]);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种新的实现方法，最好的情况是数组已经是有序数组的情况，那么外部for循环仅需要执行一次，内部寻找最大元素的比较次数是n-1次。而最坏的情况则是外部for循环执行n-1次，执行的比较次数是$(n-1)n\over 2$次。</p>
<h5 id="u4F8B4__u5192_u6CE1_u6392_u5E8F"><a href="#u4F8B4__u5192_u6CE1_u6392_u5E8F" class="headerlink" title="例4 冒泡排序"></a>例4 冒泡排序</h5><blockquote>
<p>冒泡排序是采用一种“冒泡策略”把最大元素移到右部。在冒泡过程中，对相邻的元素进行比较，如果左边的元素大于右边的元素，则交换这两个元素。</p>
</blockquote>
<p>下面是冒泡排序的一种实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#19968;&#27425;&#20882;&#27873;*/&#10;template&#60;class T&#62;&#10;void Bubble(T a[], int n)&#123;&#10;    for (int i = 0; i &#60; n-1; i++)&#123;&#10;        if (a[i]&#62;a[i + 1])&#10;            Swap(a[i], a[i + 1]);&#10;    &#125;&#10;&#125;&#10;&#10;/*&#23545;&#25968;&#32452;a[0:n - 1]&#20013;&#30340;n&#20010;&#20803;&#32032;&#36827;&#34892;&#20882;&#27873;&#25490;&#24207;*/&#10;template &#60;class T&#62;&#10;void BubbleSort(T a[], int n)&#10;&#123;&#10;    for (int i = n; i&#62;1; i--)&#10;            Bubble(a, i);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种实现方法中元素比较的次数是$(n-1)n\over 2$。</p>
<p>冒泡排序跟选择排序一样，也是需要设计一个可以及时终止的冒泡排序函数。如果在一次冒泡过程中没有发生元素互换，这说明数组已经按序排列，没有必要再继续进行冒泡过程。</p>
<p>实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#19968;&#27425;&#20882;&#27873;*/&#10;template&#60;class T&#62;&#10;bool Bubble(T a[], int n)&#123;&#10;    // &#27809;&#26377;&#21457;&#29983;&#20132;&#25442;&#10;    bool isSwaped = false;&#10;    for (int i = 0; i &#60; n - 1; i++)&#123;&#10;        if (a[i]&#62;a[i + 1])&#123;&#10;            Swap(a[i], a[i + 1]);&#10;            // &#21457;&#29983;&#20102;&#20132;&#25442;&#10;            isSwaped = true;&#10;        &#125;&#10;    &#125;&#10;    return isSwaped;&#10;&#125;&#10;&#10;/*&#23545;&#25968;&#32452;a[0:n - 1]&#20013;&#30340;n&#20010;&#20803;&#32032;&#36827;&#34892;&#20882;&#27873;&#25490;&#24207;*/&#10;template &#60;class T&#62;&#10;void BubbleSort(T a[], int n)&#10;&#123;&#10;    for (int i = n; i &#62; 1 &#38;&#38; Bubble(a, i); i--)&#123;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在最好的情况下比较次数只需要n-1次，而最坏情况则和第一种实现方法相同。</p>
<h5 id="u4F8B5__u63D2_u5165_u6392_u5E8F"><a href="#u4F8B5__u63D2_u5165_u6392_u5E8F" class="headerlink" title="例5 插入排序"></a>例5 插入排序</h5><blockquote>
<p>因为只有一个元素的数组是一个有序数组，所以可以从仅包含欲排序的n个元素的第一个元素的数组开始。通过把第二个元素插入到这个单元数组中，可以得到大小为2的有序数组，并按照这个方法继续进行下去，最终将得到一个大小为n的有序数组。而这种排序方式就是插入排序。</p>
</blockquote>
<p>实现代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#21521;&#19968;&#20010;&#26377;&#24207;&#25968;&#32452;&#20013;&#25554;&#20837;&#20803;&#32032;,&#20551;&#23450;a&#30340;&#22823;&#23567;&#36229;&#36807;n*/&#10;template&#60;class T&#62;&#10;void Insert(T a[], int&#38; n, const T&#38; x)&#123;&#10;    int i;&#10;    for (i = n - 1; i &#62;= 0 &#38;&#38; x &#60; a[i]; i--)&#10;        a[i + 1] = a[i];&#10;    a[i + 1] = x;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InsertionSort(T a[], int n)&#123;&#10;    for (int i = 1; i &#60; n; i++)&#123;&#10;        T t = a[i];&#10;        Insert(a, i, t);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种排序方法，最好的情况下比较次数是n-1，最坏的情况是$(n-1)n\over 2$。</p>
<h4 id="u6267_u884C_u6B65_u6570"><a href="#u6267_u884C_u6B65_u6570" class="headerlink" title="执行步数"></a>执行步数</h4><p>  上述例子都是利用操作计数方法来估算程序的时间复杂性，但会忽略了所选择操作之外其他操作的开销。</p>
<blockquote>
<p>在统计步数的方法中，要统计程序/函数中所有部分的时间开销。与操作计数一样，执行步数也是实例特征的函数。尽管任一个特定的程序可能会有若干个特征(如输入个数，输出个数，输入和输出的大小)，但可以把执行步数看成是其中一部分特征的函数。通常是选择一些感兴趣的特征，例如，如要了解程序的运行时间(即时间复杂性)是如何随着输入个数的增加而增加的，这种情况下，可以把执行步数看成是输入个数的函数。因此在确定一个程序的执行步数之前，必须确切地知道将要采用的实力特征，这些特征不仅定义了执行步数表达式中的变量，而且定义了以多少次计算作为一步。</p>
</blockquote>
<h5 id="u64CD_u4F5C_u6B65"><a href="#u64CD_u4F5C_u6B65" class="headerlink" title="操作步"></a>操作步</h5><p><strong>操作步是独立于所选特征的任意计算单位</strong>，如10次加法可以视为一步，100次乘法也可以视为一步，但n次加法不能视为一步，其中n是实例特征。</p>
<h5 id="u7A0B_u5E8F_u6B65"><a href="#u7A0B_u5E8F_u6B65" class="headerlink" title="程序步"></a>程序步</h5><blockquote>
<p>程序步可以定义为一个语法或语义意义上的程序片段，该片段的执行时间独立于实例特征。</p>
</blockquote>
<p>可以通过设置一个全局变量<code>count</code>(其初始值为0)来确定一个程序或函数为完成其预定任务所需要的执行步数。可以把count引入到程序语句之中，每当原始程序或函数中的一条语句被执行时，就为count累加上该语句所需要的执行步数。</p>
<p>一个例子如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;T Sum(T a[], int n)&#10;&#123;// &#35745;&#31639; a[0:n - 1]&#20013;&#20803;&#32032;&#20043;&#21644;&#10;    T tsum = 0;&#10;    count++; // &#23545;&#24212;&#20110;tsum = 0&#10;    for (int i = 0; i &#60; n; i++) &#123;&#10;        count++; // &#23545;&#24212;&#20110;f o r&#35821;&#21477;&#10;        tsum += a[i];&#10;        count++; // &#23545;&#24212;&#20110;&#36171;&#20540;&#35821;&#21477;&#10;    &#125;&#10;    count++; // &#23545;&#24212;&#20110;&#26368;&#21518;&#19968;&#20010;f o r&#35821;&#21477;&#10;    count++; //&#23545;&#24212;&#20110;r e t u r n&#35821;&#21477;&#10;    return tsum;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数<code>Sum</code>是用来计算一个数组元素之和，通过添加一个全局变量<code>count</code>来计算函数的执行步数。可以得知每次调用该函数需要执行<code>2n+3</code>步。</p>
<h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>时间复杂性的介绍就到这里为止，时间复杂性是由编译时间和运行时间决定，但书中说明了编译时间是与实例特征关，同时也假定了一次编译后就可以不用编译就能进行若干次运行。而在估算运行时间的时候介绍了两种方法，分别是估算操作计数和执行步数，书中分别给出了不少例子，这里记录的例子主要是操作计数中的例子，包括了选择排序，计数排序，插入排序，冒泡排序等。</p>
<p>还是需要在不断编程中不断实践本小节所介绍的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序性能1--空间复杂性]]></title>
    <link href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    <id>http://ccc013.github.io/2016/06/04/程序性能1-空间复杂性/</id>
    <published>2016-06-04T05:26:58.000Z</published>
    <updated>2016-06-07T01:42:44.506Z</updated>
    <content type="html"><![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能1–空间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/">程序性能2–时间复杂性</a></li>
<li><a href="http://ccc013.github.io/2016/06/07/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD3-%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7/">程序性能3–渐进符号</a></li>
</ol>
<h3 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>程序性能：是指运行一个程序所需要的内存大小和时间。<br>可以采用两种方法来确定一个程序的性能，一个是分析的方法，一个是实验的方法。在进行性能分析(performance analysis)时，采用分析的方法；而在进行性能测量(performance measurement)时，借助于实验的方法。</p>
<p>程序的空间复杂性是指运行完一个程序所需要的内存大小。</p>
<p>程序的时间复杂性是指运行完该程序所需要的时间。</p>
</blockquote>
<h3 id="u7A7A_u95F4_u590D_u6742_u6027"><a href="#u7A7A_u95F4_u590D_u6742_u6027" class="headerlink" title="空间复杂性"></a>空间复杂性</h3><h4 id="u7A7A_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210"><a href="#u7A7A_u95F4_u590D_u6742_u6027_u7684_u7EC4_u6210" class="headerlink" title="空间复杂性的组成"></a>空间复杂性的组成</h4><p>程序所需要的空间主要由以下部分构成：</p>
<ul>
<li>指令空间：是值用来存储经过编译之后的程序指令所需要的空间。</li>
<li>数据空间：是指用来存储所有常量和变量值所需的空间。其主要由两个部分构成：<ul>
<li>存储常量和简单变量所需要的空间</li>
<li>存储复合变量所需要的空间。这一类空间包括数据结构所需要的空间动态分配的空间</li>
</ul>
</li>
<li>环境栈空间：用来保存函数调用返回时恢复运行所需要的信息。例如，如果函数fun1调用了函数fun2，那么至少必须保存fun2结束时fun1将要继续执行的指令的地址。</li>
</ul>
<h5 id="u6307_u4EE4_u7A7A_u95F4"><a href="#u6307_u4EE4_u7A7A_u95F4" class="headerlink" title="指令空间"></a>指令空间</h5><p>  程序所需要的指定空间的数据取决于如下因素：</p>
<ul>
<li>把程序编译成机器代码的编译器；</li>
<li>编译时实际采用的编译器选项；</li>
<li>目标计算机。</li>
</ul>
<p>在决定最终代码需要多少空间的时候，编译器是一个最重要的因素。下图给出了计算表达式<code>a+b+b*c+(a+b-c)/(a+b)+4</code>的三段可能的代码，它们都指向完全相同的算术操作，但每段代码所需要的空间都不一样。所用的编译器将确定产生哪一种代码。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E5%9B%BE2-1.png" alt="此处输入图片的描述"></p>
<p>即使采用相同的编译器，所产生程序代码的大小也可能不一样。例如，一个编译器可能为用户提供优化选项，<strong>如代码优化以及执行时间优化等</strong>。如，在图2-1中，非优化模式下，编译器可以产生图2-1b的代码，而优化模式下，则会产生图2-1c中更短更高效的代码。<strong>使用优化模式通常会增加程序编译所需要的时间</strong>。</p>
<p>另一种可以显著减少程序空间的编译器选项就是<strong>覆盖选项</strong></p>
<blockquote>
<p>覆盖模式：空间仅分配给当前正在执行的程序模块，在调用一个新的模块时，需要从磁盘或从其他设备中读取，新模块的代码将覆盖原模块的代码。所以程序的空间就等价于最大的模块所需要的空间，而不是所有模块之和。</p>
</blockquote>
<p>目标计算机的配置也会影响代码的规模。比如计算机具有浮点处理硬件，则每个浮点操作都可以转换成一条机器指令。如果没有安装浮点处理硬件，则必须生成仿真的浮点计算代码。</p>
<h5 id="u6570_u636E_u7A7A_u95F4"><a href="#u6570_u636E_u7A7A_u95F4" class="headerlink" title="数据空间"></a>数据空间</h5><p>对于简单变量和常量来说，所需要的空间取决于<strong>所使用的计算机和编译器以及变量与常量的数目</strong>。</p>
<p>对于一个结构变量，可以把它的每个成员所占用的空间累加起来即可得到该变量所需要的内存。类似地，可以得到一个数组变量所需要的空间，方法是用数组的大小乘以单个数组元素所需要的空间。</p>
<p>比如对于<code>double a[100];</code>，数组a需要的空间是100个double类型元素所占用的空间，若每个元素占用8个字节，则分配给数组的空间总量为800字节。</p>
<h5 id="u73AF_u5883_u6808"><a href="#u73AF_u5883_u6808" class="headerlink" title="环境栈"></a>环境栈</h5><p> 每当一个函数被调用时，下面的数据将被保存在环境栈中：</p>
<ul>
<li>返回地址</li>
<li>函数被调用时所有局部变量的值以及传值形式参数的值(仅对于递归函数而言)</li>
<li>所有引用参数及常量引用参数的定义。</li>
</ul>
<p><strong>值得注意的是</strong>，有些编译器在保留局部变量的值、传值形式参数的值以及引用参数和常量引用参数的定义时，对于递归函数和非递归函数一视同仁，而有些编译器仅为递归函数保存上述内容。所以实际使用的编译器将影响环境栈所需要的空间。</p>
<h5 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h5><p> <strong>指令空间的大小对于所解决的特定问题不够敏感。常量及简单变量所需要的数据空间也独立于所解决的问题</strong>，除非相关数的大小对于所选定的数据类型来说实在太大，这时，要么改变数据类型，要么使用多精度算法重写该程序，然后再对新程序进行分析。<br>  <strong>复合变量及动态分配所需要的空间同样独立于问题的规模</strong>。<strong>而环境栈通常独立于实例的特征</strong>，除非正在使用递归函数。在使用递归函数时，实例特征通常(但不总是)会影响环境栈所需要的空间数量。</p>
<blockquote>
<p>实例的特征包含决定问题规模的因素，如输入输出的数量或相关数的大小。例如，对于一个对n个元素进行排序的程序，可以确定该程序所需要的空间为n的函数；</p>
</blockquote>
<p>因此，可以把一个程序所需要的空间分成两部分：</p>
<blockquote>
<ul>
<li>固定部分，它独立于实例的特征。一般来说，这一部分包含指定空间(即代码空间)、简单变量及定长复合变量所占用空间、常量占用空间等；</li>
<li>可变部分，它由以下部分构成：复合变量所需的空间(这些变量的大小依赖于所解决的具体问题)，动态分配的空间(这种空间一般都依赖于实例的特征)，以及递归栈所需要的空间(该空间也依赖于实例的特征).</li>
</ul>
</blockquote>
<p>任意程序P所需要的空间<code>S(P)</code>可以表示为：<br>$S(P) = c + S_p(实例特征)$<br>其中c是一个常量，表示固定部分所需要的空间，而$S_p$表示可变部分所需要的空间。一个精确的分析还应当包括在<strong>编译期间所产生的临时变量所需要的空间，这种空间是与编译器直接相关的，除依赖于递归函数外，它还依赖于实例的特征</strong>。<br>在分析程序的空间复杂性时，我们将把注意力集中在估算$S_p$(实例特征)上。对于任意给定的问题，首先需要确定实例的特征以便于估算空间需求。<strong>一般，实例特征的选择会受到相关数的数量以及程序输入和输出的规模的限制。</strong></p>
<h4 id="u4E3E_u4F8B"><a href="#u4E3E_u4F8B" class="headerlink" title="举例"></a>举例</h4><p>这里举例说明，例子如下：</p>
<blockquote>
<p>[顺序搜索] 下列程序从左至右检查数组a[0:n-1]中的元素，以查找与x相等的那些元素。如果找到一个元素与x相等，则函数返回x第一次出现所在的位置。如果在数组中没有找到这样的元素，函数返回-1.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*&#22312;&#26410;&#25490;&#24207;&#30340;&#25968;&#32452; a [ 0 : n-1 ]&#20013;&#25628;&#32034; x&#10;  &#22914;&#26524;&#25214;&#21040;&#65292;&#21017;&#36820;&#22238;&#25152;&#22312;&#20301;&#32622;&#65292;&#21542;&#21017;&#36820;&#22238;- 1*/&#10;template&#60;class T&#62;&#10;int SequentialSearch(T a[], const T&#38; x, int n)&#10;&#123;&#10;    int i;&#10;    for (i = 0; i &#60; n &#38;&#38; a[i] != x; i++);&#10;    if (i == n) return -1;&#10;    return i;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望采用实例特征n来估算该函数的空间复杂性。假定T是<code>int</code>类型，则数组a中的每个元素需要2个字节，实例x需要2个字节，传值形式参数n也需要2个字节，局部变量i需要2个字节，每个整型常量0和-1也分别需要2个字节。因此，所需要的总的数据空间是12字节，因为该空间独立于n，所以$S_{顺序搜索}$(n) = 0.</p>
<p>注意数组a必须足够大以容纳所查找的n个元素。不过，该数组所需要的空间已在定义实际参数(对应于a)的函数中分配，所以不需要把该数组所需要的空间加到上述函数<code>SequentialSearch</code>所需要的空间上去。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>阅读《数据结构算法与应用：C++描述》第二章程序性能所做的笔记。</p>
<p>第2章程序性能的所有笔记如下：</p>
<ol>
<li><a href="http://ccc013.github.io/2016/06/04/%E7%A8%8B%E5%BA%8F%E6%80]]>
    </summary>
    
      <category term="数据结构" scheme="http://ccc013.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://ccc013.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[线性代数]Note 1--方程组的几何解释]]></title>
    <link href="http://ccc013.github.io/2016/05/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-Note-1-%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/"/>
    <id>http://ccc013.github.io/2016/05/30/线性代数-Note-1-方程组的几何解释/</id>
    <published>2016-05-30T06:06:39.000Z</published>
    <updated>2016-05-30T11:06:52.501Z</updated>
    <content type="html"><![CDATA[<p>这是记录麻省理工学院公开课：线性代数的笔记，网址是<a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="external">麻省理工公开课：线性代数</a><br>第一节课说的是有关方程组的几何解释。网址是<a href="http://open.163.com/movie/2010/11/7/3/M6V0BQC4M_M6V29E773.html" target="_blank" rel="external">方程组的几何解释</a></p>
<hr>
<p> 首先是介绍方程组的几何解释，提出可以用矩阵表示，然后矩阵表示有两种表达方式，分别是行图像和列图像。行图像比较常见，比如两条直线相交，而列图像则比较少见。</p>
<h3 id="u4E24_u4E2A_u672A_u77E5_u6570_u4E24_u4E2A_u65B9_u7A0B"><a href="#u4E24_u4E2A_u672A_u77E5_u6570_u4E24_u4E2A_u65B9_u7A0B" class="headerlink" title="两个未知数两个方程"></a>两个未知数两个方程</h3><p> 然后老师举例说明，首先是两个方程组两个未知数的例子，例子如下所示：<br>$$<br> \begin{cases}<br> \ 2x-y = 0 \\<br> \ -x+3y= 3<br> \end{cases}<br>$$</p>
<p>用行图像表示如下所示：<br>$$<br> \left[\begin{matrix}2 &amp; -1  \\ -1 &amp; 3  \end{matrix} \right] \left[\begin{matrix} x \\ y \end{matrix}\right]  = \left[\begin{matrix} 0 \\ 3 \end{matrix}\right]<br>$$</p>
<p>这里用<strong>A</strong>=$ \left[\begin{matrix} 2 &amp; -1  \\ -1 &amp; 3  \end{matrix} \right]$,<strong>x</strong> = $\left[\begin{matrix} x\\ y \end{matrix}\right]$,<strong>b</strong>=$\left[\begin{matrix} 0 \\ 3 \end{matrix}\right] $,可以得到<code>Ax =b</code></p>
<p>这里表示的就是两条直线，并且它们相交于点<code>(1,2)</code>。</p>
<p>如果是用列向量，则如下所示：<br>$$<br> x\left[\begin{matrix}2 \\ -1 \end{matrix} \right] + y\left[\begin{matrix}-1\\3\end{matrix}\right] = \left[\begin{matrix} 0\\ 3 \end{matrix}\right]<br>$$</p>
<p>对于这种写法，老师称之为列向量的线性组合，然后在二维坐标平面上表示了这两个向量，而这个列向量的线性组合的解，其实在用行图像表示的时候已经得到了，就是<code>x=1, y=2</code>。</p>
<h3 id="u4E09_u4E2A_u672A_u77E5_u6570_u4E09_u4E2A_u65B9_u7A0B_u7EC4"><a href="#u4E09_u4E2A_u672A_u77E5_u6570_u4E09_u4E2A_u65B9_u7A0B_u7EC4" class="headerlink" title="三个未知数三个方程组"></a>三个未知数三个方程组</h3><p>  接着老师给出了三个未知数的情况，举例如下所示<br>$$<br> \begin{cases}<br> \ 2x-y = 0 \\<br> \ -x+2y-z = -1 \\<br> \    -3y+4z = 4<br> \end{cases}<br>$$<br> 使用行图像表示，<strong>A</strong> = $ \left[\begin{matrix}2 &amp; -1 &amp; 0 \\ -1 &amp; 2 &amp; -1 \\ 0 &amp; -3 &amp; 4\end{matrix}\right]$,<strong>b</strong>=$\left[\begin{matrix}0 \\ -1 \\4\end{matrix}\right]$,</p>
<p> 使用列图像表示是如下所示：<br> $$<br>  x\left[ \begin{matrix} 2 \\ -1 \\0\end{matrix} \right]+y\left[ \begin{matrix}-1 \\ 2 \\ -3\end{matrix} \right]+z\left[ \begin{matrix}0 \\ -1 \\ 4\end{matrix} \right]=\left[ \begin{matrix} 0 \\ -1 \\ 4\end{matrix} \right]<br> $$</p>
<p> 如果通过行图像来求解，需要通过在三维坐标轴上画出3个平面求平面的交点，这是非常困难的。(这里老师也说了下一节课会介绍消元法来求解)。</p>
<p> 而如果看列图像，则可以轻松得到答案：<code>x=0,y=0,z=1</code>，当然这是老师特意设计的题目，所以才这么容易得到这个答案。</p>
<p> 然后老师就问了一个问题：</p>
<blockquote>
<p>对任意的<strong>b</strong>，都能令<code>Ax = b</code>有解吗？<br>这个问题对于这个三个未知数的例子来说，等价于这个例子中的列向量的线性组合是否能覆盖整个三维空间？</p>
</blockquote>
<p>这里的答案当然是不能确定的，如果三个列向量都是在同一个平面上，那么得到的解也就只是在同一个平面的。</p>
<h3 id="u77E9_u9635_u5411_u91CF_u76F8_u4E58_u7684_u89E3_u6CD5"><a href="#u77E9_u9635_u5411_u91CF_u76F8_u4E58_u7684_u89E3_u6CD5" class="headerlink" title="矩阵向量相乘的解法"></a>矩阵向量相乘的解法</h3><p>最后老师介绍了矩阵与向量相乘的两种解法，首先是一个例子<br>$$<br> \left[ \begin{matrix}2 &amp; 5\\1 &amp; 3\end{matrix}\right] \left[\begin{matrix}1\\2\end{matrix}\right]<br>$$<br>两种解法分别是按照行向量还是列向量来解答的。</p>
<p>第一种，如果是按照列向量解答，则可以写成如下所示：<br>$$<br> \left[ \begin{matrix}2 &amp; 5\\1 &amp; 3\end{matrix}\right] \left[\begin{matrix}1\\2\end{matrix}\right] = 1\left[ \begin{matrix}2 \\1\end{matrix}\right]+ 2 \left[ \begin{matrix}5\\3\end{matrix}\right] = \left[ \begin{matrix}12\\7\end{matrix}\right]<br>$$</p>
<p>第二种，就是按行来求解，如下所示：<br>$$<br>  \left[ \begin{matrix}2 &amp; 5 \\ 1 &amp; 3 \end{matrix}\right] \left[\begin{matrix}1\\ 2 \end{matrix}\right] = \left[ \begin{matrix} 2*1+5*2 \\ 1*1+3*2 \end{matrix}\right] = \left[ \begin{matrix} 12 \\ 7 \end{matrix}\right]<br>$$<br>也就是第一个矩阵的第一行乘以第二个向量的对应列，然后第二行乘以第二个向量的对应列。</p>
<p>这种解法也是当初刚开始学习线性代数所学习的方法。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>这节课的收获主要是了解到列向量这种求法，之前对于矩阵的求解，还是通过按行来相乘求解的。不过在这节课中的例子都是矩阵乘以向量得到一个向量，如果是矩阵之间的相乘，不知道是否还是可以如此解决。</p>
<p>最后是手写笔记如下所示<br> <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%89%AB%E6%8F%8F_20160529215117.jpg" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是记录麻省理工学院公开课：线性代数的笔记，网址是<a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="external">麻省理工公开课：线性代数</a><br>]]>
    </summary>
    
      <category term="线性代数" scheme="http://ccc013.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android官方文档Guide阅读系列(2)--Device Compatibility]]></title>
    <link href="http://ccc013.github.io/2016/04/20/Device-Compatibility/"/>
    <id>http://ccc013.github.io/2016/04/20/Device-Compatibility/</id>
    <published>2016-04-20T06:13:07.000Z</published>
    <updated>2016-05-19T00:34:37.911Z</updated>
    <content type="html"><![CDATA[<p>第二篇文章：<a href="http://android.xsoftlab.net/guide/practices/compatibility.html" target="_blank" rel="external">设备的兼容性(Device Compatibility)</a></p>
<h3 id="u8BBE_u5907_u7684_u517C_u5BB9_u6027_28Device_Compatibility_29"><a href="#u8BBE_u5907_u7684_u517C_u5BB9_u6027_28Device_Compatibility_29" class="headerlink" title="设备的兼容性(Device Compatibility)"></a>设备的兼容性(Device Compatibility)</h3><p>Android 现在可以运行在不同的设备上，不只是手机，还有平板电脑，电视。为了能让应用可以成功在这些设备上正常运行，应用应该允许一些特征功能的多样性并且可以提供一个灵活的用户界面来适应不同的屏幕配置。</p>
<p>为了达成这个目标，Android 提供一个可以让开发者使用一些静态文件(如对于不同屏幕尺寸的不同<code>XML</code>布局)来使用特定的配置的应用资源的动态应用框架。Android 可以根据当前设备的配置来加载合适的资源。所以对于开发者，在将你的程序打包成<code>apk</code>文件前，考虑好使用几套资源文件，比如使用几套不同大小的图片来适应不同的屏幕尺寸，对于手机和平板电脑要分别设置不同的布局文件等，这样当发布了你的应用后，就可以给使用不同设备的用户一个最好的用户体验。</p>
<p>最好的情况还是开发者可以指定其应用的功能要求，这样可以控制能够安装其应用的设备类型。更多有关让你的应用适应不同设备的内容，可以查看<a href="http://android.xsoftlab.net/training/basics/supporting-devices/index.html" target="_blank" rel="external">Supporting Different Devices</a>。</p>
<hr>
<h3 id="u517C_u5BB9_u6027_u610F_u5473_u7740_u4EC0_u4E48_uFF1F"><a href="#u517C_u5BB9_u6027_u610F_u5473_u7740_u4EC0_u4E48_uFF1F" class="headerlink" title="兼容性意味着什么？"></a>兼容性意味着什么？</h3><p>  当你阅读了越来越多有关 Android 开发的文章后，你可能在不同情况下会看到这个词语–<code>兼容性</code>。兼容性分为两种，一是设备的兼容性，二是应用的兼容性。</p>
<p>  因为 Android 是一个开源项目，所以任何硬件制造商都可以制造一个能运行 Android 系统的设备，但是一个设备被称为是”兼容 Android”只有在该设备上可以正常运行在 <code>Android 执行环境</code>下编写的应用的前提。而有关<code>Android 执行环境</code>的细节可以查看<a href="http://source.android.com/compatibility/overview.html" target="_blank" rel="external"> Android compatibility program</a>,然后每个设备都必须通过兼容性测试套件(Compatibility Test Suite, CTS)才被认为是可兼容的。</p>
<p>  当然，作为一名应用开发者，是根本不需要考虑设备是否是兼容 Android的，因为可以包含谷歌应用商店(Google Play Store) 的设备都是可以兼容Android的，换句话说，能够安装你的应用的用户都是使用一台兼容Android的设备。</p>
<p>  那么，开发者需要考虑的就是你的应用的兼容性问题了。这也是因为 Android 可以运行在不同配置的设备上，有些功能不是所有的设备都具备的。比如一些设备是不具备有指南针传感器的，所以如果应该的核心功能需要有指南针传感器，那么就只有拥有这指南针传感器的设备可以使用你的应用了。</p>
<hr>
<h3 id="u63A7_u5236_u5E94_u7528_u5BF9_u8BBE_u5907_u7684_u53EF_u7528_u6027"><a href="#u63A7_u5236_u5E94_u7528_u5BF9_u8BBE_u5907_u7684_u53EF_u7528_u6027" class="headerlink" title="控制应用对设备的可用性"></a>控制应用对设备的可用性</h3><p>  Android 支持很多特性功能，这些功能有些是需要硬件支持的，比如上述的指南针传感器，有些是基于软件的，比如应用程序部件，还有一些是依赖于平台的版本。不是每一种设备都支持所有的功能，所以开发者需要根据应用所要求的功能来控制应用对设备的可用性。</p>
<p>  为了让更多的用户可以使用你的应用，你应该在使用一个单独的<code>APK</code>的情况下支持尽可能多的设备配置。大多数情况下，你可以在运行的时候关闭可选的功能特性，然后根据不同配置使用不同资源文件(比如不同屏幕尺寸的布局文件，具体参考<a href="http://android.xsoftlab.net/guide/topics/resources/providing-resources.html" target="_blank" rel="external">提供应用资源</a>)。如果可能，你是可以在谷歌应用商店中根据以下几种设备的特性来限制你的应用的可用性:</p>
<ul>
<li>设备功能(Device features)</li>
<li>平台版本(Platform version)</li>
<li>屏幕配置(Screen configuration)</li>
</ul>
<hr>
<h4 id="u8BBE_u5907_u529F_u80FD_28Device_features_29"><a href="#u8BBE_u5907_u529F_u80FD_28Device_features_29" class="headerlink" title="设备功能(Device features)"></a>设备功能(Device features)</h4><p>  Android 给所有的硬件或软件功能都提供了功能<code>IDs</code>，比如对于指南针传感器的功能 ID 就是<a href="http://android.xsoftlab.net/reference/android/content/pm/PackageManager.html#FEATURE_SENSOR_COMPASS" target="_blank" rel="external"><code>FEATURE_SENSOR_COMPASS</code></a>,而应用程序组件的 ID 是<a href="http://android.xsoftlab.net/reference/android/content/pm/PackageManager.html#FEATURE_APP_WIDGETS" target="_blank" rel="external"><code>FEATURE_APP_WIDGETS</code></a>.</p>
<p>  在你的应用的<a href="http://android.xsoftlab.net/guide/topics/manifest/manifest-intro.html" target="_blank" rel="external"><code>manifest file</code></a>可以通过使用<a href="http://android.xsoftlab.net/guide/topics/manifest/uses-feature-element.html" target="_blank" rel="external"><code>&lt;uses-feature&gt;</code></a>来声明所需要的功能从而防止不具备应用所需要的功能的设备的用户安装你的应用。</p>
<p>  一个要求必须具备指南针传感器功能的应用可以如此写明该功能要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;manifest ... &#62;&#10;    &#60;uses-feature android:name=&#34;android.hardware.sensor.compass&#34;&#10;                  android:required=&#34;true&#34; /&#62;&#10;    ...&#10;&#60;/manifest&#62;</span><br></pre></td></tr></table></figure>
<p>  当然如果你的应用主要功能并不需要一个设备的功能，可以将上述代码中的<code>required</code>设置为<code>false</code>，然后在运行的时候检查设备的功能。如果应用的功能在当前设备上不可用的时候，那么可以关闭这项功能。一个检查当前设备是否具备某个功能的代码例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PackageManager pm = getPackageManager();&#10;if (!pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_COMPASS)) &#123;&#10;    // This device does not have a compass, turn off the compass feature&#10;    disableCompassFeature();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用到了<a href="http://android.xsoftlab.net/reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String" target="_blank" rel="external">`hasSystemFeature()’</a>)这个函数，主要是检查设备是否支持某个功能，如果有返回<code>true</code>，否则返回<code>false</code>。</p>
<blockquote>
<p>注意：有些<a href="http://android.xsoftlab.net/guide/topics/security/permissions.html" target="_blank" rel="external">系统权限</a>暗含着需要某些设备功能的支持。比如，如果你的应用需要蓝牙(<code>BLUETOOTH</code>)功能，它其实是需要有<code>FEATURE_BLUETOOTH</code>这个设备功能的。当然你也可以通过在<code>&lt;uses-feature&gt;</code>中对于的功能设置<code>required = false</code>来使得你的应用也可以运行在不具备蓝牙功能的设备上。更多的有关需要设备功能的权限的信息，可以查看<a href="http://android.xsoftlab.net/guide/topics/manifest/uses-feature-element.html#permissions" target="_blank" rel="external">Permissions that Imply Feature Requirements</a>。</p>
</blockquote>
<hr>
<h4 id="u5E73_u53F0_u7248_u672C_28Platform_version_29"><a href="#u5E73_u53F0_u7248_u672C_28Platform_version_29" class="headerlink" title="平台版本(Platform version)"></a>平台版本(Platform version)</h4><p>  不同的设备可能运行不同的系统版本，比如 Android 4.0 和 Android 4.4。而每个连续的系统版本都会增加一些前一个版本不可用的新的 APIs。每个系统版本都有指定一个 <a href="http://android.xsoftlab.net/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="external"><code>API level</code></a>。</p>
<p>  使用<code>API level</code>可以指定你的应用可以兼容的最低系统版本，需要使用<code>minSdkVersion</code>(在Android Studio中这个功能是放在<code>build.gradle</code>中了);同样也可以指定你的应用最适合使用的版本，使用<code>targetSdkVersion</code>这个属性。</p>
<p>  同样的可以在代码中动态地检查当前设备使用的系统版本是否能够支持应用的某些功能，代码例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &#60; Build.VERSION_CODES.HONEYCOMB) &#123;&#10;    // Running on something older than API level 11, so disable&#10;    // the drag/drop features that use ClipboardManager APIs&#10;    disableDragAndDrop();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子是使用了<a href="http://android.xsoftlab.net/reference/android/content/ClipboardManager.html" target="_blank" rel="external">剪切板(ClipboardManager)</a>，这个API是在 API level 11中才增加的，所以低于这个系统版本的是无法实现这个功能的。</p>
<hr>
<h4 id="u5C4F_u5E55_u914D_u7F6E_28Screen_configuration_29"><a href="#u5C4F_u5E55_u914D_u7F6E_28Screen_configuration_29" class="headerlink" title="屏幕配置(Screen configuration)"></a>屏幕配置(Screen configuration)</h4><p>  Android 可以运行在不同的屏幕尺寸上，包括手机，平板电脑以及电视。为了更好的根据屏幕类型来分类设备，Android 对每个设备都定义了两种特性: 屏幕尺寸(屏幕的物理尺寸）,以及屏幕密度(屏幕的物理密度，如<code>dpi</code>)。而为了简化这些不同的配置，Android 分别为这两种特性生成一些变量来方便使用：</p>
<ul>
<li>4种屏幕尺寸: <code>small</code>,<code>normal</code>,<code>large</code>,<code>xlarge</code>;</li>
<li>几种密度: <code>mdpi(medium)</code>,<code>hdpi(hdpi)</code>,<code>xhdpi(extra high)</code>,<code>xxhdpi(extra-extra hdpi)</code>等。</li>
</ul>
<hr>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>  这篇教程主要是说明 Android 的兼容性问题，主要是3个方面的兼容性问题，一是设备的功能，二是系统版本，三是屏幕配置。这些问题的产生原因当然是因为Android是一个开源的系统，所以很多手机制造商都可以运行 Android 的系统，但是这造成了有很多不同配置，不同屏幕大小的 Android 手机，所以这也是在开发过程必须考虑的一个问题，兼容性问题，当然个人感觉主要是最后一个问题会考虑得主要多点，就是屏幕配置问题，现在有很多尺寸的手机，不同分辨率的手机，在考虑界面的时候就需要多做几套图片，几个布局文件来适应尽可能多的不同屏幕配置的手机。</p>
<p>  关于屏幕适配的文章，这里推荐下最近看到的几篇文章，包括几位大神的文章：</p>
<ul>
<li>郭霖： <a href="http://blog.csdn.net/guolin_blog/article/details/8830286" target="_blank" rel="external">Android官方提供的支持不同屏幕大小的全部方法</a></li>
<li>Stormzhang：<a href="http://stormzhang.com/android/2014/05/16/android-screen-adaptation/" target="_blank" rel="external">Android 屏幕适配</a></li>
<li>鸿洋：<a href="http://blog.csdn.net/lmj623565791/article/details/45460089" target="_blank" rel="external">Android 屏幕适配方案</a></li>
<li>凯子： <a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023" target="_blank" rel="external">Android屏幕适配全攻略(最权威的官方适配指导)</a></li>
<li><p>Carson_Ho: <a href="http://www.jianshu.com/p/ec5a1a30694b" target="_blank" rel="external">Android开发：最全面、最易懂的Android屏幕适配解决方案</a></p>
<p>屏幕适配也是一个很重要的知识点，所以也是需要找时间好好看看这方面的内容。</p>
<p>最后，如果有翻译不对，或者表达错误的地方，欢迎指正。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>第二篇文章：<a href="http://android.xsoftlab.net/guide/practices/compatibility.html" target="_blank" rel="external">设备的兼容性(Device Compatibility]]>
    </summary>
    
      <category term="Android" scheme="http://ccc013.github.io/tags/Android/"/>
    
      <category term="阅读笔记" scheme="http://ccc013.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android官方文档Guide阅读系列(1)--Application Fundamentals]]></title>
    <link href="http://ccc013.github.io/2016/04/20/Application-Fundamentals/"/>
    <id>http://ccc013.github.io/2016/04/20/Application-Fundamentals/</id>
    <published>2016-04-20T06:10:54.000Z</published>
    <updated>2016-05-18T10:50:37.857Z</updated>
    <content type="html"><![CDATA[<p>最近打算好好看看android的官方文档，<code>Training</code>的已经看过了，打算看下<code>Guide</code>指导文档，这个比<code>Training</code>会介绍得更加详细。</p>
<p>谷歌的官网因为被墙，所以这里介绍一个国内的镜像<a href="http://android.xsoftlab.net/index.html" target="_blank" rel="external">Android 6.0官网</a>，本篇文章是第一篇文章，地址是<a href="http://android.xsoftlab.net/guide/components/fundamentals.html" target="_blank" rel="external">Application Fundamentals</a></p>
<p>主要是翻译<code>Guide</code>文档的内容，但不一定会逐句翻译，因为英语水平问题，可能会有选择的翻译一些自己认为比较重要的内容，但是介绍的知识点会尽可能保证都翻译到。</p>
<h2 id="u5E94_u7528_u57FA_u7840_28Application_Fundamentals_29"><a href="#u5E94_u7528_u57FA_u7840_28Application_Fundamentals_29" class="headerlink" title="应用基础(Application Fundamentals)"></a>应用基础(Application Fundamentals)</h2><p>Android的app是使用Java语言编写的。Android SDK工具是用来将你写的代码以及一些数据和资源文件，编译成一个APK，APK是一个android的包，是一个后缀名为<code>.apk</code>的归档文件(archive file)。一个APK文件包含了一个android app的所有内容，也是使用android系统的设备用来安装app的文件。</p>
<p>一旦在一个设备上安装了，每个 android app 都是运行在自己的安全沙箱中：</p>
<ul>
<li>android的操作系统是一个多用户的Linux系统，每个app是一个不同的用户</li>
<li>默认情况下，系统会给每个app分配一个独立的Linux用户ID(这个ID只是系统使用，app是不知道这个ID的)。系统会给一个app中所有文件都设置了权限，只有分配给这个app的用户ID才可以使用这些文件</li>
<li>每个进程都有自己的虚拟机(virtual machine,VM),因此每个app都是相互隔离地运行自己的代码的</li>
<li>默认情况，每个app都是运行在自己的Linux进程。当app的组件需要被执行时，Android会开始其进程，而在其不用执行或者系统必须给其他应用分配内存(recover memory)时会关掉这个进程。</li>
</ul>
<p>通过上述方式，Android系统实现了最少特权原则(the principle of least privilege)。也就是对于每个app，默认情况，它只可以使用用于完成其工作的组件。这就创造了一个非常安全的环境，每个app都无法获取它没有得到权限的系统功能或服务。</p>
<p>然而，对每个app，还是有方法可以跟其他app分享数据以及使用系统的服务的：</p>
<ul>
<li>给两个app分享同一个Linux的用户ID是有可能的，在这种情况下它们是可以使用对方的文件。出于节省系统资源的考虑，拥有一样用户ID的apps会分配到同一个Linux进程中，并且共享同一个VM(这些apps都必须签署同样的证书)</li>
<li>一个应用是可以要求获取使用设备数据的权限，如用户的联系人，短信，SD卡，照相机，蓝牙等等。所有的应用权限都必须在安装的时候得到用户的同意。</li>
</ul>
<p>以上内容包含了基本的关于一个android应用如何存在于系统中，本文接下来的将介绍以下内容：</p>
<ul>
<li>定义app中的核心框架组件</li>
<li><code>mainfest</code>文件，用于声明组件以及要求设备功能</li>
<li>跟app代码分开的资源文件，用于让你的应用可以在面对多种设备配置时优雅地优化其行为</li>
</ul>
<hr>
<h3 id="u5E94_u7528_u7EC4_u4EF6_28App_Components_29"><a href="#u5E94_u7528_u7EC4_u4EF6_28App_Components_29" class="headerlink" title="应用组件(App Components)"></a>应用组件(App Components)</h3><p>应用组件是一个Android应用的基本建筑基石。每个组件是一个系统可以进入应用的不同点。但不是所有的组件是用户实际的入口点，其中一些需要相互依赖，但每一个都是作为一个实体存在并且扮演一个特殊的角色——每一个组件都是一个帮助开发者定义其应用整体行为的基石。</p>
<p>总共有4种不同类型的应用组件。每一种类型都是用于一个明显的用途，并且都有一个清楚的定义了其如何创建和摧毁的生命周期。</p>
<h5 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h5><p>一个活动表示用户界面上一个单独的屏幕。例如，在一个电子邮件的应用中会有一个展示新邮件列表的活动，一个活动是用于写信，以及一个读取邮件内容的活动。尽管在这个应用中这些活动一起运作形成了一个有凝聚力的用户体验，但每个活动都是相互独立的。同样地，另一个不同的应用是可以打开这些活动中的任何一个(在获得该电子邮件应用的允许的前提下)。例如，一个照相应用可以打开这个电子邮件应用中的写信的活动，以便于用户可以分享一张图片。</p>
<h5 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h5><p>一个服务是一个运行在后台，执行长时间运算或者执行远程进程的工作的组件。服务是没有用户界面的。例如，当用户在使用其他应用的时候，一个服务正在后台播放音乐，或者它是在通过网络获取一些数据但没有阻碍用户与一个活动界面进行交互。其他的组件，如一个活动，可以开启服务并让它运行，或者绑定这个服务来与它进行交互。</p>
<h5 id="Content_providers"><a href="#Content_providers" class="headerlink" title="Content providers"></a>Content providers</h5><p>一个内容提供器是管理一个用于分享的应用数据集。开发者可以通过文件系统，一个SQLite数据库，网络，或其他固定的应用可以访问的存储位置来保存数据。通过内容提供器，其他的应用可以查询甚至修改数据(在这个内容提供器允许前提下)。例如，Android系统提供了一个管理用户联系人信息的内容提供器。正因为如此，任何一个应用在有合法的权限下都可以查询这个内容提供器(如<code>ContactsContract.Data</code>)来读写一个特定的人的信息。</p>
<h5 id="Broadcast_receivers"><a href="#Broadcast_receivers" class="headerlink" title="Broadcast receivers"></a>Broadcast receivers</h5><p>一个广播接收器是一个用于响应系统全局广播通知的组件。很多广播都是起源于系统——例如，一个广播通知屏幕要关闭，电量低，或者截屏。应用也可以初始化广播——例如，让其他应用知道有些数据被下载到设备中并且可以提供给它们使用。尽管广播接收器没有显示一个用户界面，但是它们可以创建一条状态栏的通知来提醒用户有一个广播事件发生了。但更普遍的情况是，一个广播接收器仅仅是一个通向其他组件的“门(gateway)”，并且一般只做很少量的工作，例如，广播接收器可能就是开启一个基于广播事件的执行一些任务的服务。</p>
<hr>
<h3 id="Activating_Components"><a href="#Activating_Components" class="headerlink" title="Activating Components"></a>Activating Components</h3><p>在4种组件类型中有三种–活动、服务和广播接收器–都是通过一个叫做<code>intent</code>的异步信息启动的。Intents可以在运行时将独立的组件绑定在一起(可以将它们看做是需要从其他组件中要求一个<code>action</code>的信使)，无论这个组件是否属于你的应用。</p>
<p>通过使用一个<code>Intent</code>对象可以创建一个<code>intent</code>，它可以使用一个信息来启动一个特定的组件或者一类组件，即<code>intent</code>是分为显式的和隐式的。</p>
<p>对于活动和服务，一个intent定义了需要执行的<code>action</code>(如发送或者查看)，有可能还会特定数据的<code>URI</code>，比如需要打开一个网页的时候，这个<code>URI</code>就是网页的网址了。在某些情况下，活动在使用一个intent后，还可以接受返回的结果，这个结果也是通过<code>Intent</code>返回的。</p>
<p>对于广播接收器，intent只是简单定义了正在广播的通知。</p>
<p>对于内容提供器，它是由<code>ContentResolver</code>来启动的。它可以处理跟内容提供器所有的直接事务。</p>
<p>对不同组件有不同的开启方法：</p>
<ul>
<li>对于活动，可以传递一个<code>Intent</code>给<code>startActivity()</code>或者<code>startActivityForResult()</code>(当需要开启的活动返回一个结果时);</li>
<li>对于服务，传递一个<code>Intent</code>给<code>startService()</code>方法来开启服务，绑定服务则是传递给<code>bindService()</code>;</li>
<li>初始化一个广播可以通过传递<code>Intent</code>给如<code>sendBroadcast()</code>,<code>sendOrderedBroadcast()</code>,或者<code>sendStickyBroadcast()</code>;</li>
<li>通过调用<code>ContentResolver</code>的<code>query()</code>可以实现对内容提供器的查询。</li>
</ul>
<hr>
<h3 id="The_Manifest_File"><a href="#The_Manifest_File" class="headerlink" title="The Manifest File"></a>The Manifest File</h3><p>所有的组件都必须在一个文件——<code>AndroidManifest.xml</code>中声明，Android 系统才能使用它，这个文件必须是在应用项目文件的根目录中。</p>
<p>除了用于声明组件，它还有以下这些功能：</p>
<ul>
<li>声明应用所需要的用户权限，比如网络连接或者是读取用户的联系人；</li>
<li>声明该应用要求的最低 API Level，(在Android Studio中这个功能是放在<code>build.gradle</code>中了)</li>
<li>声明应用需要用到或者要求的硬件和软件的功能特性，比如照相机，蓝牙，或者是一个多点触摸的屏幕</li>
<li>应用需要链接到的 API 库，比如 Google Maps library</li>
<li>等等</li>
</ul>
<h5 id="u58F0_u660E_u7EC4_u4EF6"><a href="#u58F0_u660E_u7EC4_u4EF6" class="headerlink" title="声明组件"></a>声明组件</h5><p><code>manifest</code>的主要任务是声明组件，比如，一个声明活动的例子如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest ... &gt;
    &lt;application android:icon=&quot;@drawable/app_icon.png&quot; ... &gt;
        &lt;activity android:name=&quot;com.example.project.ExampleActivity&quot;
                  android:label=&quot;@string/example_label&quot; ... &gt;
        &lt;/activity&gt;
        ...
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre><p>没有在这个文件声明的组件是不可以使用的，除了广播接收器外。</p>
<p>广播接收器即可以在该文件中声明，也可以在代码中动态地创建，并使用<code>registerReceiver()</code>方法在进行注册。</p>
<h5 id="u58F0_u660E_u7EC4_u4EF6_u7684_u529F_u80FD"><a href="#u58F0_u660E_u7EC4_u4EF6_u7684_u529F_u80FD" class="headerlink" title="声明组件的功能"></a>声明组件的功能</h5><p><code>Intent</code>的真正作用体现在使用隐式intent上，这种intent简单描述了需要执行的行为类型，有时还会说明需要使用的数据，然后系统就会寻找可以执行这种行为的组件并启动它，而如果有多种组件，那么用户可以选择使用哪一个。</p>
<p>通过在<code>AndroidManifest.xml</code>声明组件时，使用一个<code>&lt;intent-filter&gt;</code>可以声明该组件的功能，也就是其能执行的行为。</p>
<p>下面是一个邮件应用中用户写信的一个活动的声明例子：</p>
<pre><code>&lt;manifest ... &gt;
    ...
    &lt;application ... &gt;
        &lt;activity android:name=&quot;com.example.project.ComposeEmailActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;
                &lt;data android:type=&quot;*/*&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre><p>这个例子中的活动可以响应需要<code>ACTION_SEND</code>的intent</p>
<h5 id="u58F0_u660E_u5E94_u7528_u7684_u5FC5_u8981_u6761_u4EF6"><a href="#u58F0_u660E_u5E94_u7528_u7684_u5FC5_u8981_u6761_u4EF6" class="headerlink" title="声明应用的必要条件"></a>声明应用的必要条件</h5><p>由于Android的设备非常多，但不是所有的设备都拥有同样的功能和特性，在<code>AndroidManifest.xml</code>文件中声明应用所需要的硬件和软件功能和特性是有必要的。</p>
<p>不过大部分这些声明都只是信息，系统也不会读取它们，但对于如 Google Play 会读取它们然后给用户进行过滤。</p>
<p>例如，你的应用需要使用照相功能并且使用 Android 2.1(API Level 7)的 API，应该如下所示：</p>
<pre><code>&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera.any&quot;
                  android:required=&quot;true&quot; /&gt;
    &lt;uses-sdk android:minSdkVersion=&quot;7&quot; android:targetSdkVersion=&quot;19&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre><p>这样，当不具备以上要求的设备是无法从 Google Play 上安装的。当然上述的<code>android:required</code>也可以设置为<code>false</code>，这表示你的应用使用照相功能，但并不要求设备拥有这个功能，所以在运行的时候会检查设备是否有照相机，并且会在适当的时候关闭这个功能。</p>
<hr>
<h3 id="u5E94_u7528_u8D44_u6E90"><a href="#u5E94_u7528_u8D44_u6E90" class="headerlink" title="应用资源"></a>应用资源</h3><p>一个android应用除了代码外，还有一些其他的资源，比如图片，音频文件，以及任何与应用的视觉展示有关的东西。使用应用资源可以在不修改代码的情况下升级应用的不同功能特性，并且可以使应用适配不同的设备配置(如不同的语言和屏幕尺寸)。</p>
<p>对每个在项目中使用到的资源，SDK 编译工具都会定义一个独一无二的整型 ID，这个可以在代码中或者 XML 中用来引用这个资源。</p>
<p>使用应用资源可以有利于适配不同的设备配置，比如对于在 XML 中使用字符串，可以将字符串翻译成其他语言并保存在不同的文件，并且对该文件名字使用一个限定符(如<code>res/values-fr/</code>是用于法语的字符串)。</p>
<p>Android提供了很多不同的限定符，它是一个短字符串用于放在资源文件名字中。例如，对于布局，通常需要创建不同的布局文件，因为设备的屏幕方向和尺寸。当屏幕是垂直的(<code>portrait</code>)或者是水平的(<code>landscape</code>),可以定义两个不同的布局文件来对应这两种情况，而系统会根据当前设备的方向来自动使用合适的布局。</p>
<hr>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>  第一篇简单介绍了 android 的开发语言是 <code>Java</code> ，这个是最基础的，也是学习android首先需要掌握的基础语言，而且我也认为想要在android这条道路上走得更远，Java还不能只是了解，还必须要好好掌握好，毕竟到时如果要阅读源码，读的可以都是用java写的代码，所以重新好好系统学学java也是一个近期的计划。当然，最近看到有说可以使用其他语言来写android，比如<code>kotlin</code>这门语言，还有就是说<code>swift</code>要支持 Android了，不过这个目前只是 <code>NDK</code> 支持而已。</p>
<p>其次还介绍了 android 的四大组件， 目前用得比较多的当然还是 <code>Activity</code> 了，其他三个组件用得比较少，甚至还没怎么使用过，不过这也是目前开发的经验比较少，做过的项目不多。</p>
<p>然后就是<code>AndroidManifest</code>文件，用来注册四大组件，声明应用需要的权限和硬件必须具备的功能等，还有就是说明了 Android 中除了纯 Java 代码外，还有其他资源文件，包括图片，布局文件等，这里需要根据设备的屏幕大小，分辨率，屏幕方向等分别设置对应的资源文件。</p>
<p>第一次写文章，主要是翻译自官方文档，因为英语水平和表达水平不是很好，所以有翻译错误和表达不好的地方都欢迎提出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近打算好好看看android的官方文档，<code>Training</code>的已经看过了，打算看下<code>Guide</code>指导文档，这个比<code>Training</code>会介绍得更加详细。</p>
<p>谷歌的官网因为被墙，所以这里介绍一个国内]]>
    </summary>
    
      <category term="Android" scheme="http://ccc013.github.io/tags/Android/"/>
    
      <category term="阅读笔记" scheme="http://ccc013.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo博客的优化与配置]]></title>
    <link href="http://ccc013.github.io/2016/01/26/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://ccc013.github.io/2016/01/26/hexo博客的优化与配置/</id>
    <published>2016-01-26T08:22:04.000Z</published>
    <updated>2016-01-26T09:23:09.580Z</updated>
    <content type="html"><![CDATA[<h1 id="u6DFB_u52A0_u7EDF_u8BA1_u4EE3_u7801"><a href="#u6DFB_u52A0_u7EDF_u8BA1_u4EE3_u7801" class="headerlink" title="添加统计代码"></a>添加统计代码</h1><p>上周成功用Hexo+Github Pages搭建好博客，但是还有很多功能等待添加的,今天就继续进行优化，首先是添加统计代码，数据统计方面有以下几个:</p>
<ol>
<li><a href="http://www.google.com/analytics/web/?hl=zh-CN" target="_blank" rel="external">Google Analytics</a></li>
<li><a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">百度统计</a></li>
<li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="external">不蒜子</a></li>
</ol>
<p>然后就是站长工具:</p>
<ol>
<li><a href="http://zhanzhang.cnzz.com/" target="_blank" rel="external">CNZZ|站长统计</a></li>
<li><a href="http://www.google.com/intl/zh-CN/webmasters" target="_blank" rel="external">谷歌站长工具</a></li>
<li><a href="http://zhanzhang.baidu.com/" target="_blank" rel="external">百度站长工具</a></li>
<li><a href="http://tool.chinaz.com/" target="_blank" rel="external">站长之家工具</a></li>
<li><a href="http://zhanzhang.so.com/" target="_blank" rel="external">360搜索站长平台</a></li>
</ol>
<p>感觉站长工具会比较详细点，所以就采用站长工具，用的是cnzz的，参考了<a href="http://blog.csdn.net/whjkm/article/details/37884563" target="_blank" rel="external">hexo博客的优化与配置——添加统计代码</a>.</p>
<p>首先在<code>\theme\yilia\_config.yml</code>添加一行代码:</p>
<pre><code>#### Analytics
cnzz: true
</code></pre><p>这里我用的是<strong>yilia</strong>主题。</p>
<p>登录<a href="http://zhanzhang.cnzz.com/" target="_blank" rel="external">CNZZ</a>中，注册，添加网站，然后会得到代码，选择想要显示的形式，可以只是文字形式，也可以是图表形式，复制给出的代码，然后在<code>\theme\yilia\layout\_partial</code>里面创建一个<strong>cnzz.ejs</strong>文件，把刚刚复制的代码添加进去:</p>
<pre><code>&lt;% if (theme.cnzz){ %&gt; 
&lt;script type=&quot;text/javascript&quot;&gt;
    var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);
    document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1257376919&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s11.cnzz.com/z_stat.php%3Fid%3D1257376919&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));
&lt;/script&gt; 
&lt;% } %&gt;
</code></pre><p>主要是替代这段代码中第二行<strong>&lt;script </strong>开始到倒数第二行的<strong></strong>。</p>
<p>最后在after_footer.ejs（或者footer，或head，可以自己选择需要出现站长统计的位置）的后面添加一行代码即可:</p>
<pre><code>&lt;%- partial(&apos;cnzz&apos;) %&gt; 
</code></pre><p>这样就可以了，然后就执行<code>hexo generate</code>,<code>hexo deploy</code>发布网站即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6DFB_u52A0_u7EDF_u8BA1_u4EE3_u7801"><a href="#u6DFB_u52A0_u7EDF_u8BA1_u4EE3_u7801" class="headerlink" title="添加统计代码"></a>添加统计代码</h1]]>
    </summary>
    
      <category term="Hexo" scheme="http://ccc013.github.io/tags/Hexo/"/>
    
      <category term="技术" scheme="http://ccc013.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015总结 & 2016展望]]></title>
    <link href="http://ccc013.github.io/2016/01/21/2015%E6%80%BB%E7%BB%93-2016%E5%B1%95%E6%9C%9B/"/>
    <id>http://ccc013.github.io/2016/01/21/2015总结-2016展望/</id>
    <published>2016-01-21T10:07:05.000Z</published>
    <updated>2016-01-21T10:11:28.788Z</updated>
    <content type="html"><![CDATA[<p>2015年过去了，2016年开始了。<br><strong>2015 总结</strong><br>    回首2015，最大的变化就是从本科到研究生，上半年本科毕业了，下半年则是继续读研，当然还是在本校读研，学院也还是本学院，至于专业还是有所改变了，现在是属于计算机视觉方向，简单说就是做图像识别，说得高大上点就是机器学习，或者是深度学习了。<br>    学习方面，学业方面，在本学期开学初还是有好好去了解机器学习的知识的，买了《统计学习方法》这本书，但是也只是看了前面几章，后面就因为时间关系，也是计划的调整没有看下去了，这本书主要是机器学习的一些知识；同时对linux系统有了点了解，毕竟为了使用Caffe这个框架，必须对linux系统有点了解，所以开学初也是安装了至少5次ubuntu系统，中间还换过一次主机，显示屏，所以还安装过一次win8系统，然后也了解几条linux系统的命令行命令，不过在11月底12月用linux系统用得有点少了；<br>    编程方面，本科毕设需要写一个android的应用，所以有了解基本的java知识，android也是看完《第一行代码》这本书，算是入门了，但是也是在不断探索如何学习可以掌握得更好，可以更好提高自己的水平，毕竟感觉对很多知识还是了解，还没怎么用过，最多就是在看书的时候有跟着敲下书上的代码，比如网络连接，图片加载的知识，动画，一些View的应用，如现在最新的material design的一些控件等等，本来打算要好好看看谷歌官方的training文档和guide文档，但是发现单纯看文档不写，掌握得不够好，所以打算开始写一个小应用，可以熟悉下自己不熟悉的一些知识点，同时在这个过程再去查看官方文档，总结下，做点笔记，这样可能是比较适合自己的学习方法；<br>    除了学习android，在暑假也是学习了python，这是看<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="external">廖雪峰老师的python教程</a>，安装了2.7和3.4版本的python，用sublime Text3这个编辑器，在开学后也是断断续续有用过，但是基本只是进行简单的文本操作，比如将一个文件夹中的文件名写到一个txt文件中，还有就是使用了opencv和PIL这两个第三方库对图片进行一些如调整大小的操作，还有就是学习了下爬虫，用selenium这个第三方库，跟着网上的教程写了一个爬百度图片的代码，总体上，还是属于入门的阶段，还没有很深入了解。<br>    在开学后，应该是10月份吧，开始看《C++ primer plus》，这是本应该去年就买的书，但是一直都没有看，但是看到师兄师姐都是有学这个，在同学提醒，如果以后要修改Caffe框架的代码，还是要懂C++的，所以也是开始学习，用Visual Studio 2013来编写，实际上也就是10-11月两个月有看，12月就因为各种原因暂时搁置了，目前也是总共看了13章的内容，还有5章内容，打算期末考试后，还是要重新看的。<br>    在看书方面，其实还是看得比较少，相反买书倒是比较多…看完的书有《Android编程权威指南》，这是在有3个月没有看android但是又要重新开始的时候，看的一本书，是外国人写的，中文版，首先是接触到一个MVC的架构，当然最近流行的是MVP架构，但我还没有好好去了解这个，有空要好好看看，其次就是它提倡的尽可能多用Fragment，因为看完也是有好几个星期，所以也就剩下这两个印象了。。这也暴露了没有好好做学习笔记以及做总结的坏习惯，所以2016年要努力养成做学习笔记，读书总结的好习惯才行！<br>    至于看过的书，还有就是《python基础教程》，这本书其实看得差不多了，前面教程都看了，就是后面实战例子没有看；<br>    入手的新书，除了上面提到的《统计学习方法》，android方面的有《Android群英传》，《Android开发艺术探索》，但这两本感觉是进阶的书籍，所以我是打算看完官方文档再好好看看的，还有就是《C++ primer》，这是英文版的，也打算挑战下自己吧，还有就是《编程之美》，《现代操作系统》，希望2016年可以看完至少一半的书吧。<br>    至于网上下载的电子书就更多了。。</p>
<p>   生活方面，去年辛苦减掉的几公斤体重就在11月底去深圳的时候，两天，两顿KFC的全家桶中给补回来了，加上12月入冬，缺乏锻炼，体重也是又回到70了，果然，锻炼身体，减脂增肌依然是2016的主题之一。<br>    旅游方面，6月底去了香港，澳门，这算是第一次出省游了，希望2016年也能再出省玩一次。</p>
<p><strong>2016 展望</strong><br>    对于2016年，首先学业上，当然是不挂科，同时尽量得高分啦，至少都有80分以上啦，奖学金希望是保三争二有一就是非常好了。。<br>    努力完成任务，不要让老板生气了；完成下跟同学的那个水表识别的任务，能发篇专利，有可能发论文也是好的。<br>    编程方面，android要好好学习，完成下想做的应用，一个跟阅读有关的应用，一个跟NBA相关的应用，水平能上一个层次，希望看完买的两本书和官方的training和guide文档，然后能有机会做一两个实际的项目，估计也是要看下java的书，巩固下java基础；<br>    C++是要看完买的两本书，至少是《C++ primer plus》，然后要看下数据结构和算法，也就是《大话数据结构》，还有就是看《现代操作系统》，如果有时间就看看《算法导论》吧，以及linux系统的知识；<br>    python呢，打算在写android的时候，用python来做下后台服务，也算是对python的一个应用，了解怎么用python写后台的。</p>
<p>   生活方面，当然是要多看书，做读书笔记，不过估计大部分的书都是上面提到的书了，另外就是多锻炼，或者是要学会健身，希望练出腹肌，身材更好，大腿小腿可以更瘦点！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年过去了，2016年开始了。<br><strong>2015 总结</strong><br>    回首2015，最大的变化就是从本科到研究生，上半年本科毕业了，下半年则是继续读研，当然还是在本校读研，学院也还是本学院，至于专业还是有所改变了，现在是属于计算机视觉方]]>
    </summary>
    
      <category term="总结" scheme="http://ccc013.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="随笔" scheme="http://ccc013.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio 安装配置问题总结]]></title>
    <link href="http://ccc013.github.io/2016/01/20/Android%20Studio%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://ccc013.github.io/2016/01/20/Android Studio 安装配置问题总结/</id>
    <published>2016-01-20T13:06:54.000Z</published>
    <updated>2016-01-21T10:02:03.528Z</updated>
    <content type="html"><![CDATA[<p>  之前一直都是使用Eclipse写Android的，但一直都有听说Android Studio是一个更好的用于开发Android的软件，之前其实也有保存过一些别人写的安装和配置Android Studio的一些教程，在这里也列出来：<br><a href="http://www.jianshu.com/p/36cfa1614d23" target="_blank" rel="external">Android Studio 入门指南</a>；<br><a href="http://android.jobbole.com/77635/" target="_blank" rel="external">Eclipse，到了说再见的时候了——Android Studio最全解析</a><br><a href="http://stormzhang.com/devtools/2014/11/25/android-studio-tutorial1/" target="_blank" rel="external">Android Studio系列教程一–下载与安装</a><br>另外，还有一个比较详细的介绍配置的博文系列：<br><a href="http://www.cnblogs.com/smyhvae/p/4390905.html" target="_blank" rel="external">第一次使用Android Studio时你应该知道的一切配置</a><br><a href="http://www.cnblogs.com/smyhvae/p/4392611.html" target="_blank" rel="external">第一次使用Android Studio时你应该知道的一切配置（二）：新建一个属于自己的工程并安装Genymotion模拟器</a><br><a href="http://www.cnblogs.com/smyhvae/p/4456420.html" target="_blank" rel="external">第一次使用Android Studio时你应该知道的一切配置（三）：gradle项目构建</a></p>
<p>在这里就总结下我安装的过程中遇到的一些问题吧，首先我是从<a href="https://github.com/inferjay/AndroidDevTools#sdk-tools" target="_blank" rel="external">SDK Tools - AndroidDevTools</a><br>这里下载的，毕竟尚未使用过翻墙软件，而且这个Github里面也分享了很多有关Android开发过程中使用到的一些工具，软件，还有一些电子书，资料非常齐全。</p>
<p>安装完成后，遇到几个问题，分别如下：</p>
<ol>
<li><p>首先第一个问题是弹出一个对话框，提示the environment variable JAVA_HOME(with the value of “F:\Java\JDK\” ) does not point to a valid JVM installation.<br>“F:\Java\JDK\”这是我安装jdk的文件路径<br>这个问题上网搜索了好久，有的说需要在JDK\后面加“；”，有的说去掉“\”，反正试了这几个都不行，我干脆就直接去掉“JDK\”,发现这个问题居然解决了….</p>
</li>
<li><p>在解决了第一个问题后，马上就出现第二个问题了，又弹出一个对话框显示以下这段文字：<br>‘ tools.jar’ seems to be not in Android Studio classpath.Please ensure JAVA_HOME points to JDK rather than JRE.”</p>
</li>
</ol>
<p>百度了这个问题，根据<a href="http://jingyan.baidu.com/article/ce4366491d06343773afd3cc.html" target="_blank" rel="external">‘tools.jar’seems to be not in Android Studio</a><br>这里给出的一些建议解决了问题，我主要是将jdk和jre分开了，并且没有设置SDK的环境变量，将这两个问题解决完后，就可以使用Android Studio了！</p>
<p>2015-12-24 补充<br>  因为换了新电脑，并且使用了win10的系统，所以需要重新安装java jdk，android sdk以及android studio，所以就在这再补充下前面安装配置jdk和sdk中遇到的问题。</p>
<p>首先是jdk，按照这个<a href="http://jingyan.baidu.com/article/fea4511a12b158f7bb9125b9.html" target="_blank" rel="external">如何在WIN10搭建Java开发环境</a>，在官网上下载jdk，安装，然后配置环境变量，但是在验证是否安装配置成功的时候，发现输入“java”是成功的，但是输入“javac”命令时，却提示了不是内部环境变量，但是在jdk的bin文件夹中是存在javac.exe这个文件，所以应该是配置环境变量中path的出问题了，当然我是按照上面教程中输入路径的，但是win10提供了浏览这个选项，通过这个找到要配置的文件路径，发现就成功解决这个问题了。<br><img src="http://img.blog.csdn.net/20151224205331635" alt="这里写图片描述"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>  之前一直都是使用Eclipse写Android的，但一直都有听说Android Studio是一个更好的用于开发Android的软件，之前其实也有保存过一些别人写的安装和配置Android Studio的一些教程，在这里也列出来：<br><a href="http://]]>
    </summary>
    
      <category term="Android" scheme="http://ccc013.github.io/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://ccc013.github.io/tags/Android-Studio/"/>
    
      <category term="技术" scheme="http://ccc013.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo+github pages 搭建博客总结]]></title>
    <link href="http://ccc013.github.io/2016/01/20/hexo+github%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
    <id>http://ccc013.github.io/2016/01/20/hexo+github 搭建博客总结/</id>
    <published>2016-01-20T08:49:44.000Z</published>
    <updated>2016-05-18T10:41:25.949Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_u524D_u8A00"><a href="#1-_u524D_u8A00" class="headerlink" title="1.前言"></a>1.前言</h2><p>   一直都希望能自己搭建个博客出来，所以在考完试后，也是从网上参考了很多用hexo+github pages搭建博客的文章，折腾了一天多，中间也是出现了一些问题，有一些还是暂时没有解决的问题。</p>
<p>   在搭建之前要对所用到的工具框架有个了解：</p>
<ul>
<li><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="external">Git</a></li>
<li><a href="https://github.com/" target="_blank" rel="external">Github</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a></li>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a></li>
<li><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="external">Markdown</a></li>
</ul>
<p>此外，在搭建过程中参考的文章有:<br>1.<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a><br>2.<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">GitHub-Pages-Hexo搭建博客</a><br>3.<a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">Hexo系列教程</a><br>4.<a href="http://wsgzao.github.io/post/hexo-guide/#准备工作" target="_blank" rel="external">使用GitHub和Hexo搭建免费静态Blog</a></p>
<h2 id="2-_u914D_u7F6EHexo"><a href="#2-_u914D_u7F6EHexo" class="headerlink" title="2.配置Hexo"></a>2.配置Hexo</h2><p>   首先查看Hexo的文档了解了Hexo的基本概念以及如何安装，当然还有使用的方法。</p>
<p>   Hexo官方文档（<a href="https://hexo.io/zh-cn/docs/index.html）" target="_blank" rel="external">https://hexo.io/zh-cn/docs/index.html）</a></p>
<p>（所以下面会有一大段是摘自官方文档的，当做笔记记录下）</p>
<p>  <strong>Hexo</strong></p>
<p>   Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</p>
<h3 id="281_29__u5B89_u88C5_u524D_u63D0"><a href="#281_29__u5B89_u88C5_u524D_u63D0" class="headerlink" title="(1) 安装前提"></a>(1) 安装前提</h3><p>安装Hexo的官方文档，需要安装有下面两个应用程序：</p>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<p><strong>安装Node.js</strong><br>我使用的是从<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>上下载安装，另一种安装方法是<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a></p>
<p><strong>安装Git</strong><br>我是使用官方版本的安装<a href="https://git-scm.com/download/win" target="_blank" rel="external">Git</a>,当然也是由于我是在win10上配置的，所以会选择这种方式，另外，还有一种安装方式：<a href="https://desktop.github.com/" target="_blank" rel="external">GitHub for Windows</a></p>
<p>如果是linux的话，就直接一行命令搞定了:</p>
<p>(Ubuntu,Debian):<br><code>sudo apt-get install git-core</code></p>
<p>(Fedora,Red Hat,CentOS):<br><code>sudo yum install git-core</code></p>
<p>Mac：使用<a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a>,<a href="http://www.macports.org/" target="_blank" rel="external">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="external">安装程序</a> 安装。</p>
<p><strong>Git配置以及使用</strong><br>有关Git的配置以及如何使用，我初学的时候，是根据<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="external">廖雪峰老师的Git教程</a>，这个教程简单易懂，看完是基本能懂得如何使用Git，并且教程还有教如何添加远程仓库，也就是Github，也就是如何关联一个远程仓库。</p>
<p>相关的一些资料：</p>
<ul>
<li><a href="http://backlogtool.com/git-guide/cn/intro/intro1_1.html" target="_blank" rel="external">猴子都能懂得GIT入门</a></li>
<li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="external">Git Magic</a></li>
<li><a href="http://www.jianshu.com/p/25647b9920b7" target="_blank" rel="external">Git 资源整理</a></li>
<li><a href="http://bach-dream.iteye.com/blog/1325159" target="_blank" rel="external">Github使用（一）生成本地项目上传</a></li>
<li><a href="http://wustrive2008.github.io/2016/01/06/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git%E5%85%A8%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%85%88%E7%94%A8%E8%B5%B7%E6%9D%A5/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">Git全解析之用起来先</a>,这个教程有附带一个关于git的知识结构图,如下所示:</li>
</ul>
<p><img src="http://7xifb5.com1.z0.glb.clouddn.com/wustrive-hexogit%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84.png" alt="git image"></p>
<p><strong>Github</strong><br>• 首先要注册一个Github的账号<br>• 建立一个与用户名对应的仓库，即仓库名为[your_user_name.github.com]或者[your_user.name.github.io]<br>• 添加SSH公钥到 Account settings -&gt; SSH Keys -&gt; Add SSH Key<br>关于添加SSH公钥的可以参考以下资料:<br><a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">Generating SSH keys</a><br><a href="https://help.github.com/articles/error-permission-denied-publickey/" target="_blank" rel="external">Error: Permission denied (publickey)</a></p>
<h3 id="282_29_Hexo_u7684_u5B89_u88C5_u548C_u4F7F_u7528"><a href="#282_29_Hexo_u7684_u5B89_u88C5_u548C_u4F7F_u7528" class="headerlink" title="(2) Hexo的安装和使用"></a>(2) Hexo的安装和使用</h3><h4 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h4><p>安装上面两个必须的应用程序后，就可以使用npm安装Hexo:<br><code>$ npm install -g hexo-cli</code></p>
<h4 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h4><p>安装完成后，可以使用如下命令初始化:<br><code>$ hexo init &lt;folder&gt;</code><br><code>$ cd &lt;folder&gt;</code><br><code>$ npm install</code></p>
<p>当然也可以先直接进入需要使用Hexo的文件夹，执行:<br><code>$ hexo init</code><br><code>$ npm install</code></p>
<p>初始化后的结果，就是在指定文件夹中，目录如下:</p>
<pre><code>.
├── _config.yml
    ├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><p>其中，source_posts 文件夹就是存放博客的文章，也就是.md文件</p>
<p>_config.yml是配置文件，主要是对这个文件进行配置，比如博客的名字，菜单显示，使用的主题等</p>
<p>scaffolds文件夹是模板文件夹，新建文章的时候，Hexo会根据它来建立文件</p>
<p>themes文件夹就是主题文件，Hexo会根据主题来生成静态页面，在Hexo中可以使用的主题是有很多的，可以从<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Themes</a>上选择自己喜欢的主题，更换主题需要将根目录下的<strong>_config.yml</strong>文件中的<code>theme:Landscape</code>更改成<code>theme:your_theme</code>,其中，<strong>Landscape</strong>是默认的主题</p>
<p><strong>本地浏览</strong><br>在执行下列命令后，就可以在浏览器中输入<code>localhost:4000</code>进行本地的浏览：</p>
<pre><code>$ hexo generate
$ hexo server
</code></pre><p><strong>但是在这步，我是一直都不成功，无论是输入<code>localhost:4000</code>,<code>127.0.0.1:4000</code>,这个问题我是百度了很久，发现在hexo的github的issue有人有同样的问题–<a href="https://github.com/hexojs/hexo/issues/1568" target="_blank" rel="external">win10系统hexo s以后http://localhost:4000打不开本地服务器 #1568</a>，现在这个问题我也是还没有搞明白为什么。</strong></p>
<p>虽然无法本地浏览，但是这也不是什么大问题，最终还是要部署在Github Pages上的</p>
<h3 id="283_29__u90E8_u7F72_u5230Github"><a href="#283_29__u90E8_u7F72_u5230Github" class="headerlink" title="(3) 部署到Github"></a>(3) 部署到Github</h3><p>在部署到GitHub前，需要安装一个插件:<br><code>$ npm install hexo-deployer-git --save</code><br>然后就修改根目录下的_config.yml文件中的:</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
type:
</code></pre><p>修改后的结果是：</p>
<pre><code>deploy:
 type: git
 repo: git@github.com:ccc013/ccc013.github.io.git
 branch: master
</code></pre><p><strong>repo</strong>是填写对应仓库的SSH地址<br>然后执行下列命令即可：</p>
<pre><code>$ hexo generate
$ hexo deploy
</code></pre><p>或者是<code>hexo deploy -g</code>也是同样的效果，然后就可以在浏览器中输入username.github.io进行浏览</p>
<p>但是这样在Github中的文件就是通过命令<code>hexo generate</code>生成的网站文件，而初始化生成的文件还是在本地电脑中的，也就是原始的文章是没有上传到Github的，这样如果更换了机器就不能继续修改你的博客了。</p>
<p>所以是希望在Github上可以保存原来的文章文件，这个方法呢，很多人都是用到的，就是在Github上建立分支了，比如建立一个hexo分支，然后设置它为默认分支，设置方法在<strong>Settings-&gt;Branches</strong>中</p>
<p>这个过程我初始是按照<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">GitHub-Pages-Hexo搭建博客</a>中来做的，但是在输入<code>hexo init</code>后，就会发现一开始<code>git clone</code>下来的文件中的.git文件没有了，并且之后也是无法<code>git push</code>到自己的github上，总是显示被拒绝的提示，本来我都是打算再建立一个仓库来存放文章了，但是后来又在上网搜索，看到这篇文章<a href="http://www.xrpmoon.com/blog/archives/jripple1281.html" target="_blank" rel="external">如何使用Hexo在Github上搭建自己的博客</a>中发布到github page的时候，就想自己应该是在本地的时候也是要新建一个同样名为hexo的分支，然后<code>git commit</code>到这个分支，于是就这么做，没想到真的成功了！</p>
<h3 id="284_29__u535A_u5BA2_u7BA1_u7406_u6D41_u7A0B"><a href="#284_29__u535A_u5BA2_u7BA1_u7406_u6D41_u7A0B" class="headerlink" title="(4) 博客管理流程"></a>(4) 博客管理流程</h3><p>所以现在对博客的修改就是如同<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">GitHub-Pages-Hexo搭建博客</a>中说得一样:<br><strong>日常修改</strong></p>
<ol>
<li>在本地修改博客，如添加新的博文，修改样式等；</li>
<li>在hexo分支下，依次执行<code>git add .</code>,<code>git commit -m &quot;...&quot;</code>,<code>git push origin hexo</code>,将改动push到GitHub上；</li>
<li>再执行<code>hexo deploy -g</code>,发布网站到master分支上。</li>
</ol>
<p><strong>更换电脑或者本地资料丢失</strong><br>1.使用 <code>git clone git@github.com:ccc013/ccc013.github.io.git</code> 拷贝仓库；<br>2.在本地拷贝下来的ccc013.github.io文件夹中通过Git bash依次执行下列命令：</p>
<pre><code>npm install hexo
npm install
npm install hexo-deployer-git
</code></pre><p>这里就不需要<code>hexo init</code>这个命令</p>
<h3 id="285_29__u4F7F_u7528_u95EE_u9898_u603B_u7ED3"><a href="#285_29__u4F7F_u7528_u95EE_u9898_u603B_u7ED3" class="headerlink" title="(5) 使用问题总结"></a>(5) 使用问题总结</h3><ol>
<li>/c/Users/cai/AppData/Roaming/npm/hexo: line 12: node: command not found<br>(更新于2016-03-07)</li>
</ol>
<p>在搭建完博客后，有一段时间没有使用后，然后需要更新下博文或者样式时，在Git bash敲下命令<code>hexo g</code>，居然出现上述错误信息，然后发现输入任何有关hexo的命令都是同样的错误，我又试着敲了npm这个命令，发现也是出错的，但是在系统命令行中输入<code>node -v</code>和<code>npm -v</code>,都正常显示了版本信息，于是我想估计是环境变量设置有问题，我在用户的环境变量PATH中添加了两个路径，分别是<code>C:\Users\cai\node_modules\hexo\bin</code>和<code>C:\Program Files\nodejs</code>，再加上原来就添加的路径<code>C:\Users\cai\AppData\Roaming\npm</code>，发现就解决这个问题了，可以正常修改博文，然后发布网站。</p>
<p>不过，我也不清楚是否完全解决这个问题，还需要观察一段时间。</p>
<h3 id="286_29_Markdown_u77E5_u8BC6_u70B9_u603B_u7ED3"><a href="#286_29_Markdown_u77E5_u8BC6_u70B9_u603B_u7ED3" class="headerlink" title="(6) Markdown知识点总结"></a>(6) Markdown知识点总结</h3><p><strong>生成md文件</strong><br>命令<code>hexo new &quot;文件名&quot;</code>就可以生成一个md文件，然后就可以开始写文章，但是这里用到Markdown的语法，同时我们也需要一个专门可以用来写markdown的工具。</p>
<p>这个工具，我使用的是<a href="http://www.sublimetext.com/3" target="_blank" rel="external">sublime text 3</a>,这是一个文本编辑器，可以支持多种编程语言和文件格式，当然也就包括Markdown语法，具体配置方法可以参考如下:<br><a href="http://zh.lucida.me/blog/sublime-text-complete-guide/" target="_blank" rel="external">Sublime Text 全程指南</a>,<br><a href="https://github.com/jikeytang/sublime-text" target="_blank" rel="external">Sublilme Text 资源整理</a><br><a href="http://blog.saymagic.cn/2015/06/20/write-blog-by-sublime.html" target="_blank" rel="external">Sublime进阶使用</a></p>
<p>这个工具还是非常强大的，之前是我用来写python的，现在搭建博客后，就可以用来写Markdown的文件了。</p>
<p><strong>Markdown语法</strong><br>具体的可以参考<a href="http://wowubuntu.com/markdown/index.html#code" target="_blank" rel="external">Markdown 语法说明</a></p>
<p>这里就记录下暂时用得比较多的：</p>
<p><strong>标题</strong><br><code>=</code>,<code>-</code> 分别表示最高阶和第二阶标题，这两种是在文字下一行插入；</p>
<p>在行首插入1到6个<code>#</code> 分别对应标题1到6</p>
<p><strong>段落和换行</strong><br>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p><strong>列表</strong><br>无序列表使用星号、加号或者减号，而有序列表是数字加一个英文句点<code>.</code> </p>
<p><strong>代码和代码区块</strong><br>使用一个反引号``可以得到代码，而代码区块是每行缩进4个空格或者一个制表符，也就是键盘上的Tab键，当然首先跟上一行要隔着一个空行才行。</p>
<hr>
<p><strong>分隔线</strong><br>在一行中使用三个以上的星号、减号、底线来建立一个分隔线，行中不能有其他东西。</p>
<p><strong>链接</strong><br>用的比较多的是行内式，也就是一个方括号<code>[]</code>后面加一个括号<code>()</code>,括号中是链接地址，而方括号中可以是网址的标题，或者对你对网址内容的简单总结</p>
<p><strong>强调</strong><br>一个<code>*</code>或者<code>_</code>包围的文字是斜体的效果，而两个<code>*</code>或者<code>_</code>包围则是强调的效果</p>
<p><strong>图片</strong><br>格式如下：</p>
<pre><code>![image](/path/img.jpg)
![image](/path/img.jpg &quot;title&quot;)
</code></pre><p>方括号中是图片的替代文字，而第二种写法中最后的引号内容是可以选择的标题文字</p>
<p><strong>锚的使用</strong><br>使用命名锚，我们就可以创建目录，点击目录就可以跳至该命名锚，也就是同一个页面中某个小节的位置。</p>
<p>一开始是根据markdown的语法，但是发现并没有实现这个功能，后来搜索了下，根据<a href="http://ju.outofmemory.cn/entry/115045" target="_blank" rel="external">markdown中命名锚</a>中给出的方法，也就是使用html的语法，也就是目录使用，比如<code>[Overview](#overview)</code>,而在命名锚所要到的位置，使用如<code>&lt;h3 id=&quot;overview&quot;&gt;Overview&lt;/h3&gt;</code>,主要是<strong>id</strong>属性来命名锚，这样点击目录中的Overview,就会跳至<code>&lt;h3 id=&quot;overview&quot;&gt;Overview&lt;/h3&gt;</code>处了。</p>
<h2 id="3__u603B_u7ED3"><a href="#3__u603B_u7ED3" class="headerlink" title="3 总结"></a>3 总结</h2><p>从昨天，也就是1月20号弄了一天，但是并没有解决如何在Github上存放原始文章文件，今天下午则是找到解决方法，并且成功解决了，然后写下这篇总结。</p>
<p>目前完成的也只是比较简单的内容，还有很多内容可以增加，此外搭建这个博客的本意是促使自己可以多总结多写博客，最终的目的是要掌握好学到的技术知识，所以现在仅仅是一个准备动作，最多也就是迈出一小步了，还需要自己不断坚持，不断学习，不断努力！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_u524D_u8A00"><a href="#1-_u524D_u8A00" class="headerlink" title="1.前言"></a>1.前言</h2><p>   一直都希望能自己搭建个博客出来，所以在考完试后，也是从网上参考了很多用hexo]]>
    </summary>
    
      <category term="Git" scheme="http://ccc013.github.io/tags/Git/"/>
    
      <category term="Github" scheme="http://ccc013.github.io/tags/Github/"/>
    
      <category term="Hexo" scheme="http://ccc013.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="http://ccc013.github.io/tags/Markdown/"/>
    
      <category term="技术" scheme="http://ccc013.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
