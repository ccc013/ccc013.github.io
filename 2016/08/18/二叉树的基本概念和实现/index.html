<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据结构,算法," />





  <link rel="alternate" href="/atom.xml" title="Cai's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon/favicon.png?v=5.0.1" />






<meta name="description" content="继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。
树
树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。

在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的孩子(children)，而Joe是他们的父母(parent)。有相同">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树的基本概念和实现">
<meta property="og:url" content="http://ccc013.github.io/2016/08/18/二叉树的基本概念和实现/index.html">
<meta property="og:site_name" content="Cai's blog">
<meta property="og:description" content="继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。
树
树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。

在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的孩子(children)，而Joe是他们的父母(parent)。有相同">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%911.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%912.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%913.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%914.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%911.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%912.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%913.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%914.png">
<meta property="og:updated_time" content="2016-08-18T07:05:37.766Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="二叉树的基本概念和实现">
<meta name="twitter:description" content="继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。
树
树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。

在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的孩子(children)，而Joe是他们的父母(parent)。有相同">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 5881344,
      author: '博主'
    }
  };
</script>

  <title> 二叉树的基本概念和实现 | Cai's blog </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div style="display: none;">
    <script src="http://s6.cnzz.com/stat.php?id=1257376919&web_id=1257376919" type="text/javascript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <!-- add Fork me on Github -->
    <a href="https://github.com/ccc013"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"></a>

    <!--add Fork me on Github  -->
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Cai's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Stay hungry, stay foolish</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/abou" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                二叉树的基本概念和实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-18T15:05:01+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/18/二叉树的基本概念和实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/18/二叉树的基本概念和实现/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/18/二叉树的基本概念和实现/" class="leancloud_visitors" data-flag-title="二叉树的基本概念和实现">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="u6811"><a href="#u6811" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。</p>
</blockquote>
<p>在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的<strong>孩子(children)</strong>，而Joe是他们的<strong>父母(parent)</strong>。有相同父母的孩子是<strong>兄弟(sibling)</strong>。Ann，Mary,John都是兄弟。此外，还有其他术语：<strong>孙子(grandchild),祖父(grandparent),祖先(ancestor),后代(descendent)等</strong>。树中没有孩子的元素称为<strong>叶子(leaf)</strong>。图中Ann,Mark,Sue和Chris是树的叶子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>树的另一个常用术语是<strong>级(level)</strong>。指定树根的级是1，其孩子的级是2，依次类推。上图中Joe的级是1，而Ann，Mary,John的级是2，然后Mark,Sue,Chris的级是3。</p>
<p><strong>元素的度是指其孩子的个数。</strong>叶节点的度是0。<strong>树的度是其元素度的最大值</strong>。所以上图中的度是3。</p>
<h3 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p>定义：二叉树(binary tree)t是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个称为根的元素，余下的元素（如果有的话）被组成2个二叉树，分别称为t的左子树和右子树。</p>
</blockquote>
<p><strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树可以为空，树不能为空</li>
<li>二叉树中每个元素都恰好有两棵子树（其中一个或两个可能为空）。而树中每个元素可以有若干子树。</li>
<li>在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树间是无序的。</li>
</ul>
<p>下图给出了表示数学表达式的二叉树，总共有3个数学表达式。每个操作符可以有一个或两个操作数，左操作数是操作符的左子树，而右操作数则是右子树。树中的叶节点是常量或者变量。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h3 id="u4E8C_u53C9_u6811_u7684_u7279_u6027"><a href="#u4E8C_u53C9_u6811_u7684_u7279_u6027" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><blockquote>
<p><strong>特性1： 包含n(n&gt;0)个元素的二叉树边数是n-1。</strong></p>
</blockquote>
<p>证明 二叉树中每个元素 (除了根节点)有且只有一个父节点。在子节点与父节点间有且只有一条边，因此边数为n-1。</p>
<p><strong>二叉树的高度或者深度是指该二叉树的层数。</strong></p>
<blockquote>
<p><strong>特性2： 若二叉树的高度为h,$h \ge 0$,则该二叉树最少有h个元素，最多有$2^h - 1$个元素。</strong></p>
</blockquote>
<p>证明 因为每一层最少要有1个元素，因此元素数最少为h。每元素最多有2个子节点，则第i层节点元素最多为$2^i-1$个,i&gt;0。h=0时，元素的总数为0，也就是$2^0-1$。当h&gt;0时，元素的总数不会超过$\sum_{i=1}^h 2^{i-1}=2^h-1$。</p>
<blockquote>
<p><strong>特性3： 包含n个元素的二叉树的高度最大是n，最小是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
</blockquote>
<p>证明 因为每层至少有一个元素，因此高度不会超过n。由特性2，可以得知高度为h的二叉树最多有$2^h-1$个元素。因为$n \le 2^h-1$,因此$h \ge log_2(n+1)$。由于h是整数，所以$h \ge \left\lceil  log_2(n+1) \right\rceil$。</p>
<p><strong>当高度是h的二叉树恰好有$2^h - 1$个元素时，称其为满二叉树(full binary tree)。</strong>下图就是一个高度为4的满二叉树。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>假设对高度为h的满二叉树中的元素从上到下，从左到右的顺序进行从1到$2^h - 1$进行编号，如上图所示。假设从满二叉树中删除k个元素，其编号为$2^h - i, 1 \le i \le k$,所得到的二叉树称为<strong>完全二叉树(complete binary tree)</strong>。如下图给出的三棵完全二叉树。注意，<strong>满二叉树是完全二叉树的一个特例，并且有n个元素的完全二叉树的深度是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>在完全二叉树中，一个元素与其孩子的编号有非常好的对应关系。其关系在下面特性4中给出。</p>
<blockquote>
<p><strong>特性4： 设完全二叉树中一元素的序号是i，$1 \le i \le n$。则有以下关系成立：</strong><br>1) 当i=1时，该元素为二叉树的根，若i&gt;1,则该元素父节点的编号是$\left\lfloor i/2 \right\rfloor$。<br>2) 当2i&gt;n时，该元素没有左子树，否则，其左子树的编号是2i。<br>3) 若2i+1&gt;n时，该元素没有右子树，否则，其右子树的编号是2i+1。</p>
</blockquote>
<h3 id="u4E8C_u53C9_u6811_u63CF_u8FF0"><a href="#u4E8C_u53C9_u6811_u63CF_u8FF0" class="headerlink" title="二叉树描述"></a>二叉树描述</h3><h4 id="u516C_u5F0F_u5316_u63CF_u8FF0"><a href="#u516C_u5F0F_u5316_u63CF_u8FF0" class="headerlink" title="公式化描述"></a>公式化描述</h4><p>  二叉树的公式化描述利用特性4。二叉树可以作为缺少了部分元素的完全二叉树。下图给出了二叉树的两个例子。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  在公式化描述方法中，按照二叉树对元素的编号方法，将二叉树的元素存储在数组中。上图同时给出了二叉树的公式化描述，即图中右侧的数组表示。</p>
<p>  当缺少很多元素时，这种描述方法非常浪费空间。实际上，一个有n个元素的二叉树可能最多需要$2^n-1$的空间来存储。当每个节点都是其他节点的右孩子时，存储空间达到最大。如下图所示的一棵有四个元素的二叉树，这种类型的二叉树称为右斜二叉树。当缺少的元素比较少时，这种描述方法很有效。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h4 id="u94FE_u8868_u63CF_u8FF0"><a href="#u94FE_u8868_u63CF_u8FF0" class="headerlink" title="链表描述"></a>链表描述</h4><p>  <strong>二叉树最常用的描述方法是用链表或指针。</strong>每个元素都用一个有两个指针域的节点表示，这两个域是<strong>LeftChild和RightChild</strong>。除此两个指针域外，每个节点还有一个data域。其代码实现如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class BinaryTreeNode&#123;&#10;    friend void Visit(BinaryTreeNode&#60;T&#62; *);&#10;    friend void InOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void PreOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void PostOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void LevelOrder(BinaryTreeNode&#60;T&#62; *);&#10;    friend void main(void);&#10;private:&#10;    T data;&#10;    BinaryTreeNode&#60;T&#62;* LeftChild, *RightChild;&#10;public:&#10;    BinaryTreeNode()&#123;&#10;        LeftChild = RightChild = 0;&#10;    &#125;&#10;    BinaryTreeNode(const T&#38; e)&#123;&#10;        data = e;&#10;        LeftChild = RightChild = 0;&#10;    &#125;&#10;    BinaryTreeNode(const T&#38;e, BinaryTreeNode *l, BinaryTreeNode* r)&#123;&#10;        data = e;&#10;        LeftChild = l;&#10;        RightChild = r;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的边可以用一个从父节点到子节点的指针来描述。指针放在父节点的指针域中，因为包括n个元素的二叉树恰有n-1条边，所以有<code>2n-(n-1)=n+1</code>个指针域没有值，这些域被值为0。下图给出了公式化描述中第一幅图的二叉树的链表描述。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>二叉树中不设置指向父节点的指针一般不会有什么问题，因为在二叉树的大部分函数中并不需要此指针。</p>
<h3 id="u4E8C_u53C9_u6811_u904D_u5386"><a href="#u4E8C_u53C9_u6811_u904D_u5386" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>  有四种遍历二叉树的方法：</p>
<ul>
<li><strong>前序遍历</strong></li>
<li><strong>中序遍历</strong></li>
<li><strong>后序遍历</strong></li>
<li><strong>逐层遍历</strong></li>
</ul>
<p>前3种遍历方法将在下面给出代码实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void PreOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    if (t)&#123;&#10;        // &#35775;&#38382;&#26681;&#33410;&#28857;&#10;        Visit(t);&#10;        // &#21069;&#24207;&#36941;&#21382;&#24038;&#23376;&#26641;&#10;        PreOrder(t-&#62;LeftChild);&#10;        // &#21069;&#24207;&#36941;&#21382;&#21491;&#23376;&#26641;&#10;        PreOrder(t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void InOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    if (t)&#123;&#10;        // &#20013;&#24207;&#36941;&#21382;&#24038;&#23376;&#26641;&#10;        InOrder(t-&#62;LeftChild);&#10;        Visit(t);&#10;        InOrder(t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void PostOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    if (t)&#123;&#10;        // &#21518;&#24207;&#36941;&#21382;&#24038;&#23376;&#26641;&#10;        PostOrder(t-&#62;LeftChild);&#10;        PostOrder(t-&#62;RightChild);&#10;        Visit(t);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三种方法，每个节点的左子树都在其右子树之前遍历。<strong>这三种遍历的区别在于对同一个节点在不同时刻进行访问。</strong>在进行前序遍历时，每个节点是在其左右子树被访问之前进行访问的；在中序遍历时，首先访问左子树，然后访问子树的根节点，最后访问右子树。在后序遍历时，当左右子树均访问完之后才访问子树的根节点。</p>
<p>下图给出上述三种方法对前文给出的数学表达式分别产生的结果，其中<code>Visit(t)</code>由<code>cout&lt;&lt; t-&gt;data;</code>代替。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>当对一棵数学表达式树进行前、中、后序遍历时，便分别得到表达式的前缀、中缀和后缀表达式。中缀（infix）形式就是平时书写的数学表达式。使用中缀形式的时候由于没有括号，可能会产生一些歧义，比如对于<code>x+y*z</code>，可以理解为<code>(x+y)*z</code>或者<code>x+(y*z)</code>，为了避免这种歧义，可以使用完全括号化的中缀表达式，每个操作符和相应的操作数都用一对括号括起来。下面是改进后的中序遍历算法的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void Infix(BinaryTreeNode&#60;T&#62; *t)&#123;&#10;    // &#36755;&#20986;&#23436;&#20840;&#25324;&#21495;&#30340;&#20013;&#32512;&#34920;&#36798;&#24335;&#10;    if (t)&#123;&#10;        cout &#60;&#60; &#34;(&#34;;&#10;        // &#24038;&#25805;&#20316;&#25968;&#10;        Infix(t-&#62;LeftChild);&#10;        // &#25805;&#20316;&#31526;&#10;        cout &#60;&#60; t-&#62;data;&#10;        // &#21491;&#25805;&#20316;&#25968;&#10;        Infix(t-&#62;RightChild);&#10;        cout &#60;&#60; &#34;)&#34;;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在后缀(postfix)表达式中，每个操作符跟在操作数之后，操作数从左到右的顺序出现；在前缀(prefix)表达式中，操作符位于操作数之前。前缀和后缀表达式都不会存在歧义，不需要采用括号或者优先级。从左到右或者从右到左扫描表达式并采用操作数栈，可以很容易确定操作数和操作符的关系。若在扫描中遇到一个操作数，把它压入堆栈，遇到一个操作符，则将其与栈顶的操作数相匹配，把这些操作数推出栈，由操作符执行相应的计算，并将所得结果作为操作数压入堆栈。</p>
<p>逐层遍历就是<strong>按从顶层到底层的次序访问树中元素，在同一层中，从左到右进行访问。</strong>由于遍历中使用的是一个队列而不是栈，因此写一个按层遍历的递归程序很困难。下列程序是采用队列来实现对二叉树进行逐层遍历，队列中的元素指向二叉树节点，这里使用了之前<a href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%971-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">队列章节</a>中使用的类<strong>LinkedQueue</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void LevelOrder(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#23545;*t&#36880;&#23618;&#36941;&#21382;&#10;    LinkedQueue&#60;BinaryTreeNode&#60;T&#62;*&#62;  Q;&#10;    while (t)&#123;&#10;        Visit(t);&#10;        // &#23558;t&#30340;&#21491;&#23401;&#23376;&#25918;&#20837;&#38431;&#21015;&#10;        if (t-&#62;LeftChild)&#10;            Q.Add(t-&#62;LeftChild);&#10;        if (t-&#62;RightChild)&#10;            Q.Add(t-&#62;RightChild);&#10;        // &#35775;&#38382;&#19979;&#19968;&#20010;&#33410;&#28857;&#10;        try&#123;&#10;            Q.Delete(t);&#10;        &#125;&#10;        catch (OutOfBounds)&#123;&#10;            return;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述程序中，首先仅当树非空时，才进入<code>while</code>循环。首先访问根节点，然后将其子节点加到队列中。当队列添加操作失败时，由Add会引发<code>NoMem</code>异常，由于没有捕捉该异常，所以发生该异常时函数将退出。在添加操作成功后，就进行从队列中删除t元素，如果成功，则删除的元素会返回到t中，这个删除的元素也就是下一个要访问的节点。下次访问该节点的时候，又会将其左右子树加入到队列的尾部，然后下一个要访问的就是根节点的右子树（如果存在），如此就可以实现逐层遍历了。而如果删除失败就表明队列为空，也就是意味着遍历的结束。</p>
<p>假设二叉树中元素的数目是<code>n</code>。这四种遍历算法的空间复杂性均为$O(n)$,时间复杂性是$\theta(n)$。当t的高度是n的时候，通过观察期前序、中序和后序遍历时所使用的递归栈空间可得到上述结论。当t是满二叉树的时候，逐层遍历所需要的队列空间是$\theta(n)$。每个遍历算法花在树中每个节点上的时间是$\theta(1)$(假设访问一个节点的时间是$\theta(1)$)。</p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578BBinaryTree"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578BBinaryTree" class="headerlink" title="抽象数据类型BinaryTree"></a>抽象数据类型BinaryTree</h3><p>  下面给出二叉树的抽象数据类型，这里只列出几个常用的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25277;&#35937;&#25968;&#25454;&#31867;&#22411; BinaryTree&#123;&#10;&#23454;&#20363;&#10;    &#20803;&#32032;&#38598;&#21512;&#65307;&#22914;&#26524;&#19981;&#31354;&#65292;&#21017;&#34987;&#21010;&#20998;&#20026;&#26681;&#33410;&#28857;&#12289;&#24038;&#23376;&#26641;&#21644;&#21491;&#23376;&#26641;&#65307;&#10;    &#27599;&#20010;&#23376;&#26641;&#20173;&#26159;&#19968;&#20010;&#20108;&#21449;&#26641;&#10;&#25805;&#20316;&#10;    Create()&#65306;&#21019;&#24314;&#19968;&#20010;&#31354;&#30340;&#20108;&#21449;&#26641;&#65307;&#10;    IsEmpty&#65306;&#22914;&#26524;&#20108;&#21449;&#26641;&#20026;&#31354;&#65292;&#21017;&#36820;&#22238; true &#65292;&#21542;&#21017;&#36820;&#22238;false&#10;    Root(x)&#65306;&#21462;x&#20026;&#26681;&#33410;&#28857;&#65307;&#22914;&#26524;&#25805;&#20316;&#22833;&#36133;&#65292;&#21017;&#36820;&#22238;false&#65292;&#21542;&#21017;&#36820;&#22238;true&#10;    MakeTree(root,left&#65292;right)&#65306;&#21019;&#24314;&#19968;&#20010;&#20108;&#21449;&#26641;&#65292;root&#20316;&#20026;&#26681;&#33410;&#28857;&#65292;left&#20316;&#20026;&#24038;&#23376;&#26641;&#65292; right&#20316;&#20026;&#21491;&#23376;&#26641;&#10;    BreakTree(root&#65292;left&#65292;right)&#65306;&#25286;&#20998;&#20108;&#21449;&#26641;&#10;    PreOrder&#65306;&#21069;&#24207;&#36941;&#21382;&#10;    InOrder&#65306;&#20013;&#24207;&#36941;&#21382;&#10;    PostOrder&#65306;&#21518;&#24207;&#36941;&#21382;&#10;    LevelOrder&#65306;&#36880;&#23618;&#36941;&#21382;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u7C7BBinaryTree"><a href="#u7C7BBinaryTree" class="headerlink" title="类BinaryTree"></a>类BinaryTree</h3><p>  下面给出类<strong>BinaryTree</strong>的C++定义。函数<strong>Visit</strong>作为遍历函数的参数，以实现不同操作的实现。该定义中使用了链表描述的二叉树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;class BinaryTree&#123;&#10;private:&#10;    BinaryTreeNode&#60;T&#62; *root;    // &#26681;&#33410;&#28857;&#25351;&#38024;&#10;    void PreOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t);&#10;    void Inorder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t);&#10;    void PostOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t);&#10;public:&#10;    BinaryTree()&#123; root = 0; &#125;&#10;    ~BinaryTree()&#123;&#125;;&#10;    bool IsEmpty() const&#123;&#10;        return ((root) ? false : true);&#10;    &#125;&#10;    bool Root(T&#38; x)const;&#10;    void MakeTree(const T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right);&#10;    void BreakTree(const T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right);&#10;    void PreOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u))&#123;&#10;        PreOrder(Visit, root);&#10;    &#125;&#10;    void Inorder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u))&#123;&#10;        Inorder(Visit, root);&#10;    &#125;&#10;    void PostOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u))&#123;&#10;        PostOrder(Visit, root);&#10;    &#125;&#10;    void LevelOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u));&#10;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面会给出共享成员函数<code>Root,MakeTree,BreakTree</code>的代码。函数<code>MakeTree</code>和<code>BreakTree</code>要求参与操作的三棵树应该互不相同，否则程序会得出错误的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;bool BinaryTree&#60;T&#62;::Root(T&#38; x)const&#123;&#10;    // &#21462;&#26681;&#33410;&#28857;&#30340;data&#22495;&#65292;&#25918;&#20837;x&#65292;&#22914;&#26524;&#27809;&#26377;&#21017;&#36820;&#22238;false&#10;    if (root)&#123;&#10;        x = root-&#62;data;&#10;        return true;&#10;    &#125;&#10;else&#10;    return false;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::MakeTree(const T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right)&#123;&#10;    // &#23558;left&#65292;right&#21644;element&#21512;&#24182;&#25104;&#19968;&#26869;&#26032;&#26641;&#65292;&#24182;&#19988;&#35201;&#27714;left&#21644;right&#21450;this&#24517;&#39035;&#26159;&#19981;&#21516;&#30340;&#26641;&#12290;&#10;&#10;    // &#21019;&#24314;&#26032;&#26641;&#10;    root = new BinaryTreeNode&#60;T&#62;(element, left.root, right.root);&#10;&#10;    // &#38459;&#27490;&#35775;&#38382;left&#21644;right&#10;    left.root = right.root = 0;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::BreakTree(T&#38; element, BinaryTree&#60;T&#62;&#38; left, BinaryTree&#60;T&#62;&#38; right)&#123;&#10;    // left,right &#21644;this&#24517;&#39035;&#26159;&#19981;&#21516;&#30340;&#26641;&#10;    if (!root)&#10;        // &#31354;&#26641;&#10;        throw BadInput();&#10;&#10;    // &#20998;&#35299;&#26641;&#10;    element = root-&#62;data;&#10;    left.root = root-&#62;LeftChild;&#10;    right.root = root-&#62;RightChild;&#10;&#10;    delete root;&#10;    root = 0;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出四种遍历方法的实现代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::PreOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#21069;&#24207;&#36941;&#21382;&#10;    if (t)&#123;&#10;        Visit(t);&#10;        PreOrder(Visit, t-&#62;LeftChild);&#10;        PreOrder(Visit, t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::Inorder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#20013;&#24207;&#36941;&#21382;&#10;    if (t)&#123;&#10;        Inorder(Visit, t-&#62;LeftChild);&#10;        Visit(t);&#10;        Inorder(Visit, t-&#62;RightChild);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::PostOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;*u), BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    // &#21518;&#24207;&#36941;&#21382;&#10;    if (t)&#123;&#10;        PostOrder(Visit, t-&#62;LeftChild);&#10;        PostOrder(Visit, t-&#62;RightChild);&#10;        Visit(t);&#10;    &#125;&#10;&#125;&#10;&#10;template&#60;class T&#62;&#10;void BinaryTree&#60;T&#62;::LevelOrder(void(*Visit)(BinaryTreeNode&#60;T&#62;* u))&#123;&#10;    // &#36880;&#23618;&#36941;&#21382;&#10;    LinkedQueue&#60;BinaryTreeNode&#60;T&#62;*&#62;Q;&#10;    BinaryTreeNode&#60;T&#62; *t;&#10;    t = root;&#10;    while (t)&#123;&#10;        Visit(t);&#10;        // &#23558;t&#30340;&#21491;&#23401;&#23376;&#25918;&#20837;&#38431;&#21015;&#10;        if (t-&#62;LeftChild)&#10;            Q.Add(t-&#62;LeftChild);&#10;        if (t-&#62;RightChild)&#10;            Q.Add(t-&#62;RightChild);&#10;        // &#35775;&#38382;&#19979;&#19968;&#20010;&#33410;&#28857;&#10;        try&#123;&#10;            Q.Delete(t);&#10;        &#125;&#10;        catch (OutOfBounds)&#123;&#10;            return;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是对类BinaryTree的简单应用，程序中构造了一个四节点的二叉树，并进行了前序遍历以确定书中的节点数目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&#60;iostream&#62;&#10;#include&#34;xcept.h&#34;&#10;#include&#34;BinaryTree.h&#34;&#10;&#10;using std::cout;&#10;using std::endl;&#10;using std::cin;&#10;&#10;int count = 0;&#10;BinaryTree&#60;int&#62;a, x, y, z;&#10;&#10;template&#60;class T&#62;&#10;void ct(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    count++;&#10;&#125;&#10;&#10;void main(void)&#123;&#10;    y.MakeTree(1, a, a);&#10;    z.MakeTree(2, a, a);&#10;    x.MakeTree(3, y, z);&#10;    y.MakeTree(4, x, a);&#10;    y.PreOrder(ct);&#10;    cout &#60;&#60;&#34;Tree y has &#34;&#60;&#60; count &#60;&#60;&#34; nodes&#34;&#60;&#60; endl;&#10;&#10;    system(&#34;pause&#34;);&#10;    return;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u62BD_u8C61_u6570_u636E_u7C7B_u578B_u53CA_u7C7B_u7684_u6269_u5145"><a href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B_u53CA_u7C7B_u7684_u6269_u5145" class="headerlink" title="抽象数据类型及类的扩充"></a>抽象数据类型及类的扩充</h3><p>  本节将扩充之前给出的抽象数据类型，增加如下二叉树操作：</p>
<ul>
<li><strong>PreOutput():</strong>按前序方式输出数据域</li>
<li><strong>InOutput():</strong>按中序方式输出数据域</li>
<li><strong>PostOutput():</strong>按后序方式输出数据域</li>
<li><strong>LevelOutput():</strong>逐层输出数据域</li>
<li><strong>Delete():</strong>删除一棵二叉树，释放其节点</li>
<li><strong>Height():</strong>返回树的高度</li>
<li><strong>Size():</strong>返回树中节点数</li>
</ul>
<h4 id="u8F93_u51FA"><a href="#u8F93_u51FA" class="headerlink" title="输出"></a>输出</h4><p>  四个输出函数可以通过定义一个私有静态成员函数Output来实现，该函数代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void Output(BinaryTreeNode&#60;T&#62;*t)&#123;&#10;    cout &#60;&#60; t-&#62;data &#60;&#60; &#34;, &#34;;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而四个共享输出函数的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void PreOutput()&#123;&#10;    PreOrder(Output, root);&#10;    cout &#60;&#60; endl;&#10;&#125;&#10;void InOutput()&#123;&#10;    Inorder(Output, root);&#10;    cout &#60;&#60; endl;&#10;&#125;&#10;void PostOutput()&#123;&#10;    PostOrder(Output, root);&#10;    cout &#60;&#60; endl;&#10;&#125;&#10;void PreOutput()&#123;&#10;    LevelOrder(Output);&#10;    cout &#60;&#60; endl;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Visit操作的时间复杂性是$\theta(1)$,对包括n个节点的二叉树来说，每种遍历方法所花费的时间是$\theta(n)$(遍历成功的话），因此每种输出方法的时间复杂性均为$\theta(n)$。</p>
<h4 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h4><p>  要删除一棵二叉树，需要删除其所有节点，可以通过<strong>后序遍历</strong>在访问一个节点时，将其删除，也就是先删除左子树，然后右子树，最后删除根。因此函数<strong>Delete</strong>的形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Delete()&#123;&#10;    PostOrder(Free, root);&#10;    root = 0;&#10;&#125;&#10;static void Free(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    delete t;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中函数<strong>Free</strong>是一个私有成员函数。要删除的二叉树有n个节点时，<strong>Delete</strong>函数的时间复杂性是$\theta(n)$。</p>
<h4 id="u8BA1_u7B97_u9AD8_u5EA6"><a href="#u8BA1_u7B97_u9AD8_u5EA6" class="headerlink" title="计算高度"></a>计算高度</h4><p>  <strong>通过进行后序遍历，可以得到二叉树的高度。</strong>首先得到左子树的高度hl，然后得到右子树的高度hr，则树的高度为<strong>max{hl,hr}+1</strong>。</p>
<p>  但是这里不能使用之前定义的后序遍历代码，因为在进行遍历的时候需要有返回值（也就是子树的高度）。所以首先需要在增加一个共享成员函数Height,其代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Height() const&#123;&#10;    return Height(root);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后增加一个私有成员函数<strong>Height</strong>，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&#60;class T&#62;&#10;int BinaryTree&#60;T&#62;::Height(BinaryTreeNode&#60;T&#62; *t)const&#123;&#10;    // &#36820;&#22238;&#26641;*t&#30340;&#39640;&#24230;&#10;    if (!t)&#10;        return 0;&#10;    // &#24038;&#23376;&#26641;&#39640;&#24230;&#10;    int hl = Height(t-&#62;LeftChild);&#10;    // &#21491;&#23376;&#26641;&#30340;&#39640;&#24230;&#10;    int hr = Height(t-&#62;RightChild);&#10;    if (hl &#62; hr)&#10;        return ++hl;&#10;    else&#10;        return ++hr;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数的时间复杂性是$\theta(n)$。</p>
<h4 id="u7EDF_u8BA1_u8282_u70B9_u6570"><a href="#u7EDF_u8BA1_u8282_u70B9_u6570" class="headerlink" title="统计节点数"></a>统计节点数</h4><p>  可以用上述四种遍历方法中的任何一种来获取二叉树中的节点数，因为每种遍历方法都对每个节点仅访问一次，只要在访问每个节点的时候将一个全局计数器加1即可。所以首先在类<strong>BinaryTree</strong>定义外定义一个全局变量：<code>int _count;</code>,然后增加一个共享成员函数<strong>Size</strong>和私有成员函数<strong>Add1</strong>，其代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void Add1(BinaryTreeNode&#60;T&#62;* t)&#123;&#10;    _count++;&#10;&#125;&#10;&#10;int Size()&#123;&#10;    _count = 0;&#10;    PreOrder(Add1, root);&#10;    return _count;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<strong>Size</strong>的时间复杂性是$\theta(n)$。</p>
<p>对于类<strong>BinaryTree</strong>的定义以及测试例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/BinaryTree" target="_blank" rel="external">二叉树</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><p>  本节内容主要是介绍了树的基本概念以及二叉树的定义、特性和实现代码，包括四种遍历树的方法。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag">#数据结构</a>
          
            <a href="/tags/算法/" rel="tag">#算法</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/07/跳表-散列2-散列/" rel="next" title="跳表&散列2-散列">
                <i class="fa fa-chevron-left"></i> 跳表&散列2-散列
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/23/优先队列1-堆/" rel="prev" title="优先队列1--堆">
                优先队列1--堆 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/18/二叉树的基本概念和实现/"
           data-title="二叉树的基本概念和实现" data-url="http://ccc013.github.io/2016/08/18/二叉树的基本概念和实现/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.png"
               alt="cai" />
          <p class="site-author-name" itemprop="name">cai</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ccc013" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2181051220?is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/luo-cai" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/lc013?viewmode=contents" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lmj623565791" title="张鸿洋的博客" target="_blank">张鸿洋的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" title="郭霖的博客" target="_blank">郭霖的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/singwhatiwanna/article/category/1405419" title="任玉刚" target="_blank">任玉刚</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/Luoshengyang/" title="罗升阳" target="_blank">罗升阳</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hukai.me/" title="胡凯" target="_blank">胡凯</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.daimajia.com/" title="代码家" target="_blank">代码家</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hujiaweibujidao.github.io/" title="HujiaweiBujidao" target="_blank">HujiaweiBujidao</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/" title="廖雪峰的博客" target="_blank">廖雪峰的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://drakeet.me/" title="Drakeet的个人博客" target="_blank">Drakeet的个人博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.kymjs.com/" title="张涛-开源实验室" target="_blank">张涛-开源实验室</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://gudong.name/" title="咕咚" target="_blank">咕咚</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#u6811"><span class="nav-number">1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4E8C_u53C9_u6811"><span class="nav-number">2.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4E8C_u53C9_u6811_u7684_u7279_u6027"><span class="nav-number">3.</span> <span class="nav-text">二叉树的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4E8C_u53C9_u6811_u63CF_u8FF0"><span class="nav-number">4.</span> <span class="nav-text">二叉树描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#u516C_u5F0F_u5316_u63CF_u8FF0"><span class="nav-number">4.1.</span> <span class="nav-text">公式化描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u94FE_u8868_u63CF_u8FF0"><span class="nav-number">4.2.</span> <span class="nav-text">链表描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4E8C_u53C9_u6811_u904D_u5386"><span class="nav-number">5.</span> <span class="nav-text">二叉树遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u62BD_u8C61_u6570_u636E_u7C7B_u578BBinaryTree"><span class="nav-number">6.</span> <span class="nav-text">抽象数据类型BinaryTree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u7C7BBinaryTree"><span class="nav-number">7.</span> <span class="nav-text">类BinaryTree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u62BD_u8C61_u6570_u636E_u7C7B_u578B_u53CA_u7C7B_u7684_u6269_u5145"><span class="nav-number">8.</span> <span class="nav-text">抽象数据类型及类的扩充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#u8F93_u51FA"><span class="nav-number">8.1.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u5220_u9664"><span class="nav-number">8.2.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8BA1_u7B97_u9AD8_u5EA6"><span class="nav-number">8.3.</span> <span class="nav-text">计算高度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u7EDF_u8BA1_u8282_u70B9_u6570"><span class="nav-number">8.4.</span> <span class="nav-text">统计节点数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5C0F_u7ED3"><span class="nav-number">9.</span> <span class="nav-text">小结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cai</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
  
</div>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cai"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("gmEY36PtfOmueA7roORTu2He-gzGzoHsz", "mzEkjGKehJYxfp1PrU0TYsW3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

</body>
</html>
