<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据结构,算法," />





  <link rel="alternate" href="/atom.xml" title="一个算法汪的日常" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon/icon_code.jpg?v=5.0.1" />






<meta name="description" content="继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。
树
树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。

在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的孩子(children)，而Joe是他们的父母(parent)。有相同">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树的基本概念和实现">
<meta property="og:url" content="http://ccc013.github.io/2016/08/18/二叉树的基本概念和实现/index.html">
<meta property="og:site_name" content="一个算法汪的日常">
<meta property="og:description" content="继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。
树
树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。

在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的孩子(children)，而Joe是他们的父母(parent)。有相同">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%911.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%912.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%913.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%914.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%911.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%912.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%913.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%914.png">
<meta property="og:updated_time" content="2016-10-25T11:52:45.346Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="二叉树的基本概念和实现">
<meta name="twitter:description" content="继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。
树
树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。

在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的孩子(children)，而Joe是他们的父母(parent)。有相同">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>

  <title> 二叉树的基本概念和实现 | 一个算法汪的日常 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div style="display: none;">
    <script src="http://s6.cnzz.com/stat.php?id=1257376919&web_id=1257376919" type="text/javascript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <!-- add Fork me on Github -->
    <a href="https://github.com/ccc013"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"></a>

    <!--add Fork me on Github  -->
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一个算法汪的日常</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Stay hungry, stay foolish</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                二叉树的基本概念和实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-18T15:05:01+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/18/二叉树的基本概念和实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/18/二叉树的基本概念和实现/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/08/18/二叉树的基本概念和实现/" class="leancloud_visitors" data-flag-title="二叉树的基本概念和实现">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>继续是《数据结构算法与应用：C++语言描述》的笔记，这是第八章二叉树和其他树的内容，本节内容介绍树的定义以及二叉树的代码实现。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树t是一个非空的有限元素的集合，其中一个元素为根，余下的元素组成t的子树。</p>
</blockquote>
<p>在画一棵树时，每个元素都代表一个节点。树根在上面，其子树画在下面。如下图所示，其中，Ann，Mary,John是Joe的<strong>孩子(children)</strong>，而Joe是他们的<strong>父母(parent)</strong>。有相同父母的孩子是<strong>兄弟(sibling)</strong>。Ann，Mary,John都是兄弟。此外，还有其他术语：<strong>孙子(grandchild),祖父(grandparent),祖先(ancestor),后代(descendent)等</strong>。树中没有孩子的元素称为<strong>叶子(leaf)</strong>。图中Ann,Mark,Sue和Chris是树的叶子。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>树的另一个常用术语是<strong>级(level)</strong>。指定树根的级是1，其孩子的级是2，依次类推。上图中Joe的级是1，而Ann，Mary,John的级是2，然后Mark,Sue,Chris的级是3。</p>
<p><strong>元素的度是指其孩子的个数。</strong>叶节点的度是0。<strong>树的度是其元素度的最大值</strong>。所以上图中的度是3。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p>定义：二叉树(binary tree)t是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个称为根的元素，余下的元素（如果有的话）被组成2个二叉树，分别称为t的左子树和右子树。</p>
</blockquote>
<p><strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树可以为空，树不能为空</li>
<li>二叉树中每个元素都恰好有两棵子树（其中一个或两个可能为空）。而树中每个元素可以有若干子树。</li>
<li>在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树间是无序的。</li>
</ul>
<p>下图给出了表示数学表达式的二叉树，总共有3个数学表达式。每个操作符可以有一个或两个操作数，左操作数是操作符的左子树，而右操作数则是右子树。树中的叶节点是常量或者变量。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h3 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><blockquote>
<p><strong>特性1： 包含n(n&gt;0)个元素的二叉树边数是n-1。</strong></p>
</blockquote>
<p>证明 二叉树中每个元素 (除了根节点)有且只有一个父节点。在子节点与父节点间有且只有一条边，因此边数为n-1。</p>
<p><strong>二叉树的高度或者深度是指该二叉树的层数。</strong></p>
<blockquote>
<p><strong>特性2： 若二叉树的高度为h,$h \ge 0$,则该二叉树最少有h个元素，最多有$2^h - 1$个元素。</strong></p>
</blockquote>
<p>证明 因为每一层最少要有1个元素，因此元素数最少为h。每元素最多有2个子节点，则第i层节点元素最多为$2^i-1$个,i&gt;0。h=0时，元素的总数为0，也就是$2^0-1$。当h&gt;0时，元素的总数不会超过$\sum_{i=1}^h 2^{i-1}=2^h-1$。</p>
<blockquote>
<p><strong>特性3： 包含n个元素的二叉树的高度最大是n，最小是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
</blockquote>
<p>证明 因为每层至少有一个元素，因此高度不会超过n。由特性2，可以得知高度为h的二叉树最多有$2^h-1$个元素。因为$n \le 2^h-1$,因此$h \ge log_2(n+1)$。由于h是整数，所以$h \ge \left\lceil  log_2(n+1) \right\rceil$。</p>
<p><strong>当高度是h的二叉树恰好有$2^h - 1$个元素时，称其为满二叉树(full binary tree)。</strong>下图就是一个高度为4的满二叉树。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>假设对高度为h的满二叉树中的元素从上到下，从左到右的顺序进行从1到$2^h - 1$进行编号，如上图所示。假设从满二叉树中删除k个元素，其编号为$2^h - i, 1 \le i \le k$,所得到的二叉树称为<strong>完全二叉树(complete binary tree)</strong>。如下图给出的三棵完全二叉树。注意，<strong>满二叉树是完全二叉树的一个特例，并且有n个元素的完全二叉树的深度是$\left\lceil  log_2(n+1) \right\rceil$</strong>。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>在完全二叉树中，一个元素与其孩子的编号有非常好的对应关系。其关系在下面特性4中给出。</p>
<blockquote>
<p><strong>特性4： 设完全二叉树中一元素的序号是i，$1 \le i \le n$。则有以下关系成立：</strong><br>1) 当i=1时，该元素为二叉树的根，若i&gt;1,则该元素父节点的编号是$\left\lfloor i/2 \right\rfloor$。<br>2) 当2i&gt;n时，该元素没有左子树，否则，其左子树的编号是2i。<br>3) 若2i+1&gt;n时，该元素没有右子树，否则，其右子树的编号是2i+1。</p>
</blockquote>
<h3 id="二叉树描述"><a href="#二叉树描述" class="headerlink" title="二叉树描述"></a>二叉树描述</h3><h4 id="公式化描述"><a href="#公式化描述" class="headerlink" title="公式化描述"></a>公式化描述</h4><p>  二叉树的公式化描述利用特性4。二叉树可以作为缺少了部分元素的完全二叉树。下图给出了二叉树的两个例子。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt="此处输入图片的描述"></p>
<p>  在公式化描述方法中，按照二叉树对元素的编号方法，将二叉树的元素存储在数组中。上图同时给出了二叉树的公式化描述，即图中右侧的数组表示。</p>
<p>  当缺少很多元素时，这种描述方法非常浪费空间。实际上，一个有n个元素的二叉树可能最多需要$2^n-1$的空间来存储。当每个节点都是其他节点的右孩子时，存储空间达到最大。如下图所示的一棵有四个元素的二叉树，这种类型的二叉树称为右斜二叉树。当缺少的元素比较少时，这种描述方法很有效。</p>
<p>  <img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="此处输入图片的描述"></p>
<h4 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h4><p>  <strong>二叉树最常用的描述方法是用链表或指针。</strong>每个元素都用一个有两个指针域的节点表示，这两个域是<strong>LeftChild和RightChild</strong>。除此两个指针域外，每个节点还有一个data域。其代码实现如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> BinaryTreeNode&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Visit</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* LeftChild, *RightChild;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTreeNode()&#123;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode(<span class="keyword">const</span> T&amp; e)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        LeftChild = RightChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode(<span class="keyword">const</span> T&amp;e, BinaryTreeNode *l, BinaryTreeNode* r)&#123;</span><br><span class="line">        data = e;</span><br><span class="line">        LeftChild = l;</span><br><span class="line">        RightChild = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的边可以用一个从父节点到子节点的指针来描述。指针放在父节点的指针域中，因为包括n个元素的二叉树恰有n-1条边，所以有<code>2n-(n-1)=n+1</code>个指针域没有值，这些域被值为0。下图给出了公式化描述中第一幅图的二叉树的链表描述。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%913.png" alt="此处输入图片的描述"></p>
<p>二叉树中不设置指向父节点的指针一般不会有什么问题，因为在二叉树的大部分函数中并不需要此指针。</p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>  有四种遍历二叉树的方法：</p>
<ul>
<li><strong>前序遍历</strong></li>
<li><strong>中序遍历</strong></li>
<li><strong>后序遍历</strong></li>
<li><strong>逐层遍历</strong></li>
</ul>
<p>前3种遍历方法将在下面给出代码实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 前序遍历左子树</span></span><br><span class="line">        PreOrder(t-&gt;LeftChild);</span><br><span class="line">        <span class="comment">// 前序遍历右子树</span></span><br><span class="line">        PreOrder(t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        InOrder(t-&gt;LeftChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">        InOrder(t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        PostOrder(t-&gt;LeftChild);</span><br><span class="line">        PostOrder(t-&gt;RightChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三种方法，每个节点的左子树都在其右子树之前遍历。<strong>这三种遍历的区别在于对同一个节点在不同时刻进行访问。</strong>在进行前序遍历时，每个节点是在其左右子树被访问之前进行访问的；在中序遍历时，首先访问左子树，然后访问子树的根节点，最后访问右子树。在后序遍历时，当左右子树均访问完之后才访问子树的根节点。</p>
<p>下图给出上述三种方法对前文给出的数学表达式分别产生的结果，其中<code>Visit(t)</code>由<code>cout&lt;&lt; t-&gt;data;</code>代替。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%914.png" alt="此处输入图片的描述"></p>
<p>当对一棵数学表达式树进行前、中、后序遍历时，便分别得到表达式的前缀、中缀和后缀表达式。中缀（infix）形式就是平时书写的数学表达式。使用中缀形式的时候由于没有括号，可能会产生一些歧义，比如对于<code>x+y*z</code>，可以理解为<code>(x+y)*z</code>或者<code>x+(y*z)</code>，为了避免这种歧义，可以使用完全括号化的中缀表达式，每个操作符和相应的操作数都用一对括号括起来。下面是改进后的中序遍历算法的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Infix</span><span class="params">(BinaryTreeNode&lt;T&gt; *t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 输出完全括号的中缀表达式</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">        <span class="comment">// 左操作数</span></span><br><span class="line">        Infix(t-&gt;LeftChild);</span><br><span class="line">        <span class="comment">// 操作符</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t-&gt;data;</span><br><span class="line">        <span class="comment">// 右操作数</span></span><br><span class="line">        Infix(t-&gt;RightChild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在后缀(postfix)表达式中，每个操作符跟在操作数之后，操作数从左到右的顺序出现；在前缀(prefix)表达式中，操作符位于操作数之前。前缀和后缀表达式都不会存在歧义，不需要采用括号或者优先级。从左到右或者从右到左扫描表达式并采用操作数栈，可以很容易确定操作数和操作符的关系。若在扫描中遇到一个操作数，把它压入堆栈，遇到一个操作符，则将其与栈顶的操作数相匹配，把这些操作数推出栈，由操作符执行相应的计算，并将所得结果作为操作数压入堆栈。</p>
<p>逐层遍历就是<strong>按从顶层到底层的次序访问树中元素，在同一层中，从左到右进行访问。</strong>由于遍历中使用的是一个队列而不是栈，因此写一个按层遍历的递归程序很困难。下列程序是采用队列来实现对二叉树进行逐层遍历，队列中的元素指向二叉树节点，这里使用了之前<a href="http://ccc013.github.io/2016/07/23/%E9%98%9F%E5%88%971-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">队列章节</a>中使用的类<strong>LinkedQueue</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对*t逐层遍历</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt;  Q;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 将t的右孩子放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;LeftChild)</span><br><span class="line">            Q.Add(t-&gt;LeftChild);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;RightChild)</span><br><span class="line">            Q.Add(t-&gt;RightChild);</span><br><span class="line">        <span class="comment">// 访问下一个节点</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Q.Delete(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述程序中，首先仅当树非空时，才进入<code>while</code>循环。首先访问根节点，然后将其子节点加到队列中。当队列添加操作失败时，由Add会引发<code>NoMem</code>异常，由于没有捕捉该异常，所以发生该异常时函数将退出。在添加操作成功后，就进行从队列中删除t元素，如果成功，则删除的元素会返回到t中，这个删除的元素也就是下一个要访问的节点。下次访问该节点的时候，又会将其左右子树加入到队列的尾部，然后下一个要访问的就是根节点的右子树（如果存在），如此就可以实现逐层遍历了。而如果删除失败就表明队列为空，也就是意味着遍历的结束。</p>
<p>假设二叉树中元素的数目是<code>n</code>。这四种遍历算法的空间复杂性均为$O(n)$,时间复杂性是$\theta(n)$。当t的高度是n的时候，通过观察期前序、中序和后序遍历时所使用的递归栈空间可得到上述结论。当t是满二叉树的时候，逐层遍历所需要的队列空间是$\theta(n)$。每个遍历算法花在树中每个节点上的时间是$\theta(1)$(假设访问一个节点的时间是$\theta(1)$)。</p>
<h3 id="抽象数据类型BinaryTree"><a href="#抽象数据类型BinaryTree" class="headerlink" title="抽象数据类型BinaryTree"></a>抽象数据类型BinaryTree</h3><p>  下面给出二叉树的抽象数据类型，这里只列出几个常用的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">抽象数据类型 BinaryTree&#123;</span><br><span class="line">实例</span><br><span class="line">    元素集合；如果不空，则被划分为根节点、左子树和右子树；</span><br><span class="line">    每个子树仍是一个二叉树</span><br><span class="line">操作</span><br><span class="line">    Create()：创建一个空的二叉树；</span><br><span class="line">    IsEmpty：如果二叉树为空，则返回 true ，否则返回false</span><br><span class="line">    Root(x)：取x为根节点；如果操作失败，则返回false，否则返回true</span><br><span class="line">    MakeTree(root,left，right)：创建一个二叉树，root作为根节点，left作为左子树， right作为右子树</span><br><span class="line">    BreakTree(root，left，right)：拆分二叉树</span><br><span class="line">    PreOrder：前序遍历</span><br><span class="line">    InOrder：中序遍历</span><br><span class="line">    PostOrder：后序遍历</span><br><span class="line">    LevelOrder：逐层遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类BinaryTree"><a href="#类BinaryTree" class="headerlink" title="类BinaryTree"></a>类BinaryTree</h3><p>  下面给出类<strong>BinaryTree</strong>的C++定义。函数<strong>Visit</strong>作为遍历函数的参数，以实现不同操作的实现。该定义中使用了链表描述的二叉树。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class BinaryTree&#123;</span><br><span class="line">private:</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *root;    // 根节点指针</span><br><span class="line">    void PreOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">    void Inorder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">    void PostOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t);</span><br><span class="line">public:</span><br><span class="line">    BinaryTree()&#123; root = 0; &#125;</span><br><span class="line">    ~BinaryTree()&#123;&#125;;</span><br><span class="line">    bool IsEmpty() const&#123;</span><br><span class="line">        return ((root) ? false : true);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Root(T&amp; x)const;</span><br><span class="line">    void MakeTree(const T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);</span><br><span class="line">    void BreakTree(const T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right);</span><br><span class="line">    void PreOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        PreOrder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void Inorder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        Inorder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void PostOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u))&#123;</span><br><span class="line">        PostOrder(Visit, root);</span><br><span class="line">    &#125;</span><br><span class="line">    void LevelOrder(void(*Visit)(BinaryTreeNode&lt;T&gt;*u));</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面会给出共享成员函数<code>Root,MakeTree,BreakTree</code>的代码。函数<code>MakeTree</code>和<code>BreakTree</code>要求参与操作的三棵树应该互不相同，否则程序会得出错误的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;T&gt;::Root(T&amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 取根节点的data域，放入x，如果没有则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (root)&#123;</span><br><span class="line">        x = root-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::MakeTree(<span class="keyword">const</span> T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)&#123;</span><br><span class="line">    <span class="comment">// 将left，right和element合并成一棵新树，并且要求left和right及this必须是不同的树。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新树</span></span><br><span class="line">    root = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(element, left.root, right.root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止访问left和right</span></span><br><span class="line">    left.root = right.root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::BreakTree(T&amp; element, BinaryTree&lt;T&gt;&amp; left, BinaryTree&lt;T&gt;&amp; right)&#123;</span><br><span class="line">    <span class="comment">// left,right 和this必须是不同的树</span></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="comment">// 空树</span></span><br><span class="line">        <span class="keyword">throw</span> BadInput();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分解树</span></span><br><span class="line">    element = root-&gt;data;</span><br><span class="line">    left.root = root-&gt;LeftChild;</span><br><span class="line">    right.root = root-&gt;RightChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出四种遍历方法的实现代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        PreOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">        PreOrder(Visit, t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::Inorder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        Inorder(Visit, t-&gt;LeftChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">        Inorder(Visit, t-&gt;RightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PostOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;*u), BinaryTreeNode&lt;T&gt;* t)&#123;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (t)&#123;</span><br><span class="line">        PostOrder(Visit, t-&gt;LeftChild);</span><br><span class="line">        PostOrder(Visit, t-&gt;RightChild);</span><br><span class="line">        Visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::LevelOrder(<span class="keyword">void</span>(*Visit)(BinaryTreeNode&lt;T&gt;* u))&#123;</span><br><span class="line">    <span class="comment">// 逐层遍历</span></span><br><span class="line">    LinkedQueue&lt;BinaryTreeNode&lt;T&gt;*&gt;Q;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *t;</span><br><span class="line">    t = root;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        Visit(t);</span><br><span class="line">        <span class="comment">// 将t的右孩子放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;LeftChild)</span><br><span class="line">            Q.Add(t-&gt;LeftChild);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;RightChild)</span><br><span class="line">            Q.Add(t-&gt;RightChild);</span><br><span class="line">        <span class="comment">// 访问下一个节点</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Q.Delete(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OutOfBounds)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是对类BinaryTree的简单应用，程序中构造了一个四节点的二叉树，并进行了前序遍历以确定书中的节点数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"xcept.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"BinaryTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">BinaryTree&lt;<span class="keyword">int</span>&gt;a, x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ct</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    y.MakeTree(<span class="number">1</span>, a, a);</span><br><span class="line">    z.MakeTree(<span class="number">2</span>, a, a);</span><br><span class="line">    x.MakeTree(<span class="number">3</span>, y, z);</span><br><span class="line">    y.MakeTree(<span class="number">4</span>, x, a);</span><br><span class="line">    y.PreOrder(ct);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Tree y has "</span>&lt;&lt; count &lt;&lt;<span class="string">" nodes"</span>&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象数据类型及类的扩充"><a href="#抽象数据类型及类的扩充" class="headerlink" title="抽象数据类型及类的扩充"></a>抽象数据类型及类的扩充</h3><p>  本节将扩充之前给出的抽象数据类型，增加如下二叉树操作：</p>
<ul>
<li><strong>PreOutput():</strong>按前序方式输出数据域</li>
<li><strong>InOutput():</strong>按中序方式输出数据域</li>
<li><strong>PostOutput():</strong>按后序方式输出数据域</li>
<li><strong>LevelOutput():</strong>逐层输出数据域</li>
<li><strong>Delete():</strong>删除一棵二叉树，释放其节点</li>
<li><strong>Height():</strong>返回树的高度</li>
<li><strong>Size():</strong>返回树中节点数</li>
</ul>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>  四个输出函数可以通过定义一个私有静态成员函数Output来实现，该函数代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Output</span><span class="params">(BinaryTreeNode&lt;T&gt;*t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而四个共享输出函数的形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PreOrder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Inorder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PostOrder(Output, root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOutput</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LevelOrder(Output);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Visit操作的时间复杂性是$\theta(1)$,对包括n个节点的二叉树来说，每种遍历方法所花费的时间是$\theta(n)$(遍历成功的话），因此每种输出方法的时间复杂性均为$\theta(n)$。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>  要删除一棵二叉树，需要删除其所有节点，可以通过<strong>后序遍历</strong>在访问一个节点时，将其删除，也就是先删除左子树，然后右子树，最后删除根。因此函数<strong>Delete</strong>的形式如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PostOrder(Free, root);</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Free</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中函数<strong>Free</strong>是一个私有成员函数。要删除的二叉树有n个节点时，<strong>Delete</strong>函数的时间复杂性是$\theta(n)$。</p>
<h4 id="计算高度"><a href="#计算高度" class="headerlink" title="计算高度"></a>计算高度</h4><p>  <strong>通过进行后序遍历，可以得到二叉树的高度。</strong>首先得到左子树的高度hl，然后得到右子树的高度hr，则树的高度为<strong>max{hl,hr}+1</strong>。</p>
<p>  但是这里不能使用之前定义的后序遍历代码，因为在进行遍历的时候需要有返回值（也就是子树的高度）。所以首先需要在增加一个共享成员函数Height,其代码为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Height(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后增加一个私有成员函数<strong>Height</strong>，其实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> BinaryTree&lt;T&gt;::Height(BinaryTreeNode&lt;T&gt; *t)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 返回树*t的高度</span></span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左子树高度</span></span><br><span class="line">    <span class="keyword">int</span> hl = Height(t-&gt;LeftChild);</span><br><span class="line">    <span class="comment">// 右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> hr = Height(t-&gt;RightChild);</span><br><span class="line">    <span class="keyword">if</span> (hl &gt; hr)</span><br><span class="line">        <span class="keyword">return</span> ++hl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ++hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述函数的时间复杂性是$\theta(n)$。</p>
<h4 id="统计节点数"><a href="#统计节点数" class="headerlink" title="统计节点数"></a>统计节点数</h4><p>  可以用上述四种遍历方法中的任何一种来获取二叉树中的节点数，因为每种遍历方法都对每个节点仅访问一次，只要在访问每个节点的时候将一个全局计数器加1即可。所以首先在类<strong>BinaryTree</strong>定义外定义一个全局变量：<code>int _count;</code>,然后增加一个共享成员函数<strong>Size</strong>和私有成员函数<strong>Add1</strong>，其代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add1</span><span class="params">(BinaryTreeNode&lt;T&gt;* t)</span></span>&#123;</span><br><span class="line">    _count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _count = <span class="number">0</span>;</span><br><span class="line">    PreOrder(Add1, root);</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<strong>Size</strong>的时间复杂性是$\theta(n)$。</p>
<p>对于类<strong>BinaryTree</strong>的定义以及测试例子可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/BinaryTree" target="_blank" rel="external">二叉树</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本节内容主要是介绍了树的基本概念以及二叉树的定义、特性和实现代码，包括四种遍历树的方法。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag">#数据结构</a>
          
            <a href="/tags/算法/" rel="tag">#算法</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/07/跳表-散列2-散列/" rel="next" title="跳表&散列2-散列">
                <i class="fa fa-chevron-left"></i> 跳表&散列2-散列
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/23/优先队列1-堆/" rel="prev" title="优先队列1--堆">
                优先队列1--堆 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zOTcyOC8xNjI1NQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.png"
               alt="cai" />
          <p class="site-author-name" itemprop="name">cai</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">34</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ccc013" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2181051220?is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/luo-cai" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/lc013?viewmode=contents" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lmj623565791" title="张鸿洋的博客" target="_blank">张鸿洋的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" title="郭霖的博客" target="_blank">郭霖的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/singwhatiwanna/article/category/1405419" title="任玉刚" target="_blank">任玉刚</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/Luoshengyang/" title="罗升阳" target="_blank">罗升阳</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hukai.me/" title="胡凯" target="_blank">胡凯</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.daimajia.com/" title="代码家" target="_blank">代码家</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hujiaweibujidao.github.io/" title="HujiaweiBujidao" target="_blank">HujiaweiBujidao</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/" title="廖雪峰的博客" target="_blank">廖雪峰的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://drakeet.me/" title="Drakeet的个人博客" target="_blank">Drakeet的个人博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.kymjs.com/" title="张涛-开源实验室" target="_blank">张涛-开源实验室</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://gudong.name/" title="咕咚" target="_blank">咕咚</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number">1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">2.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的特性"><span class="nav-number">3.</span> <span class="nav-text">二叉树的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树描述"><span class="nav-number">4.</span> <span class="nav-text">二叉树描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公式化描述"><span class="nav-number">4.1.</span> <span class="nav-text">公式化描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表描述"><span class="nav-number">4.2.</span> <span class="nav-text">链表描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树遍历"><span class="nav-number">5.</span> <span class="nav-text">二叉树遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象数据类型BinaryTree"><span class="nav-number">6.</span> <span class="nav-text">抽象数据类型BinaryTree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类BinaryTree"><span class="nav-number">7.</span> <span class="nav-text">类BinaryTree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象数据类型及类的扩充"><span class="nav-number">8.</span> <span class="nav-text">抽象数据类型及类的扩充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输出"><span class="nav-number">8.1.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除"><span class="nav-number">8.2.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算高度"><span class="nav-number">8.3.</span> <span class="nav-text">计算高度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#统计节点数"><span class="nav-number">8.4.</span> <span class="nav-text">统计节点数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">9.</span> <span class="nav-text">小结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cai</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
  
</div>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  
  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>




  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("gmEY36PtfOmueA7roORTu2He-gzGzoHsz", "mzEkjGKehJYxfp1PrU0TYsW3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

</body>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</html>
