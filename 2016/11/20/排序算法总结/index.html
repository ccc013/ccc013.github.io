<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据结构,算法," />





  <link rel="alternate" href="/atom.xml" title="一个算法汪的日常" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon/icon_code.jpg?v=5.0.1" />






<meta name="description" content="这是《大话数据结构》第九章排序算法的知识点总结。
排序的基本概念与分类
假设含有n个记录的序列为${r_1,r_2,\cdots,r_n}$，其相应的关键字分别为${k_1,k_2,\cdots,k_n}$，需要确定$1,2, \cdots, n$的一种排列$p_1,p_2,\cdots,p_n$，使其相应的关键字满足$k_{p1}\le k_{p2}\le \cdots \le k_{pn}$非">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法总结">
<meta property="og:url" content="http://ccc013.github.io/2016/11/20/排序算法总结/index.html">
<meta property="og:site_name" content="一个算法汪的日常">
<meta property="og:description" content="这是《大话数据结构》第九章排序算法的知识点总结。
排序的基本概念与分类
假设含有n个记录的序列为${r_1,r_2,\cdots,r_n}$，其相应的关键字分别为${k_1,k_2,\cdots,k_n}$，需要确定$1,2, \cdots, n$的一种排列$p_1,p_2,\cdots,p_n$，使其相应的关键字满足$k_{p1}\le k_{p2}\le \cdots \le k_{pn}$非">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png">
<meta property="og:image" content="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%954.png">
<meta property="og:updated_time" content="2016-12-08T03:18:55.965Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法总结">
<meta name="twitter:description" content="这是《大话数据结构》第九章排序算法的知识点总结。
排序的基本概念与分类
假设含有n个记录的序列为${r_1,r_2,\cdots,r_n}$，其相应的关键字分别为${k_1,k_2,\cdots,k_n}$，需要确定$1,2, \cdots, n$的一种排列$p_1,p_2,\cdots,p_n$，使其相应的关键字满足$k_{p1}\le k_{p2}\le \cdots \le k_{pn}$非">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>

  <title> 排序算法总结 | 一个算法汪的日常 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div style="display: none;">
    <script src="http://s6.cnzz.com/stat.php?id=1257376919&web_id=1257376919" type="text/javascript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <!-- add Fork me on Github -->
    <a href="https://github.com/ccc013"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"></a>

    <!--add Fork me on Github  -->
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一个算法汪的日常</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Stay hungry, stay foolish</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                排序算法总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-20T13:27:44+08:00" content="2016-11-20">
              2016-11-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/20/排序算法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/20/排序算法总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/20/排序算法总结/" class="leancloud_visitors" data-flag-title="排序算法总结">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这是《大话数据结构》第九章排序算法的知识点总结。</p>
<h4 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h4><blockquote>
<p>假设含有n个记录的序列为${r_1,r_2,\cdots,r_n}$，其相应的关键字分别为${k_1,k_2,\cdots,k_n}$，需要确定$1,2, \cdots, n$的一种排列$p_1,p_2,\cdots,p_n$，使其相应的关键字满足$k_{p1}\le k_{p2}\le \cdots \le k_{pn}$非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列${r_{p1}, r_{p2}, \cdots, r_{pn}}$，这样的操作就称为排序。</p>
</blockquote>
<p><strong>在排序问题中，通常将数据元素称为记录。</strong></p>
<p>排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p>
<p>这里关键字$k_i$可以是记录$r$的主关键字，也可以是次关键字，甚至是若干数据项的组合。</p>
<h5 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h5><p>由于排序不仅是针对主关键字，还有针对次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，下面给出稳定与不稳定排序的定义。</p>
<blockquote>
<p>假设$k_i = k_j \ (1\le i \le n, 1\le j\le n, i\neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i \lt j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先于$r_i$，则称所用的排序方法是不稳定的。</p>
</blockquote>
<p>不稳定的排序算法有：<strong>希尔、快速、堆排和选择排序</strong>。</p>
<h5 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h5><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序可以分为：内排序和外排序。</p>
<blockquote>
<p>内排序是在排序整个过程中，<strong>待排序的所有记录全部被放置在内存中</strong>。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要<strong>在内外存之间多次交换数据才能进行</strong>。</p>
</blockquote>
<p>对于内排序来说，排序算法的性能主要是受到3个方面的影响：</p>
<h6 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h6><p>在内排序中，主要进行两种操作：<strong>比较和移动</strong>。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</p>
<h6 id="辅助空间"><a href="#辅助空间" class="headerlink" title="辅助空间"></a>辅助空间</h6><p>辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</p>
<h6 id="算法的复杂性"><a href="#算法的复杂性" class="headerlink" title="算法的复杂性"></a>算法的复杂性</h6><p>这里指的是算法本身的复杂度，而不是算法的时间复杂度。</p>
<p>根据排序过程中借助的主要操作，我们把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序。</strong></p>
<h5 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h5><p>这里先提供一个用于排序用的顺序表结构，这个结构将用于接下来介绍的所有排序算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">10</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 用于存储待排序数组</span></span><br><span class="line">  <span class="keyword">int</span> r[MAXSIZE]; </span><br><span class="line">  <span class="comment">// 用于记录顺序表的长度</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>此外，由于排序最常用到的操作是数组两元素的交换，这里写成一个函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换L中数组r的下标为i和j的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = L-&gt;r[i];</span><br><span class="line">  L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">  L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p><strong>冒泡排序(Bubble sort)是一种交换排序。</strong>它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。</p>
</blockquote>
<p>首先介绍一个简单版本的冒泡排序算法的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序初级版</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort0</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不算是标准的冒泡排序算法，因为不满足“两两比较相邻记录”的冒泡排序思想，它更应该是最简单的交换排序。它的思路是让每一个关键字都和后面的每一个关键字比较，如果大或小则进行交换，这样关键字在一次循环后，第一个位置的关键字会变成最大值或者最小值。</p>
<p>这个最简单的实现算法效率是非常低的。</p>
<p>下面介绍正宗的冒泡排序算法实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正宗的冒泡排序算法实现代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = L-&gt;length - <span class="number">2</span>; j &gt;= i; j--)&#123;</span><br><span class="line">			<span class="comment">// j是从后往前循环</span></span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里改变的地方是在内循环中，<code>j</code>是从数组最后往前进行比较，并且是逐个往前进行相邻记录的比较，这样最大值或者最小值会在第一次循环过后，从后面浮现到第一个位置，如同气泡一样浮到上面。</p>
<p>这段实现代码其实还是可以进行优化的，例如待排序数组是<code>{2,1,3,4,5,6,7,8,9}</code>,需要进行递增排序，可以发现其实只需要交换前两个元素的位置即可完成，但是上述算法还是会在交换完这两者位置后继续进行循环，这样效率就不高了，所以可以在算法中增加一个标志，当有一次循环中没有进行数据交换，就证明数组已经是完成排序的，此时就可以退出算法，实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进版冒泡算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSortOptimz</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length &amp;&amp; flag; i++)&#123;</span><br><span class="line">		<span class="comment">// 若 flag为false则退出循环</span></span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = L-&gt;length - <span class="number">2</span>; j &gt;= i; j--)&#123;</span><br><span class="line">			<span class="comment">// j是从后往前循环</span></span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="comment">// 实现递增排序</span></span><br><span class="line">				swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 如果有数据交换，则flag是true</span></span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法的时间复杂度是$O(n^2)$。</p>
<p>完整的冒泡排序算法代码可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/SortAlgorithms/BubbleSortTest.cpp" target="_blank" rel="external">BubbleSort</a>。</p>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><blockquote>
<p>简单选择排序算法(Simple Selection Sort)就是通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字中最小的记录，并和第$i(1\le i \le n)$个记录进行交换。</p>
</blockquote>
<p>下面是实现的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单选择排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, min;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">		min = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[j] &lt; L-&gt;r[min])</span><br><span class="line">				min = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若min不等于i，说明找到最小值，进行交换</span></span><br><span class="line">		<span class="keyword">if</span> (min != i)</span><br><span class="line">			swap(L, i, min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单选择排序的最大特点就是交换移动数据次数相当少。分析其时间复杂度发现，无论最好最差的情况，比较次数都是一样的，都需要比较$\sum_{i=1}^{n-1} (n-i) = (n-1)+(n-2)+\cdots+2+1=\frac{n(n-1)}{2}$次。对于交换次数，最好的时候是交换0次，而最差的情况是$n-1$次。因此，总的时间复杂度是$O(n^2)$，虽然与冒泡排序一样的时间复杂度，但是其性能上还是略好于冒泡排序。</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><blockquote>
<p>直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增加1的有序表。</p>
</blockquote>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j,val;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="comment">// 将L-&gt;r[i]插入有序表中,使用val保存待插入的数组元素L-&gt;r[i]</span></span><br><span class="line">			val = L-&gt;r[i];</span><br><span class="line">			<span class="keyword">for</span> (j = i - <span class="number">1</span>; L-&gt;r[j]&gt;val; j--)</span><br><span class="line">				<span class="comment">// 记录后移</span></span><br><span class="line">				L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[j];	</span><br><span class="line">			<span class="comment">// 插入到正确位置</span></span><br><span class="line">			L-&gt;r[j + <span class="number">1</span>] =val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接插入排序算法是需要有一个保存待插入数值的辅助空间。</p>
<p>在时间复杂度方面，最好的情况是待排序的表本身就是有序的，如{2,3,4,5,6}，比较次数则是$n-1$次，然后不需要进行移动，时间复杂度是$O(n)$。</p>
<p>最差的情况就是待排序表是逆序的情况，如{6,5,4,3,2},此时需要比较$\sum_{i=2}^{n} i = \frac{(n+2)(n-1)}{2}$次，而记录的移动次数也达到最大值$\sum_{i=2}^{n} (i+1) = \frac{(n+4)(n-1)}{2}$次。</p>
<p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为$\frac{n^2}{4}$。因此，可以得出直接插入排序算法的时间复杂度是$O(n^2)$。同时也可以看出，直接插入排序算法会比冒泡排序和简单选择排序算法的性能要更好一些。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>上述三种排序算法的时间复杂度都是$O(n^2)$，而希尔排序是突破这个时间复杂度的第一批算法之一。</p>
<p>其实直接插入排序的效率在某些情况下是非常高效的，这些情况是指记录本来就很少或者待排序的表基本有序的情况，但是这两种情况都是特殊情况，在现实中比较少见。而希尔排序就是通过创造条件来改进直接插入排序的算法。</p>
<p>希尔排序的做法是<strong>将原本有大量记录数的记录进行分组，分割成若干个序列</strong>，这样每个子序列待排序的记录就比较少了，然后就可以对子序列分别进行直接插入排序，<strong>当整个序列基本有序时，再对全体记录进行一次直接插入排序。</strong></p>
<p>这里的<strong>基本有序是指小的关键字基本在前面，大的基本在后面，不大不小的在中间。</strong>像{2,1,3,6,4,7,5,8,9}可以称为基本有序。</p>
<p>这里的关键就是如何进行分割，希尔排序采取的是<strong>跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</strong></p>
<p>实现的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j,val;</span><br><span class="line">	<span class="keyword">int</span> increment = L-&gt;length;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="comment">// 增量序列</span></span><br><span class="line">		increment = increment / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = increment; i &lt;= L-&gt;length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i - increment])&#123;</span><br><span class="line">				<span class="comment">// 将L-&gt;r[i]插入有序表中,使用val保存待插入的数组元素L-&gt;r[i]</span></span><br><span class="line">				val = L-&gt;r[i];</span><br><span class="line">				<span class="keyword">for</span> (j = i - increment; j &gt;= <span class="number">0</span> &amp;&amp; L-&gt;r[j]&gt;val; j -= increment)</span><br><span class="line">					<span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">					L-&gt;r[j + increment] = L-&gt;r[j];</span><br><span class="line">				L-&gt;r[j + increment] = val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中增量的选取是<code>increment = increment / 3 + 1</code>，实际上增量的选取是非常关键的，现在还没有人找到一种最好的增量序列，但是大量研究表明，当增量序列是$\delta [k] = 2^{t-k+1} - 1 (0\le k \le t \le \lfloor log_2(n+1)\rfloor)$时，可以获得不错的效率，其时间复杂度是$O(n^{\frac{3}{2}})$，要好于直接插入排序的$O(n^2)$。当然，这里需要注意的是<strong>增量序列的最后一个增量值必须等于1才行</strong>。此外，由于记录是跳跃式的移动，<strong>希尔排序是不稳定的排序算法</strong>。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>有一个数量为Size个数的数组A，数组的值范围为(0 - Max)，然后创建一个大小为<code>Max+1</code>的数组B，每个元素都为0.从头遍历A，当读取到A[i]的时候，B[A[i]]的值+1，这样所有的A数组被遍历后，直接扫描B之后，输出表B就可以了。然后再根据B来对A进行排序。</p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得未排序数组中最大的一个元素值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxVal</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxVal = arr[<span class="number">0</span>]; <span class="comment">//假设最大为arr[0]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)  <span class="comment">//遍历比较，找到大的就赋值给maxVal</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; maxVal)</span><br><span class="line">			maxVal = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxVal;  <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong input!"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> size = GetMaxVal(numbers,length) + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(size);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length + <span class="number">1</span>; i++)&#123;</span><br><span class="line">		bucket[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算数组中每个元素出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = numbers[i];</span><br><span class="line">		bucket[j] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (bucket[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++)&#123;</span><br><span class="line">				numbers[count] = i;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>简单选择排序在待排序的$n$个记录中选择一个最小的记录需要比较$n-1$次，这是查找第一个数据，所以需要比较这么多次是比较正常的，但是可惜的是它没有把每一趟的比较结果保存下来，这导致在后面的比较中，实际有许多比较在前一趟中已经做过了。因此，如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就会变得很高了。</p>
<p>堆排序(Heap Sort)就是对简单选择排序进行的一种改进，并且效果非常明显。</p>
<blockquote>
<p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为最大堆或者大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为最小堆或者小顶堆。</p>
</blockquote>
<p>下图是一个例子，左边的是大顶堆，而右边的是小顶堆。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png" alt=""></p>
<p>而根据堆的定义，可以知道根结点一定是堆中所有结点最大或者最小者。如果按照层遍历的方式给结点从1开始编号，则结点之间满足下列关系：</p>
<script type="math/tex; mode=display">
\begin{cases}
k_i \ge k_{2i} \\\
k_i \ge k_{2i+1}
\end{cases}
或 
\begin{cases}
k_i \le k_{2i} \\\
k_i \le k_{2i+1}
\end{cases}
1 \le i \le \lfloor \frac{n}{2} \rfloor</script><p>如果将上图按照层遍历存入数组，则一定满足上述关系表达，得到的数组如下图所示。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png" alt=""></p>
<blockquote>
<p>堆排序的基本思想是，将待排序的序列构成一个最大堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素进行交换，此时末尾元素就是最大值），然后将剩余的$n-1$个序列重新构成一个堆，这样就会得到$n$个元素中的次最大值。如此反复执行，便能得到一个有序序列。</p>
</blockquote>
<p>下面将给出堆排序算法的代码实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知L-&gt;r[s...m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义</span></span><br><span class="line"><span class="comment">// 本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp, j;</span><br><span class="line">	temp = L-&gt;r[s];</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m - <span class="number">1</span>; j *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="comment">// 沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">		<span class="keyword">if</span> (j &lt; m-<span class="number">1</span> &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">			<span class="comment">// j是关键字中较大的记录的下标</span></span><br><span class="line">			++j;</span><br><span class="line">		<span class="keyword">if</span> (temp &gt;= L-&gt;r[j])</span><br><span class="line">			<span class="comment">// 当前值不需要进行调整</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		L-&gt;r[s] = L-&gt;r[j];</span><br><span class="line">		s = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 插入</span></span><br><span class="line">	L-&gt;r[s] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = L-&gt;length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 将待排序的序列构成一个最大堆</span></span><br><span class="line">		HeapAdjust(L, i, L-&gt;length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始进行排序</span></span><br><span class="line">	<span class="keyword">for</span> (i = L-&gt;length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 将堆顶记录与当前未经排序的子序列的最后一个记录交换</span></span><br><span class="line">		swap(L, <span class="number">0</span>, i);</span><br><span class="line">		<span class="comment">// 重新调整为最大堆</span></span><br><span class="line">		HeapAdjust(L, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，堆排序分两步走，首先是将待排序的序列构造成最大堆，这也是<code>HeapSort()</code>中第一个循环所做的事情，第二个循环也就是第二步，进行堆排序，逐步将每个最大值的根结点和末尾元素进行交换，然后再调整成最大堆，重复执行。</p>
<p>而在第一步中构造最大堆的过程中，是从$\lfloor \frac{n}{2} \rfloor$的位置开始进行构造，这是从下往上、从右到左，将每个非叶结点当作根结点，将其和其子树调整成最大堆。</p>
<p>接下来就是分享堆排序的效率了。堆排序的运行时间主要是消耗在初始构造堆和在重建堆时的反复筛选上。</p>
<p>在构建堆的过程中，因为是从完全二叉树的最下层最右边的非叶结点开始构建，将它与其孩子进行比较和若有必要的交换，对每个非叶结点，最多进行两次比较和互换操作，这里需要进行这种操作的非叶结点数目是$\lfloor \frac{n}{2} \rfloor$个，所以整个构建堆的时间复杂度是$O(n)$。</p>
<p>在正式排序的时候，第$i$取堆顶记录重建堆需要用$O(log i)$的时间(完全二叉树的某个结点到根结点的距离是$\lfloor log_2i \rfloor + 1$)，并且需要取$n-1$次堆顶记录，因此，重建堆的时间复杂度是$O(nlogn)$。</p>
<p><strong>所以，总体上来说，堆排序的时间复杂度是$O(nlogn)$。</strong>由于堆排序对原始记录的排序状态并不敏感，因此它无论最好、最坏和平均时间复杂度都是$O(nlogn)$。同样由于记录的比较与交换是跳跃式进行，<strong>堆排序也不是稳定的排序算法。</strong></p>
<p>另外，由于初始构建堆需要的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>归并排序(Merging Sort)就是利用归并的思想实现的排序方法，它的原理是假设初始序列有$n$个记录，则可以看成是$n$个有序的子序列，每个子序列的长度为1，然后两两合并，得到$\lceil \frac{n}{2} \rceil$($\lceil x \rceil$表示不小于$x$的最小整数)个长度为2或1的有序子序列；再两两合并，$\cdots \cdots$，如此重复，直至得到一个长度为$n$的有序序列为止，这种排序方法称为2路归并排序。</p>
</blockquote>
<p>下面是介绍实现的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序,使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	MSort(L-&gt;r, L -&gt;r, <span class="number">0</span>, L-&gt;length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将SR[s..t]归并排序为TR1[s..t]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR1[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> TR2[MAXSIZE];</span><br><span class="line">	<span class="keyword">if</span> (s == t)</span><br><span class="line">		TR1[s] = SR[s];</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 将SR[s..t]平分为SR[s...m-1]和SR[m...t]</span></span><br><span class="line">		m = (s + t) / <span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		MSort(SR, TR2, s, m-<span class="number">1</span>);</span><br><span class="line">		MSort(SR, TR2, m, t);</span><br><span class="line">		<span class="comment">// 将TR2[s..m-1]和TR2[m..t]归并到TR1[s..t]</span></span><br><span class="line">		Merge(TR2, TR1, s, m-<span class="number">1</span>, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, k, l;</span><br><span class="line">	<span class="keyword">for</span> (j = m+<span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;</span><br><span class="line">		<span class="comment">// 将SR中记录由小到大并入TR</span></span><br><span class="line">		<span class="keyword">if</span> (SR[i] &lt; SR[j])</span><br><span class="line">			TR[k] = SR[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			TR[k] = SR[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= m)&#123;</span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= m - i; l++)</span><br><span class="line">			<span class="comment">// 将剩余的SR[i..m]复制到TR</span></span><br><span class="line">			TR[k + l] = SR[i + l];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &lt;= n)&#123;</span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">			<span class="comment">// 将剩余的SR[j..n-1]复制到TR</span></span><br><span class="line">			TR[k + l] = SR[j + l];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是一个递归版本的归并排序实现算法，其中函数<code>MSort()</code>的作用是将待排序序列进行分割，然后<code>Merge()</code>函数会对需要归并的序列进行排序并两两归并在一起。</p>
<p><strong>归并排序的时间复杂度是$O(nlogn)$，并且无论是最好、最坏还是平均都是同样的时间性能。</strong>另外，在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，并且递归时需要深度为$log_2 n$的栈空间，因此空间复杂度是$O(n+logn)$。</p>
<p>另外，归并排序是使用两两比较，不存在跳跃，这在<code>Merge()</code>中的语句<code>if(SR[i]&lt;SR[j])</code>可以看出，<strong>所以归并排序是一个稳定的排序算法。</strong></p>
<p><strong>总体来说，归并排序是一个比较占用内存，但效率高且稳定的算法。</strong></p>
<p>下面会介绍一个非递归版本的归并排序算法实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 非递归版本的归并排序</span><br><span class="line">void MergeSort2(SqList *L)&#123;</span><br><span class="line">	// 申请额外空间</span><br><span class="line">	int* TR = (int *)malloc(L-&gt;length * sizeof(int));</span><br><span class="line">	int k = 1;</span><br><span class="line">	while (k &lt; L-&gt;length)&#123;</span><br><span class="line">		MergePass(L-&gt;r, TR, k, L-&gt;length);</span><br><span class="line">		// 子序列长度加倍</span><br><span class="line">		k = 2 * k;</span><br><span class="line">		MergePass(TR, L-&gt;r, k, L-&gt;length);</span><br><span class="line">		k = 2 * k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将SR[]中相邻长度为s的子序列两两归并到TR[]</span><br><span class="line">void MergePass(int SR[], int TR[], int s, int n)&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j;</span><br><span class="line">	while (i &lt;= n - 2 * s)&#123;</span><br><span class="line">		// 两两归并</span><br><span class="line">		Merge(SR, TR, i, i + s - 1, i + 2 * s - 1);</span><br><span class="line">		i = i + 2 * s;</span><br><span class="line">	&#125;</span><br><span class="line">	if (i &lt; n - s + 1)</span><br><span class="line">		// 归并最后两个子序列</span><br><span class="line">		Merge(SR, TR, i, i + s - 1, n - 1);</span><br><span class="line">	else&#123;</span><br><span class="line">		// 若最后剩下单个子序列</span><br><span class="line">		for (j = i; j &lt;= n - 1; j++)</span><br><span class="line">			TR[j] = SR[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]</span><br><span class="line">void Merge(int SR[], int TR[], int i, int m, int n)&#123;</span><br><span class="line">	int j, k, l;</span><br><span class="line">	for (j = m+1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)&#123;</span><br><span class="line">		// 将SR中记录由小到大并入TR</span><br><span class="line">		if (SR[i] &lt; SR[j])</span><br><span class="line">			TR[k] = SR[i++];</span><br><span class="line">		else</span><br><span class="line">			TR[k] = SR[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	if (i &lt;= m)&#123;</span><br><span class="line">		for (l = 0; l &lt;= m - i; l++)</span><br><span class="line">			// 将剩余的SR[i..m]复制到TR</span><br><span class="line">			TR[k + l] = SR[i + l];</span><br><span class="line">	&#125;</span><br><span class="line">	if (j &lt;= n)&#123;</span><br><span class="line">		for (l = 0; l &lt;= n - j; l++)</span><br><span class="line">			// 将剩余的SR[j..n-1]复制到TR</span><br><span class="line">			TR[k + l] = SR[j + l];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归版本的归并排序算法避免了递归时深度为$log_2 n$的栈空间，空间复杂度是$O(n)$，并且避免递归也在时间性能上有一定的提升。应该说，使用归并排序时，尽量考虑用非递归方法。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>在前面介绍的几种排序算法，希尔排序相当于直接插入排序的升级，它们属于插入排序类，而堆排序相当于简单选择排序的升级，它们是属于选择排序类，而接下来介绍的快速排序就是冒泡排序的升级，它们属于交换排序类。</p>
<blockquote>
<p>快速排序(Quick Sort)的基本思想是：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
</blockquote>
<p>下面给出实现的快速排序算法代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">	QSort(L, <span class="number">0</span>, L-&gt;length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">		<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">		pivot = Partition(L, low, high);</span><br><span class="line">		<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">		QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 对高子序列递归排序</span></span><br><span class="line">		QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换待排序序列L中子表的记录，使枢轴记录到位，并返回其所在位置</span></span><br><span class="line"><span class="comment">// 并使得其之前位置的值小于它，后面位置的值大于它</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot_key;</span><br><span class="line">	<span class="comment">// 初始值设置为子表的第一个记录</span></span><br><span class="line">	pivot_key = L-&gt;r[low];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivot_key)</span><br><span class="line">			high--;</span><br><span class="line">		<span class="comment">// 将小于枢轴记录的值交换到低端</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivot_key)</span><br><span class="line">			low++;</span><br><span class="line">		<span class="comment">// 将大于枢轴记录的值交换到高端</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码同样是使用了递归，其中<code>Partition()</code>函数要做的就是先选取待排序序列中的一个关键字，然后将其放在一个位置，这个位置左边的值小于它，右边的值都大于它，这样的值被称为枢轴。</p>
<p>快速排序的时间性能取决于快速排序递归的深度。在最优情况下，<code>Partition()</code>每次都划分得很均匀，如果排序$n$个关键字，其递归树的深度技术$\lfloor log_ n \rfloor +1$，即需要递归$log_2n$次，其时间复杂度是$O(nlogn)$。而最坏的情况下，待排序的序列是正序或逆序，得到的递归树是斜树，最终其时间复杂度是$O(n^2)$。</p>
<p><strong>平均情况可以得到时间复杂度是$O(nlogn)$，而空间复杂度的平均情况是$O(logn)$。但是由于关键字的比较和交换是跳跃进行的，所以快速排序也是不稳定排序。</strong></p>
<h5 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h5><p>快速排序算法是有许多地方可以优化的，下面给出一些优化的方案。</p>
<h6 id="优化选取枢轴"><a href="#优化选取枢轴" class="headerlink" title="优化选取枢轴"></a>优化选取枢轴</h6><p>枢轴的值太大或者太小都会影响快速排序的性能，一个改进方法是<strong>三数取中</strong>法，即<strong>取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数</strong>。</p>
<p>需要在<code>Partition()</code>函数中做出下列修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pivot_key;</span><br><span class="line">	<span class="comment">// 使用三数取中法选取枢轴</span></span><br><span class="line">	<span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[low] &gt; L-&gt;r[high])</span><br><span class="line">		<span class="comment">// 保证左端最小</span></span><br><span class="line">		swap(L, low, high);</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m] &gt; L-&gt;r[high])</span><br><span class="line">		<span class="comment">// 保证中间较小</span></span><br><span class="line">		swap(L, high, m);</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;r[m] &gt; L-&gt;r[low])</span><br><span class="line">		<span class="comment">// 保证左端较小</span></span><br><span class="line">		swap(L, m, low);</span><br><span class="line"></span><br><span class="line">	pivot_key = L-&gt;r[low];</span><br></pre></td></tr></table></figure>
<p>三数取中对小数组有很大的概率取到一个比较好的枢轴值，但是对于非常大的待排序的序列还是不足以保证得到一个比较好的枢轴值，因此还有一个办法是<strong>九数取中法</strong>，它先从数组中分三次取样，每次去三个数，三个样品各自取出中数，然后从这三个中数当中再取出一个中数作为枢轴。</p>
<h6 id="优化不必要的交换"><a href="#优化不必要的交换" class="headerlink" title="优化不必要的交换"></a>优化不必要的交换</h6><p>优化后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pivot_key = L-&gt;r[low];</span><br><span class="line"><span class="keyword">int</span> temp = pivot_key;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivot_key)</span><br><span class="line">		high--;</span><br><span class="line">	<span class="comment">// 将小于枢轴记录的值交换到低端</span></span><br><span class="line">	<span class="comment">// swap(L, low, high);</span></span><br><span class="line">	<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">	L-&gt;r[low] = L-&gt;r[high];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivot_key)</span><br><span class="line">		low++;</span><br><span class="line">	<span class="comment">// 将大于枢轴记录的值交换到高端</span></span><br><span class="line">	<span class="comment">// swap(L, low, high);</span></span><br><span class="line">	<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">	L-&gt;r[high] = L-&gt;r[low];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将枢轴值替换回L.r[low]</span></span><br><span class="line">L-&gt;r[low] = temp;</span><br><span class="line"><span class="keyword">return</span> low;</span><br></pre></td></tr></table></figure>
<p>这里可以减少多次交换数据的操作，性能上可以得到一定的提高。</p>
<h6 id="优化小数组时的排序方案"><a href="#优化小数组时的排序方案" class="headerlink" title="优化小数组时的排序方案"></a>优化小数组时的排序方案</h6><p>当数组比较小的时候，快速排序的性能其实还不如直接插入排序(直接插入排序是简单排序中性能最好的)。其原因是快速排序使用了递归操作，在有大量数据排序时，递归操作的影响是可以忽略的，但如果只有少数记录需要排序，这个影响就比较大，所以下面给出改进的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_LENGTH_INSERT_SORT <span class="number">7</span> </span></span><br><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class="line">		<span class="comment">// 当high - low 大于常数时用快速排序</span></span><br><span class="line">		<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">		pivot = Partition(L, low, high);</span><br><span class="line">		<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">		QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 对高子序列递归排序</span></span><br><span class="line">		QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 否则使用直接插入排序</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是先进行一个判断，当数组的数量大于一个预设定的常数时，才进行快速排序，否则就进行直接插入排序。这样可以保证最大化地利用两种排序的优势来完成排序工作。</p>
<h6 id="优化递归操作"><a href="#优化递归操作" class="headerlink" title="优化递归操作"></a>优化递归操作</h6><p>递归对性能是有一定影响的，<code>QSort()</code>在其尾部有两次递归操作，如果待排序的序列划分极端不平衡，递归的深度将趋近于$n$，而不是平衡时的$log_2 n$，这就不仅仅是速度快慢的问题了。栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此，如果能减少递归，将会大大提高性能。</p>
<p>下面给出对<code>QSort()</code>实施尾递归优化的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对待排序序列L中的子序列L-&gt;r[low...high]做快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)&#123;</span><br><span class="line">		<span class="comment">// 当high - low 大于常数时用快速排序</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">			<span class="comment">// 将L-&gt;r[low...high]一分为二，算出枢轴值pivot</span></span><br><span class="line">			pivot = Partition(L, low, high);</span><br><span class="line">			<span class="comment">// 对低子序列递归排序</span></span><br><span class="line">			QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 尾递归</span></span><br><span class="line">			low = pivot + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 否则使用直接插入排序</span></span><br><span class="line">		InsertSort(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中使用<code>while</code>循环，并且去掉原来的对高子序列进行递归，改成代码<code>low = privot + 1</code>，那么在进行一次递归后，再进行循环，就相当于原来的<code>QSort(L,privot+1,high);</code>，结果相同，但是从递归变成了迭代，可以缩减堆栈深度，从而提高了整体性能。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上述总共介绍了7种排序算法，首先是根据排序过程中借助的主要操作，将内排序分为：插入排序、交换排序、选择排序和归并排序，如下图所示。</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png" alt=""></p>
<p>事实上，目前还没有十全十美的排序算法，都是各有优点和缺点，即使是快速排序算法，也只是整体上性能优越，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。</p>
<p>下面对这7种算法的各种指标进行对比，如下图所示：</p>
<p><img src="http://7xrluf.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%954.png" alt=""></p>
<p>从算法的简单性来看，可以分为两类：</p>
<ul>
<li>简单算法：冒泡、简单选择、直接插入。</li>
<li>改进算法：快速、堆、希尔、归并。</li>
</ul>
<p>从平均情况看，快速、堆、归并三种改进算法都优于希尔排序，并远远胜过3种简单算法。</p>
<p>从最好情况看，冒泡和直接插入排序要更好一点，即当待排序序列是基本有序的时候，应该考虑这两种排序算法，而非4种复杂的改进算法。</p>
<p>从最坏情况看，堆和归并排序比其他排序算法都要更好。</p>
<p>从空间复杂度看，归并排序和快速排序都对空间有要求，而其他排序反而都只是$O(1)$的复杂度。</p>
<p>从稳定性上看，归并排序是改进算法中唯一稳定的算法。而不稳定的排序算法有“快些选堆”，即快速、希尔、选择和堆排序四种算法（书中给出的简单选择排序是不稳定的，但是从网上查找资料看到选择排序是一个不稳定的算法）。</p>
<p>排序算法的总结就到这里，实际上还是要根据实际问题来选择适合的排序算法。</p>
<p>全部排序算法的代码可以查看<a href="https://github.com/ccc013/DataStructe-Algorithms_Study/tree/master/SortAlgorithms" target="_blank" rel="external">排序算法实现代码</a>。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag">#数据结构</a>
          
            <a href="/tags/算法/" rel="tag">#算法</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/08/图的基本定义/" rel="next" title="图的基本定义">
                <i class="fa fa-chevron-left"></i> 图的基本定义
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/31/2016总结-2017展望/" rel="prev" title="2016总结 & 2017展望">
                2016总结 & 2017展望 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zOTcyOC8xNjI1NQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.png"
               alt="cai" />
          <p class="site-author-name" itemprop="name">cai</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ccc013" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2181051220?is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/luo-cai" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/lc013?viewmode=contents" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lmj623565791" title="张鸿洋的博客" target="_blank">张鸿洋的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" title="郭霖的博客" target="_blank">郭霖的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/singwhatiwanna/article/category/1405419" title="任玉刚" target="_blank">任玉刚</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/Luoshengyang/" title="罗升阳" target="_blank">罗升阳</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hukai.me/" title="胡凯" target="_blank">胡凯</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.daimajia.com/" title="代码家" target="_blank">代码家</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hujiaweibujidao.github.io/" title="HujiaweiBujidao" target="_blank">HujiaweiBujidao</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.liaoxuefeng.com/" title="廖雪峰的博客" target="_blank">廖雪峰的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://drakeet.me/" title="Drakeet的个人博客" target="_blank">Drakeet的个人博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.kymjs.com/" title="张涛-开源实验室" target="_blank">张涛-开源实验室</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://gudong.name/" title="咕咚" target="_blank">咕咚</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序的基本概念与分类"><span class="nav-number">1.</span> <span class="nav-text">排序的基本概念与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#排序的稳定性"><span class="nav-number">1.1.</span> <span class="nav-text">排序的稳定性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内排序和外排序"><span class="nav-number">1.2.</span> <span class="nav-text">内排序和外排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#时间性能"><span class="nav-number">1.2.1.</span> <span class="nav-text">时间性能</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#辅助空间"><span class="nav-number">1.2.2.</span> <span class="nav-text">辅助空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#算法的复杂性"><span class="nav-number">1.2.3.</span> <span class="nav-text">算法的复杂性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#排序用到的结构与函数"><span class="nav-number">1.3.</span> <span class="nav-text">排序用到的结构与函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序"><span class="nav-number">2.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单选择排序"><span class="nav-number">3.</span> <span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接插入排序"><span class="nav-number">4.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希尔排序"><span class="nav-number">5.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#桶排序"><span class="nav-number">6.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序"><span class="nav-number">7.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">8.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">9.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#快速排序的优化"><span class="nav-number">9.1.</span> <span class="nav-text">快速排序的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优化选取枢轴"><span class="nav-number">9.1.1.</span> <span class="nav-text">优化选取枢轴</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优化不必要的交换"><span class="nav-number">9.1.2.</span> <span class="nav-text">优化不必要的交换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优化小数组时的排序方案"><span class="nav-number">9.1.3.</span> <span class="nav-text">优化小数组时的排序方案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优化递归操作"><span class="nav-number">9.1.4.</span> <span class="nav-text">优化递归操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">10.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cai</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
  
</div>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  
  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>




  
  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("gmEY36PtfOmueA7roORTu2He-gzGzoHsz", "mzEkjGKehJYxfp1PrU0TYsW3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

</body>


<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>



</html>
